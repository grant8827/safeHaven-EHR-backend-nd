
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model SOAPNote
 * 
 */
export type SOAPNote = $Result.DefaultSelection<Prisma.$SOAPNotePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model MessageThread
 * 
 */
export type MessageThread = $Result.DefaultSelection<Prisma.$MessageThreadPayload>
/**
 * Model MessageThreadParticipant
 * 
 */
export type MessageThreadParticipant = $Result.DefaultSelection<Prisma.$MessageThreadParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentShare
 * 
 */
export type DocumentShare = $Result.DefaultSelection<Prisma.$DocumentSharePayload>
/**
 * Model DocumentAccessLog
 * 
 */
export type DocumentAccessLog = $Result.DefaultSelection<Prisma.$DocumentAccessLogPayload>
/**
 * Model TelehealthSession
 * 
 */
export type TelehealthSession = $Result.DefaultSelection<Prisma.$TelehealthSessionPayload>
/**
 * Model TelehealthParticipant
 * 
 */
export type TelehealthParticipant = $Result.DefaultSelection<Prisma.$TelehealthParticipantPayload>
/**
 * Model RecordingMetadata
 * 
 */
export type RecordingMetadata = $Result.DefaultSelection<Prisma.$RecordingMetadataPayload>
/**
 * Model Transcript
 * 
 */
export type Transcript = $Result.DefaultSelection<Prisma.$TranscriptPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  therapist: 'therapist',
  staff: 'staff',
  client: 'client'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppointmentType: {
  initial_consultation: 'initial_consultation',
  therapy_session: 'therapy_session',
  follow_up: 'follow_up',
  group_therapy: 'group_therapy',
  telehealth: 'telehealth',
  assessment: 'assessment'
};

export type AppointmentType = (typeof AppointmentType)[keyof typeof AppointmentType]


export const AppointmentStatus: {
  scheduled: 'scheduled',
  confirmed: 'confirmed',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled',
  no_show: 'no_show',
  rescheduled: 'rescheduled'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const InvoiceStatus: {
  draft: 'draft',
  sent: 'sent',
  paid: 'paid',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const ClaimStatus: {
  draft: 'draft',
  submitted: 'submitted',
  pending: 'pending',
  approved: 'approved',
  denied: 'denied',
  paid: 'paid'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const DocumentCategory: {
  medical_record: 'medical_record',
  insurance: 'insurance',
  consent_form: 'consent_form',
  assessment: 'assessment',
  treatment_plan: 'treatment_plan',
  progress_note: 'progress_note',
  discharge_summary: 'discharge_summary',
  other: 'other'
};

export type DocumentCategory = (typeof DocumentCategory)[keyof typeof DocumentCategory]


export const TelehealthStatus: {
  scheduled: 'scheduled',
  waiting_room: 'waiting_room',
  connecting: 'connecting',
  active: 'active',
  on_hold: 'on_hold',
  ended: 'ended',
  cancelled: 'cancelled',
  failed: 'failed'
};

export type TelehealthStatus = (typeof TelehealthStatus)[keyof typeof TelehealthStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppointmentType = $Enums.AppointmentType

export const AppointmentType: typeof $Enums.AppointmentType

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type DocumentCategory = $Enums.DocumentCategory

export const DocumentCategory: typeof $Enums.DocumentCategory

export type TelehealthStatus = $Enums.TelehealthStatus

export const TelehealthStatus: typeof $Enums.TelehealthStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sOAPNote`: Exposes CRUD operations for the **SOAPNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SOAPNotes
    * const sOAPNotes = await prisma.sOAPNote.findMany()
    * ```
    */
  get sOAPNote(): Prisma.SOAPNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageThread`: Exposes CRUD operations for the **MessageThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageThreads
    * const messageThreads = await prisma.messageThread.findMany()
    * ```
    */
  get messageThread(): Prisma.MessageThreadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageThreadParticipant`: Exposes CRUD operations for the **MessageThreadParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageThreadParticipants
    * const messageThreadParticipants = await prisma.messageThreadParticipant.findMany()
    * ```
    */
  get messageThreadParticipant(): Prisma.MessageThreadParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentShare`: Exposes CRUD operations for the **DocumentShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentShares
    * const documentShares = await prisma.documentShare.findMany()
    * ```
    */
  get documentShare(): Prisma.DocumentShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentAccessLog`: Exposes CRUD operations for the **DocumentAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAccessLogs
    * const documentAccessLogs = await prisma.documentAccessLog.findMany()
    * ```
    */
  get documentAccessLog(): Prisma.DocumentAccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telehealthSession`: Exposes CRUD operations for the **TelehealthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelehealthSessions
    * const telehealthSessions = await prisma.telehealthSession.findMany()
    * ```
    */
  get telehealthSession(): Prisma.TelehealthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telehealthParticipant`: Exposes CRUD operations for the **TelehealthParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelehealthParticipants
    * const telehealthParticipants = await prisma.telehealthParticipant.findMany()
    * ```
    */
  get telehealthParticipant(): Prisma.TelehealthParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recordingMetadata`: Exposes CRUD operations for the **RecordingMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecordingMetadata
    * const recordingMetadata = await prisma.recordingMetadata.findMany()
    * ```
    */
  get recordingMetadata(): Prisma.RecordingMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    PasswordResetToken: 'PasswordResetToken',
    Patient: 'Patient',
    Appointment: 'Appointment',
    SOAPNote: 'SOAPNote',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Claim: 'Claim',
    MessageThread: 'MessageThread',
    MessageThreadParticipant: 'MessageThreadParticipant',
    Message: 'Message',
    MessageAttachment: 'MessageAttachment',
    Document: 'Document',
    DocumentShare: 'DocumentShare',
    DocumentAccessLog: 'DocumentAccessLog',
    TelehealthSession: 'TelehealthSession',
    TelehealthParticipant: 'TelehealthParticipant',
    RecordingMetadata: 'RecordingMetadata',
    Transcript: 'Transcript',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "passwordResetToken" | "patient" | "appointment" | "sOAPNote" | "invoice" | "invoiceItem" | "claim" | "messageThread" | "messageThreadParticipant" | "message" | "messageAttachment" | "document" | "documentShare" | "documentAccessLog" | "telehealthSession" | "telehealthParticipant" | "recordingMetadata" | "transcript" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      SOAPNote: {
        payload: Prisma.$SOAPNotePayload<ExtArgs>
        fields: Prisma.SOAPNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SOAPNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SOAPNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          findFirst: {
            args: Prisma.SOAPNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SOAPNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          findMany: {
            args: Prisma.SOAPNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>[]
          }
          create: {
            args: Prisma.SOAPNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          createMany: {
            args: Prisma.SOAPNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SOAPNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>[]
          }
          delete: {
            args: Prisma.SOAPNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          update: {
            args: Prisma.SOAPNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          deleteMany: {
            args: Prisma.SOAPNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SOAPNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SOAPNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>[]
          }
          upsert: {
            args: Prisma.SOAPNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOAPNotePayload>
          }
          aggregate: {
            args: Prisma.SOAPNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSOAPNote>
          }
          groupBy: {
            args: Prisma.SOAPNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SOAPNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SOAPNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SOAPNoteCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      MessageThread: {
        payload: Prisma.$MessageThreadPayload<ExtArgs>
        fields: Prisma.MessageThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findFirst: {
            args: Prisma.MessageThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findMany: {
            args: Prisma.MessageThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          create: {
            args: Prisma.MessageThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          createMany: {
            args: Prisma.MessageThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          delete: {
            args: Prisma.MessageThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          update: {
            args: Prisma.MessageThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          deleteMany: {
            args: Prisma.MessageThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageThreadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          upsert: {
            args: Prisma.MessageThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          aggregate: {
            args: Prisma.MessageThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageThread>
          }
          groupBy: {
            args: Prisma.MessageThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageThreadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadCountAggregateOutputType> | number
          }
        }
      }
      MessageThreadParticipant: {
        payload: Prisma.$MessageThreadParticipantPayload<ExtArgs>
        fields: Prisma.MessageThreadParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageThreadParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageThreadParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          findFirst: {
            args: Prisma.MessageThreadParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageThreadParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          findMany: {
            args: Prisma.MessageThreadParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>[]
          }
          create: {
            args: Prisma.MessageThreadParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          createMany: {
            args: Prisma.MessageThreadParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageThreadParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>[]
          }
          delete: {
            args: Prisma.MessageThreadParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          update: {
            args: Prisma.MessageThreadParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          deleteMany: {
            args: Prisma.MessageThreadParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageThreadParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageThreadParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>[]
          }
          upsert: {
            args: Prisma.MessageThreadParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadParticipantPayload>
          }
          aggregate: {
            args: Prisma.MessageThreadParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageThreadParticipant>
          }
          groupBy: {
            args: Prisma.MessageThreadParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageThreadParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentShare: {
        payload: Prisma.$DocumentSharePayload<ExtArgs>
        fields: Prisma.DocumentShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          findFirst: {
            args: Prisma.DocumentShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          findMany: {
            args: Prisma.DocumentShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
          }
          create: {
            args: Prisma.DocumentShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          createMany: {
            args: Prisma.DocumentShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
          }
          delete: {
            args: Prisma.DocumentShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          update: {
            args: Prisma.DocumentShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          deleteMany: {
            args: Prisma.DocumentShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
          }
          upsert: {
            args: Prisma.DocumentShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentSharePayload>
          }
          aggregate: {
            args: Prisma.DocumentShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentShare>
          }
          groupBy: {
            args: Prisma.DocumentShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentShareCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentShareCountAggregateOutputType> | number
          }
        }
      }
      DocumentAccessLog: {
        payload: Prisma.$DocumentAccessLogPayload<ExtArgs>
        fields: Prisma.DocumentAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          findFirst: {
            args: Prisma.DocumentAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          findMany: {
            args: Prisma.DocumentAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>[]
          }
          create: {
            args: Prisma.DocumentAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          createMany: {
            args: Prisma.DocumentAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>[]
          }
          delete: {
            args: Prisma.DocumentAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          update: {
            args: Prisma.DocumentAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.DocumentAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentAccessLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>[]
          }
          upsert: {
            args: Prisma.DocumentAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAccessLogPayload>
          }
          aggregate: {
            args: Prisma.DocumentAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAccessLog>
          }
          groupBy: {
            args: Prisma.DocumentAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAccessLogCountAggregateOutputType> | number
          }
        }
      }
      TelehealthSession: {
        payload: Prisma.$TelehealthSessionPayload<ExtArgs>
        fields: Prisma.TelehealthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelehealthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelehealthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          findFirst: {
            args: Prisma.TelehealthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelehealthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          findMany: {
            args: Prisma.TelehealthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>[]
          }
          create: {
            args: Prisma.TelehealthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          createMany: {
            args: Prisma.TelehealthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelehealthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>[]
          }
          delete: {
            args: Prisma.TelehealthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          update: {
            args: Prisma.TelehealthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          deleteMany: {
            args: Prisma.TelehealthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelehealthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelehealthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>[]
          }
          upsert: {
            args: Prisma.TelehealthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthSessionPayload>
          }
          aggregate: {
            args: Prisma.TelehealthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelehealthSession>
          }
          groupBy: {
            args: Prisma.TelehealthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelehealthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelehealthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TelehealthSessionCountAggregateOutputType> | number
          }
        }
      }
      TelehealthParticipant: {
        payload: Prisma.$TelehealthParticipantPayload<ExtArgs>
        fields: Prisma.TelehealthParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelehealthParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelehealthParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          findFirst: {
            args: Prisma.TelehealthParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelehealthParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          findMany: {
            args: Prisma.TelehealthParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>[]
          }
          create: {
            args: Prisma.TelehealthParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          createMany: {
            args: Prisma.TelehealthParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelehealthParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>[]
          }
          delete: {
            args: Prisma.TelehealthParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          update: {
            args: Prisma.TelehealthParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TelehealthParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelehealthParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelehealthParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TelehealthParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelehealthParticipantPayload>
          }
          aggregate: {
            args: Prisma.TelehealthParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelehealthParticipant>
          }
          groupBy: {
            args: Prisma.TelehealthParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelehealthParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelehealthParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TelehealthParticipantCountAggregateOutputType> | number
          }
        }
      }
      RecordingMetadata: {
        payload: Prisma.$RecordingMetadataPayload<ExtArgs>
        fields: Prisma.RecordingMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecordingMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecordingMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          findFirst: {
            args: Prisma.RecordingMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecordingMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          findMany: {
            args: Prisma.RecordingMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>[]
          }
          create: {
            args: Prisma.RecordingMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          createMany: {
            args: Prisma.RecordingMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecordingMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>[]
          }
          delete: {
            args: Prisma.RecordingMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          update: {
            args: Prisma.RecordingMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          deleteMany: {
            args: Prisma.RecordingMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecordingMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecordingMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>[]
          }
          upsert: {
            args: Prisma.RecordingMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordingMetadataPayload>
          }
          aggregate: {
            args: Prisma.RecordingMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecordingMetadata>
          }
          groupBy: {
            args: Prisma.RecordingMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecordingMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecordingMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<RecordingMetadataCountAggregateOutputType> | number
          }
        }
      }
      Transcript: {
        payload: Prisma.$TranscriptPayload<ExtArgs>
        fields: Prisma.TranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findFirst: {
            args: Prisma.TranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findMany: {
            args: Prisma.TranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          create: {
            args: Prisma.TranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          createMany: {
            args: Prisma.TranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          delete: {
            args: Prisma.TranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          update: {
            args: Prisma.TranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          aggregate: {
            args: Prisma.TranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscript>
          }
          groupBy: {
            args: Prisma.TranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    patient?: PatientOmit
    appointment?: AppointmentOmit
    sOAPNote?: SOAPNoteOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    claim?: ClaimOmit
    messageThread?: MessageThreadOmit
    messageThreadParticipant?: MessageThreadParticipantOmit
    message?: MessageOmit
    messageAttachment?: MessageAttachmentOmit
    document?: DocumentOmit
    documentShare?: DocumentShareOmit
    documentAccessLog?: DocumentAccessLogOmit
    telehealthSession?: TelehealthSessionOmit
    telehealthParticipant?: TelehealthParticipantOmit
    recordingMetadata?: RecordingMetadataOmit
    transcript?: TranscriptOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    passwordResetTokens: number
    auditLogs: number
    assignedPatients: number
    appointments: number
    createdAppointments: number
    sentMessages: number
    readMessages: number
    messageThreadParticipants: number
    createdInvoices: number
    createdNotes: number
    sessionParticipants: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    assignedPatients?: boolean | UserCountOutputTypeCountAssignedPatientsArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    createdAppointments?: boolean | UserCountOutputTypeCountCreatedAppointmentsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    readMessages?: boolean | UserCountOutputTypeCountReadMessagesArgs
    messageThreadParticipants?: boolean | UserCountOutputTypeCountMessageThreadParticipantsArgs
    createdInvoices?: boolean | UserCountOutputTypeCountCreatedInvoicesArgs
    createdNotes?: boolean | UserCountOutputTypeCountCreatedNotesArgs
    sessionParticipants?: boolean | UserCountOutputTypeCountSessionParticipantsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageThreadParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOAPNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelehealthParticipantWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    invoices: number
    soapNotes: number
    documents: number
    sessions: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    soapNotes?: boolean | PatientCountOutputTypeCountSoapNotesArgs
    documents?: boolean | PatientCountOutputTypeCountDocumentsArgs
    sessions?: boolean | PatientCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountSoapNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOAPNoteWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelehealthSessionWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type MessageThreadCountOutputType
   */

  export type MessageThreadCountOutputType = {
    messages: number
    participants: number
  }

  export type MessageThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageThreadCountOutputTypeCountMessagesArgs
    participants?: boolean | MessageThreadCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadCountOutputType
     */
    select?: MessageThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadParticipantWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    shares: number
    accessHistory: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shares?: boolean | DocumentCountOutputTypeCountSharesArgs
    accessHistory?: boolean | DocumentCountOutputTypeCountAccessHistoryArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentShareWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountAccessHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAccessLogWhereInput
  }


  /**
   * Count Type TelehealthSessionCountOutputType
   */

  export type TelehealthSessionCountOutputType = {
    participants: number
    recordings: number
    transcripts: number
  }

  export type TelehealthSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TelehealthSessionCountOutputTypeCountParticipantsArgs
    recordings?: boolean | TelehealthSessionCountOutputTypeCountRecordingsArgs
    transcripts?: boolean | TelehealthSessionCountOutputTypeCountTranscriptsArgs
  }

  // Custom InputTypes
  /**
   * TelehealthSessionCountOutputType without action
   */
  export type TelehealthSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSessionCountOutputType
     */
    select?: TelehealthSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TelehealthSessionCountOutputType without action
   */
  export type TelehealthSessionCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelehealthParticipantWhereInput
  }

  /**
   * TelehealthSessionCountOutputType without action
   */
  export type TelehealthSessionCountOutputTypeCountRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordingMetadataWhereInput
  }

  /**
   * TelehealthSessionCountOutputType without action
   */
  export type TelehealthSessionCountOutputTypeCountTranscriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    mustChangePassword: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    mustChangePassword: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    phoneNumber: number
    role: number
    isActive: number
    mustChangePassword: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    role?: true
    isActive?: true
    mustChangePassword?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    role?: true
    isActive?: true
    mustChangePassword?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    role?: true
    isActive?: true
    mustChangePassword?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber: string | null
    role: $Enums.UserRole
    isActive: boolean
    mustChangePassword: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    role?: boolean
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    patientProfile?: boolean | User$patientProfileArgs<ExtArgs>
    assignedPatients?: boolean | User$assignedPatientsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    createdAppointments?: boolean | User$createdAppointmentsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    readMessages?: boolean | User$readMessagesArgs<ExtArgs>
    messageThreadParticipants?: boolean | User$messageThreadParticipantsArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    createdNotes?: boolean | User$createdNotesArgs<ExtArgs>
    sessionParticipants?: boolean | User$sessionParticipantsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    role?: boolean
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    role?: boolean
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    role?: boolean
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phoneNumber" | "role" | "isActive" | "mustChangePassword" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    patientProfile?: boolean | User$patientProfileArgs<ExtArgs>
    assignedPatients?: boolean | User$assignedPatientsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    createdAppointments?: boolean | User$createdAppointmentsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    readMessages?: boolean | User$readMessagesArgs<ExtArgs>
    messageThreadParticipants?: boolean | User$messageThreadParticipantsArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    createdNotes?: boolean | User$createdNotesArgs<ExtArgs>
    sessionParticipants?: boolean | User$sessionParticipantsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      patientProfile: Prisma.$PatientPayload<ExtArgs> | null
      assignedPatients: Prisma.$PatientPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      createdAppointments: Prisma.$AppointmentPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      readMessages: Prisma.$MessagePayload<ExtArgs>[]
      messageThreadParticipants: Prisma.$MessageThreadParticipantPayload<ExtArgs>[]
      createdInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      createdNotes: Prisma.$SOAPNotePayload<ExtArgs>[]
      sessionParticipants: Prisma.$TelehealthParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      phoneNumber: string | null
      role: $Enums.UserRole
      isActive: boolean
      mustChangePassword: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patientProfile<T extends User$patientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$patientProfileArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedPatients<T extends User$assignedPatientsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedPatientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAppointments<T extends User$createdAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readMessages<T extends User$readMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$readMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messageThreadParticipants<T extends User$messageThreadParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageThreadParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdInvoices<T extends User$createdInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdNotes<T extends User$createdNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionParticipants<T extends User$sessionParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly mustChangePassword: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.patientProfile
   */
  export type User$patientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * User.assignedPatients
   */
  export type User$assignedPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.createdAppointments
   */
  export type User$createdAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.readMessages
   */
  export type User$readMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messageThreadParticipants
   */
  export type User$messageThreadParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    where?: MessageThreadParticipantWhereInput
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    cursor?: MessageThreadParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageThreadParticipantScalarFieldEnum | MessageThreadParticipantScalarFieldEnum[]
  }

  /**
   * User.createdInvoices
   */
  export type User$createdInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.createdNotes
   */
  export type User$createdNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    where?: SOAPNoteWhereInput
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    cursor?: SOAPNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOAPNoteScalarFieldEnum | SOAPNoteScalarFieldEnum[]
  }

  /**
   * User.sessionParticipants
   */
  export type User$sessionParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    where?: TelehealthParticipantWhereInput
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    cursor?: TelehealthParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelehealthParticipantScalarFieldEnum | TelehealthParticipantScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    revokedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    revokedAt: Date | null
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "revokedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      revokedAt: Date | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "usedAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    insuranceCopay: number | null
    insuranceDeductible: number | null
  }

  export type PatientSumAggregateOutputType = {
    insuranceCopay: number | null
    insuranceDeductible: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactRelationship: string | null
    emergencyContactPhone: string | null
    emergencyContactEmail: string | null
    insuranceProvider: string | null
    insurancePolicyNumber: string | null
    insuranceGroupNumber: string | null
    insuranceCopay: number | null
    insuranceDeductible: number | null
    medicalHistory: string | null
    allergies: string | null
    assignedTherapistId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactRelationship: string | null
    emergencyContactPhone: string | null
    emergencyContactEmail: string | null
    insuranceProvider: string | null
    insurancePolicyNumber: string | null
    insuranceGroupNumber: string | null
    insuranceCopay: number | null
    insuranceDeductible: number | null
    medicalHistory: string | null
    allergies: string | null
    assignedTherapistId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    userId: number
    dateOfBirth: number
    street: number
    city: number
    state: number
    zipCode: number
    country: number
    emergencyContactName: number
    emergencyContactRelationship: number
    emergencyContactPhone: number
    emergencyContactEmail: number
    insuranceProvider: number
    insurancePolicyNumber: number
    insuranceGroupNumber: number
    insuranceCopay: number
    insuranceDeductible: number
    medicalHistory: number
    allergies: number
    assignedTherapistId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    insuranceCopay?: true
    insuranceDeductible?: true
  }

  export type PatientSumAggregateInputType = {
    insuranceCopay?: true
    insuranceDeductible?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    userId?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactRelationship?: true
    emergencyContactPhone?: true
    emergencyContactEmail?: true
    insuranceProvider?: true
    insurancePolicyNumber?: true
    insuranceGroupNumber?: true
    insuranceCopay?: true
    insuranceDeductible?: true
    medicalHistory?: true
    allergies?: true
    assignedTherapistId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    userId?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactRelationship?: true
    emergencyContactPhone?: true
    emergencyContactEmail?: true
    insuranceProvider?: true
    insurancePolicyNumber?: true
    insuranceGroupNumber?: true
    insuranceCopay?: true
    insuranceDeductible?: true
    medicalHistory?: true
    allergies?: true
    assignedTherapistId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    userId?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactRelationship?: true
    emergencyContactPhone?: true
    emergencyContactEmail?: true
    insuranceProvider?: true
    insurancePolicyNumber?: true
    insuranceGroupNumber?: true
    insuranceCopay?: true
    insuranceDeductible?: true
    medicalHistory?: true
    allergies?: true
    assignedTherapistId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    userId: string
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactRelationship: string | null
    emergencyContactPhone: string | null
    emergencyContactEmail: string | null
    insuranceProvider: string | null
    insurancePolicyNumber: string | null
    insuranceGroupNumber: string | null
    insuranceCopay: number | null
    insuranceDeductible: number | null
    medicalHistory: string | null
    allergies: string | null
    assignedTherapistId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactRelationship?: boolean
    emergencyContactPhone?: boolean
    emergencyContactEmail?: boolean
    insuranceProvider?: boolean
    insurancePolicyNumber?: boolean
    insuranceGroupNumber?: boolean
    insuranceCopay?: boolean
    insuranceDeductible?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    assignedTherapistId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    soapNotes?: boolean | Patient$soapNotesArgs<ExtArgs>
    documents?: boolean | Patient$documentsArgs<ExtArgs>
    sessions?: boolean | Patient$sessionsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactRelationship?: boolean
    emergencyContactPhone?: boolean
    emergencyContactEmail?: boolean
    insuranceProvider?: boolean
    insurancePolicyNumber?: boolean
    insuranceGroupNumber?: boolean
    insuranceCopay?: boolean
    insuranceDeductible?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    assignedTherapistId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactRelationship?: boolean
    emergencyContactPhone?: boolean
    emergencyContactEmail?: boolean
    insuranceProvider?: boolean
    insurancePolicyNumber?: boolean
    insuranceGroupNumber?: boolean
    insuranceCopay?: boolean
    insuranceDeductible?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    assignedTherapistId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    userId?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactRelationship?: boolean
    emergencyContactPhone?: boolean
    emergencyContactEmail?: boolean
    insuranceProvider?: boolean
    insurancePolicyNumber?: boolean
    insuranceGroupNumber?: boolean
    insuranceCopay?: boolean
    insuranceDeductible?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    assignedTherapistId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dateOfBirth" | "street" | "city" | "state" | "zipCode" | "country" | "emergencyContactName" | "emergencyContactRelationship" | "emergencyContactPhone" | "emergencyContactEmail" | "insuranceProvider" | "insurancePolicyNumber" | "insuranceGroupNumber" | "insuranceCopay" | "insuranceDeductible" | "medicalHistory" | "allergies" | "assignedTherapistId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    soapNotes?: boolean | Patient$soapNotesArgs<ExtArgs>
    documents?: boolean | Patient$documentsArgs<ExtArgs>
    sessions?: boolean | Patient$sessionsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTherapist?: boolean | Patient$assignedTherapistArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignedTherapist: Prisma.$UserPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      soapNotes: Prisma.$SOAPNotePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      sessions: Prisma.$TelehealthSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dateOfBirth: Date | null
      street: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
      emergencyContactName: string | null
      emergencyContactRelationship: string | null
      emergencyContactPhone: string | null
      emergencyContactEmail: string | null
      insuranceProvider: string | null
      insurancePolicyNumber: string | null
      insuranceGroupNumber: string | null
      insuranceCopay: number | null
      insuranceDeductible: number | null
      medicalHistory: string | null
      allergies: string | null
      assignedTherapistId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTherapist<T extends Patient$assignedTherapistArgs<ExtArgs> = {}>(args?: Subset<T, Patient$assignedTherapistArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soapNotes<T extends Patient$soapNotesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$soapNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Patient$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Patient$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly userId: FieldRef<"Patient", 'String'>
    readonly dateOfBirth: FieldRef<"Patient", 'DateTime'>
    readonly street: FieldRef<"Patient", 'String'>
    readonly city: FieldRef<"Patient", 'String'>
    readonly state: FieldRef<"Patient", 'String'>
    readonly zipCode: FieldRef<"Patient", 'String'>
    readonly country: FieldRef<"Patient", 'String'>
    readonly emergencyContactName: FieldRef<"Patient", 'String'>
    readonly emergencyContactRelationship: FieldRef<"Patient", 'String'>
    readonly emergencyContactPhone: FieldRef<"Patient", 'String'>
    readonly emergencyContactEmail: FieldRef<"Patient", 'String'>
    readonly insuranceProvider: FieldRef<"Patient", 'String'>
    readonly insurancePolicyNumber: FieldRef<"Patient", 'String'>
    readonly insuranceGroupNumber: FieldRef<"Patient", 'String'>
    readonly insuranceCopay: FieldRef<"Patient", 'Float'>
    readonly insuranceDeductible: FieldRef<"Patient", 'Float'>
    readonly medicalHistory: FieldRef<"Patient", 'String'>
    readonly allergies: FieldRef<"Patient", 'String'>
    readonly assignedTherapistId: FieldRef<"Patient", 'String'>
    readonly isActive: FieldRef<"Patient", 'Boolean'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.assignedTherapist
   */
  export type Patient$assignedTherapistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.soapNotes
   */
  export type Patient$soapNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    where?: SOAPNoteWhereInput
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    cursor?: SOAPNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOAPNoteScalarFieldEnum | SOAPNoteScalarFieldEnum[]
  }

  /**
   * Patient.documents
   */
  export type Patient$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Patient.sessions
   */
  export type Patient$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    where?: TelehealthSessionWhereInput
    orderBy?: TelehealthSessionOrderByWithRelationInput | TelehealthSessionOrderByWithRelationInput[]
    cursor?: TelehealthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelehealthSessionScalarFieldEnum | TelehealthSessionScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    therapistId: string | null
    createdById: string | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.AppointmentType | null
    status: $Enums.AppointmentStatus | null
    notes: string | null
    telehealthLink: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    therapistId: string | null
    createdById: string | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.AppointmentType | null
    status: $Enums.AppointmentStatus | null
    notes: string | null
    telehealthLink: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    therapistId: number
    createdById: number
    startTime: number
    endTime: number
    type: number
    status: number
    notes: number
    telehealthLink: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    createdById?: true
    startTime?: true
    endTime?: true
    type?: true
    status?: true
    notes?: true
    telehealthLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    createdById?: true
    startTime?: true
    endTime?: true
    type?: true
    status?: true
    notes?: true
    telehealthLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    createdById?: true
    startTime?: true
    endTime?: true
    type?: true
    status?: true
    notes?: true
    telehealthLink?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date
    endTime: Date
    type: $Enums.AppointmentType
    status: $Enums.AppointmentStatus
    notes: string | null
    telehealthLink: string | null
    location: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    createdById?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    telehealthLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    soapNote?: boolean | Appointment$soapNoteArgs<ExtArgs>
    invoice?: boolean | Appointment$invoiceArgs<ExtArgs>
    session?: boolean | Appointment$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    createdById?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    telehealthLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    createdById?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    telehealthLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    createdById?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    telehealthLink?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "therapistId" | "createdById" | "startTime" | "endTime" | "type" | "status" | "notes" | "telehealthLink" | "location" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    soapNote?: boolean | Appointment$soapNoteArgs<ExtArgs>
    invoice?: boolean | Appointment$invoiceArgs<ExtArgs>
    session?: boolean | Appointment$sessionArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      therapist: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      soapNote: Prisma.$SOAPNotePayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      session: Prisma.$TelehealthSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      therapistId: string
      createdById: string
      startTime: Date
      endTime: Date
      type: $Enums.AppointmentType
      status: $Enums.AppointmentStatus
      notes: string | null
      telehealthLink: string | null
      location: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    therapist<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    soapNote<T extends Appointment$soapNoteArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$soapNoteArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Appointment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends Appointment$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$sessionArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly therapistId: FieldRef<"Appointment", 'String'>
    readonly createdById: FieldRef<"Appointment", 'String'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly type: FieldRef<"Appointment", 'AppointmentType'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly telehealthLink: FieldRef<"Appointment", 'String'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.soapNote
   */
  export type Appointment$soapNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    where?: SOAPNoteWhereInput
  }

  /**
   * Appointment.invoice
   */
  export type Appointment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Appointment.session
   */
  export type Appointment$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    where?: TelehealthSessionWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model SOAPNote
   */

  export type AggregateSOAPNote = {
    _count: SOAPNoteCountAggregateOutputType | null
    _min: SOAPNoteMinAggregateOutputType | null
    _max: SOAPNoteMaxAggregateOutputType | null
  }

  export type SOAPNoteMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    therapistId: string | null
    appointmentId: string | null
    date: Date | null
    subjective: string | null
    objective: string | null
    assessment: string | null
    plan: string | null
    signature: string | null
    signatureDate: Date | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SOAPNoteMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    therapistId: string | null
    appointmentId: string | null
    date: Date | null
    subjective: string | null
    objective: string | null
    assessment: string | null
    plan: string | null
    signature: string | null
    signatureDate: Date | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SOAPNoteCountAggregateOutputType = {
    id: number
    patientId: number
    therapistId: number
    appointmentId: number
    date: number
    subjective: number
    objective: number
    assessment: number
    plan: number
    signature: number
    signatureDate: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SOAPNoteMinAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    appointmentId?: true
    date?: true
    subjective?: true
    objective?: true
    assessment?: true
    plan?: true
    signature?: true
    signatureDate?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SOAPNoteMaxAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    appointmentId?: true
    date?: true
    subjective?: true
    objective?: true
    assessment?: true
    plan?: true
    signature?: true
    signatureDate?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SOAPNoteCountAggregateInputType = {
    id?: true
    patientId?: true
    therapistId?: true
    appointmentId?: true
    date?: true
    subjective?: true
    objective?: true
    assessment?: true
    plan?: true
    signature?: true
    signatureDate?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SOAPNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOAPNote to aggregate.
     */
    where?: SOAPNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOAPNotes to fetch.
     */
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SOAPNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOAPNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOAPNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SOAPNotes
    **/
    _count?: true | SOAPNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SOAPNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SOAPNoteMaxAggregateInputType
  }

  export type GetSOAPNoteAggregateType<T extends SOAPNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSOAPNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSOAPNote[P]>
      : GetScalarType<T[P], AggregateSOAPNote[P]>
  }




  export type SOAPNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOAPNoteWhereInput
    orderBy?: SOAPNoteOrderByWithAggregationInput | SOAPNoteOrderByWithAggregationInput[]
    by: SOAPNoteScalarFieldEnum[] | SOAPNoteScalarFieldEnum
    having?: SOAPNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SOAPNoteCountAggregateInputType | true
    _min?: SOAPNoteMinAggregateInputType
    _max?: SOAPNoteMaxAggregateInputType
  }

  export type SOAPNoteGroupByOutputType = {
    id: string
    patientId: string
    therapistId: string
    appointmentId: string | null
    date: Date
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature: string | null
    signatureDate: Date | null
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: SOAPNoteCountAggregateOutputType | null
    _min: SOAPNoteMinAggregateOutputType | null
    _max: SOAPNoteMaxAggregateOutputType | null
  }

  type GetSOAPNoteGroupByPayload<T extends SOAPNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SOAPNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SOAPNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SOAPNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SOAPNoteGroupByOutputType[P]>
        }
      >
    >


  export type SOAPNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    appointmentId?: boolean
    date?: boolean
    subjective?: boolean
    objective?: boolean
    assessment?: boolean
    plan?: boolean
    signature?: boolean
    signatureDate?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["sOAPNote"]>

  export type SOAPNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    appointmentId?: boolean
    date?: boolean
    subjective?: boolean
    objective?: boolean
    assessment?: boolean
    plan?: boolean
    signature?: boolean
    signatureDate?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["sOAPNote"]>

  export type SOAPNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    appointmentId?: boolean
    date?: boolean
    subjective?: boolean
    objective?: boolean
    assessment?: boolean
    plan?: boolean
    signature?: boolean
    signatureDate?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["sOAPNote"]>

  export type SOAPNoteSelectScalar = {
    id?: boolean
    patientId?: boolean
    therapistId?: boolean
    appointmentId?: boolean
    date?: boolean
    subjective?: boolean
    objective?: boolean
    assessment?: boolean
    plan?: boolean
    signature?: boolean
    signatureDate?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SOAPNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "therapistId" | "appointmentId" | "date" | "subjective" | "objective" | "assessment" | "plan" | "signature" | "signatureDate" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["sOAPNote"]>
  export type SOAPNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }
  export type SOAPNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }
  export type SOAPNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    therapist?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | SOAPNote$appointmentArgs<ExtArgs>
  }

  export type $SOAPNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SOAPNote"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      therapist: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      therapistId: string
      appointmentId: string | null
      date: Date
      subjective: string
      objective: string
      assessment: string
      plan: string
      signature: string | null
      signatureDate: Date | null
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sOAPNote"]>
    composites: {}
  }

  type SOAPNoteGetPayload<S extends boolean | null | undefined | SOAPNoteDefaultArgs> = $Result.GetResult<Prisma.$SOAPNotePayload, S>

  type SOAPNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SOAPNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SOAPNoteCountAggregateInputType | true
    }

  export interface SOAPNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SOAPNote'], meta: { name: 'SOAPNote' } }
    /**
     * Find zero or one SOAPNote that matches the filter.
     * @param {SOAPNoteFindUniqueArgs} args - Arguments to find a SOAPNote
     * @example
     * // Get one SOAPNote
     * const sOAPNote = await prisma.sOAPNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SOAPNoteFindUniqueArgs>(args: SelectSubset<T, SOAPNoteFindUniqueArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SOAPNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SOAPNoteFindUniqueOrThrowArgs} args - Arguments to find a SOAPNote
     * @example
     * // Get one SOAPNote
     * const sOAPNote = await prisma.sOAPNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SOAPNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SOAPNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOAPNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteFindFirstArgs} args - Arguments to find a SOAPNote
     * @example
     * // Get one SOAPNote
     * const sOAPNote = await prisma.sOAPNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SOAPNoteFindFirstArgs>(args?: SelectSubset<T, SOAPNoteFindFirstArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOAPNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteFindFirstOrThrowArgs} args - Arguments to find a SOAPNote
     * @example
     * // Get one SOAPNote
     * const sOAPNote = await prisma.sOAPNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SOAPNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SOAPNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SOAPNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SOAPNotes
     * const sOAPNotes = await prisma.sOAPNote.findMany()
     * 
     * // Get first 10 SOAPNotes
     * const sOAPNotes = await prisma.sOAPNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sOAPNoteWithIdOnly = await prisma.sOAPNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SOAPNoteFindManyArgs>(args?: SelectSubset<T, SOAPNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SOAPNote.
     * @param {SOAPNoteCreateArgs} args - Arguments to create a SOAPNote.
     * @example
     * // Create one SOAPNote
     * const SOAPNote = await prisma.sOAPNote.create({
     *   data: {
     *     // ... data to create a SOAPNote
     *   }
     * })
     * 
     */
    create<T extends SOAPNoteCreateArgs>(args: SelectSubset<T, SOAPNoteCreateArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SOAPNotes.
     * @param {SOAPNoteCreateManyArgs} args - Arguments to create many SOAPNotes.
     * @example
     * // Create many SOAPNotes
     * const sOAPNote = await prisma.sOAPNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SOAPNoteCreateManyArgs>(args?: SelectSubset<T, SOAPNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SOAPNotes and returns the data saved in the database.
     * @param {SOAPNoteCreateManyAndReturnArgs} args - Arguments to create many SOAPNotes.
     * @example
     * // Create many SOAPNotes
     * const sOAPNote = await prisma.sOAPNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SOAPNotes and only return the `id`
     * const sOAPNoteWithIdOnly = await prisma.sOAPNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SOAPNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SOAPNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SOAPNote.
     * @param {SOAPNoteDeleteArgs} args - Arguments to delete one SOAPNote.
     * @example
     * // Delete one SOAPNote
     * const SOAPNote = await prisma.sOAPNote.delete({
     *   where: {
     *     // ... filter to delete one SOAPNote
     *   }
     * })
     * 
     */
    delete<T extends SOAPNoteDeleteArgs>(args: SelectSubset<T, SOAPNoteDeleteArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SOAPNote.
     * @param {SOAPNoteUpdateArgs} args - Arguments to update one SOAPNote.
     * @example
     * // Update one SOAPNote
     * const sOAPNote = await prisma.sOAPNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SOAPNoteUpdateArgs>(args: SelectSubset<T, SOAPNoteUpdateArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SOAPNotes.
     * @param {SOAPNoteDeleteManyArgs} args - Arguments to filter SOAPNotes to delete.
     * @example
     * // Delete a few SOAPNotes
     * const { count } = await prisma.sOAPNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SOAPNoteDeleteManyArgs>(args?: SelectSubset<T, SOAPNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SOAPNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SOAPNotes
     * const sOAPNote = await prisma.sOAPNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SOAPNoteUpdateManyArgs>(args: SelectSubset<T, SOAPNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SOAPNotes and returns the data updated in the database.
     * @param {SOAPNoteUpdateManyAndReturnArgs} args - Arguments to update many SOAPNotes.
     * @example
     * // Update many SOAPNotes
     * const sOAPNote = await prisma.sOAPNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SOAPNotes and only return the `id`
     * const sOAPNoteWithIdOnly = await prisma.sOAPNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SOAPNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, SOAPNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SOAPNote.
     * @param {SOAPNoteUpsertArgs} args - Arguments to update or create a SOAPNote.
     * @example
     * // Update or create a SOAPNote
     * const sOAPNote = await prisma.sOAPNote.upsert({
     *   create: {
     *     // ... data to create a SOAPNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SOAPNote we want to update
     *   }
     * })
     */
    upsert<T extends SOAPNoteUpsertArgs>(args: SelectSubset<T, SOAPNoteUpsertArgs<ExtArgs>>): Prisma__SOAPNoteClient<$Result.GetResult<Prisma.$SOAPNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SOAPNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteCountArgs} args - Arguments to filter SOAPNotes to count.
     * @example
     * // Count the number of SOAPNotes
     * const count = await prisma.sOAPNote.count({
     *   where: {
     *     // ... the filter for the SOAPNotes we want to count
     *   }
     * })
    **/
    count<T extends SOAPNoteCountArgs>(
      args?: Subset<T, SOAPNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SOAPNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SOAPNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SOAPNoteAggregateArgs>(args: Subset<T, SOAPNoteAggregateArgs>): Prisma.PrismaPromise<GetSOAPNoteAggregateType<T>>

    /**
     * Group by SOAPNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOAPNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SOAPNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SOAPNoteGroupByArgs['orderBy'] }
        : { orderBy?: SOAPNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SOAPNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSOAPNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SOAPNote model
   */
  readonly fields: SOAPNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SOAPNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SOAPNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    therapist<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends SOAPNote$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, SOAPNote$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SOAPNote model
   */
  interface SOAPNoteFieldRefs {
    readonly id: FieldRef<"SOAPNote", 'String'>
    readonly patientId: FieldRef<"SOAPNote", 'String'>
    readonly therapistId: FieldRef<"SOAPNote", 'String'>
    readonly appointmentId: FieldRef<"SOAPNote", 'String'>
    readonly date: FieldRef<"SOAPNote", 'DateTime'>
    readonly subjective: FieldRef<"SOAPNote", 'String'>
    readonly objective: FieldRef<"SOAPNote", 'String'>
    readonly assessment: FieldRef<"SOAPNote", 'String'>
    readonly plan: FieldRef<"SOAPNote", 'String'>
    readonly signature: FieldRef<"SOAPNote", 'String'>
    readonly signatureDate: FieldRef<"SOAPNote", 'DateTime'>
    readonly isLocked: FieldRef<"SOAPNote", 'Boolean'>
    readonly createdAt: FieldRef<"SOAPNote", 'DateTime'>
    readonly updatedAt: FieldRef<"SOAPNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SOAPNote findUnique
   */
  export type SOAPNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter, which SOAPNote to fetch.
     */
    where: SOAPNoteWhereUniqueInput
  }

  /**
   * SOAPNote findUniqueOrThrow
   */
  export type SOAPNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter, which SOAPNote to fetch.
     */
    where: SOAPNoteWhereUniqueInput
  }

  /**
   * SOAPNote findFirst
   */
  export type SOAPNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter, which SOAPNote to fetch.
     */
    where?: SOAPNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOAPNotes to fetch.
     */
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOAPNotes.
     */
    cursor?: SOAPNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOAPNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOAPNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOAPNotes.
     */
    distinct?: SOAPNoteScalarFieldEnum | SOAPNoteScalarFieldEnum[]
  }

  /**
   * SOAPNote findFirstOrThrow
   */
  export type SOAPNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter, which SOAPNote to fetch.
     */
    where?: SOAPNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOAPNotes to fetch.
     */
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOAPNotes.
     */
    cursor?: SOAPNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOAPNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOAPNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOAPNotes.
     */
    distinct?: SOAPNoteScalarFieldEnum | SOAPNoteScalarFieldEnum[]
  }

  /**
   * SOAPNote findMany
   */
  export type SOAPNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter, which SOAPNotes to fetch.
     */
    where?: SOAPNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOAPNotes to fetch.
     */
    orderBy?: SOAPNoteOrderByWithRelationInput | SOAPNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SOAPNotes.
     */
    cursor?: SOAPNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOAPNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOAPNotes.
     */
    skip?: number
    distinct?: SOAPNoteScalarFieldEnum | SOAPNoteScalarFieldEnum[]
  }

  /**
   * SOAPNote create
   */
  export type SOAPNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SOAPNote.
     */
    data: XOR<SOAPNoteCreateInput, SOAPNoteUncheckedCreateInput>
  }

  /**
   * SOAPNote createMany
   */
  export type SOAPNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SOAPNotes.
     */
    data: SOAPNoteCreateManyInput | SOAPNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SOAPNote createManyAndReturn
   */
  export type SOAPNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * The data used to create many SOAPNotes.
     */
    data: SOAPNoteCreateManyInput | SOAPNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SOAPNote update
   */
  export type SOAPNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SOAPNote.
     */
    data: XOR<SOAPNoteUpdateInput, SOAPNoteUncheckedUpdateInput>
    /**
     * Choose, which SOAPNote to update.
     */
    where: SOAPNoteWhereUniqueInput
  }

  /**
   * SOAPNote updateMany
   */
  export type SOAPNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SOAPNotes.
     */
    data: XOR<SOAPNoteUpdateManyMutationInput, SOAPNoteUncheckedUpdateManyInput>
    /**
     * Filter which SOAPNotes to update
     */
    where?: SOAPNoteWhereInput
    /**
     * Limit how many SOAPNotes to update.
     */
    limit?: number
  }

  /**
   * SOAPNote updateManyAndReturn
   */
  export type SOAPNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * The data used to update SOAPNotes.
     */
    data: XOR<SOAPNoteUpdateManyMutationInput, SOAPNoteUncheckedUpdateManyInput>
    /**
     * Filter which SOAPNotes to update
     */
    where?: SOAPNoteWhereInput
    /**
     * Limit how many SOAPNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SOAPNote upsert
   */
  export type SOAPNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SOAPNote to update in case it exists.
     */
    where: SOAPNoteWhereUniqueInput
    /**
     * In case the SOAPNote found by the `where` argument doesn't exist, create a new SOAPNote with this data.
     */
    create: XOR<SOAPNoteCreateInput, SOAPNoteUncheckedCreateInput>
    /**
     * In case the SOAPNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SOAPNoteUpdateInput, SOAPNoteUncheckedUpdateInput>
  }

  /**
   * SOAPNote delete
   */
  export type SOAPNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
    /**
     * Filter which SOAPNote to delete.
     */
    where: SOAPNoteWhereUniqueInput
  }

  /**
   * SOAPNote deleteMany
   */
  export type SOAPNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOAPNotes to delete
     */
    where?: SOAPNoteWhereInput
    /**
     * Limit how many SOAPNotes to delete.
     */
    limit?: number
  }

  /**
   * SOAPNote.appointment
   */
  export type SOAPNote$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * SOAPNote without action
   */
  export type SOAPNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOAPNote
     */
    select?: SOAPNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOAPNote
     */
    omit?: SOAPNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOAPNoteInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    appointmentId: string | null
    createdById: string | null
    invoiceNumber: string | null
    date: Date | null
    dueDate: Date | null
    subtotal: number | null
    tax: number | null
    total: number | null
    status: $Enums.InvoiceStatus | null
    paymentDate: Date | null
    paymentMethod: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    appointmentId: string | null
    createdById: string | null
    invoiceNumber: string | null
    date: Date | null
    dueDate: Date | null
    subtotal: number | null
    tax: number | null
    total: number | null
    status: $Enums.InvoiceStatus | null
    paymentDate: Date | null
    paymentMethod: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    patientId: number
    appointmentId: number
    createdById: number
    invoiceNumber: number
    date: number
    dueDate: number
    subtotal: number
    tax: number
    total: number
    status: number
    paymentDate: number
    paymentMethod: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    patientId?: true
    appointmentId?: true
    createdById?: true
    invoiceNumber?: true
    date?: true
    dueDate?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    patientId?: true
    appointmentId?: true
    createdById?: true
    invoiceNumber?: true
    date?: true
    dueDate?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    patientId?: true
    appointmentId?: true
    createdById?: true
    invoiceNumber?: true
    date?: true
    dueDate?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    patientId: string
    appointmentId: string | null
    createdById: string
    invoiceNumber: string
    date: Date
    dueDate: Date
    subtotal: number
    tax: number
    total: number
    status: $Enums.InvoiceStatus
    paymentDate: Date | null
    paymentMethod: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    appointmentId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    date?: boolean
    dueDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    claim?: boolean | Invoice$claimArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    appointmentId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    date?: boolean
    dueDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    appointmentId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    date?: boolean
    dueDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    patientId?: boolean
    appointmentId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    date?: boolean
    dueDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "appointmentId" | "createdById" | "invoiceNumber" | "date" | "dueDate" | "subtotal" | "tax" | "total" | "status" | "paymentDate" | "paymentMethod" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    claim?: boolean | Invoice$claimArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    appointment?: boolean | Invoice$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      claim: Prisma.$ClaimPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      appointmentId: string | null
      createdById: string
      invoiceNumber: string
      date: Date
      dueDate: Date
      subtotal: number
      tax: number
      total: number
      status: $Enums.InvoiceStatus
      paymentDate: Date | null
      paymentMethod: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Invoice$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    claim<T extends Invoice$claimArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$claimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly patientId: FieldRef<"Invoice", 'String'>
    readonly appointmentId: FieldRef<"Invoice", 'String'>
    readonly createdById: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly tax: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly paymentDate: FieldRef<"Invoice", 'DateTime'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.appointment
   */
  export type Invoice$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.claim
   */
  export type Invoice$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    cptCode: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    cptCode: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    cptCode: number
    quantity: number
    unitPrice: number
    total: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    cptCode?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    cptCode?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    cptCode?: true
    quantity?: true
    unitPrice?: true
    total?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    cptCode: string | null
    quantity: number
    unitPrice: number
    total: number
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    cptCode?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    cptCode?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    cptCode?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    cptCode?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "cptCode" | "quantity" | "unitPrice" | "total", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      cptCode: string | null
      quantity: number
      unitPrice: number
      total: number
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly cptCode: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Float'>
    readonly total: FieldRef<"InvoiceItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    amount: number | null
    approvedAmount: number | null
  }

  export type ClaimSumAggregateOutputType = {
    amount: number | null
    approvedAmount: number | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    patientId: string | null
    claimNumber: string | null
    insuranceProvider: string | null
    submissionDate: Date | null
    status: $Enums.ClaimStatus | null
    amount: number | null
    approvedAmount: number | null
    denialReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    patientId: string | null
    claimNumber: string | null
    insuranceProvider: string | null
    submissionDate: Date | null
    status: $Enums.ClaimStatus | null
    amount: number | null
    approvedAmount: number | null
    denialReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    invoiceId: number
    patientId: number
    claimNumber: number
    insuranceProvider: number
    submissionDate: number
    status: number
    amount: number
    approvedAmount: number
    denialReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    amount?: true
    approvedAmount?: true
  }

  export type ClaimSumAggregateInputType = {
    amount?: true
    approvedAmount?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    claimNumber?: true
    insuranceProvider?: true
    submissionDate?: true
    status?: true
    amount?: true
    approvedAmount?: true
    denialReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    claimNumber?: true
    insuranceProvider?: true
    submissionDate?: true
    status?: true
    amount?: true
    approvedAmount?: true
    denialReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    claimNumber?: true
    insuranceProvider?: true
    submissionDate?: true
    status?: true
    amount?: true
    approvedAmount?: true
    denialReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    invoiceId: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date
    status: $Enums.ClaimStatus
    amount: number
    approvedAmount: number | null
    denialReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    claimNumber?: boolean
    insuranceProvider?: boolean
    submissionDate?: boolean
    status?: boolean
    amount?: boolean
    approvedAmount?: boolean
    denialReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    claimNumber?: boolean
    insuranceProvider?: boolean
    submissionDate?: boolean
    status?: boolean
    amount?: boolean
    approvedAmount?: boolean
    denialReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    claimNumber?: boolean
    insuranceProvider?: boolean
    submissionDate?: boolean
    status?: boolean
    amount?: boolean
    approvedAmount?: boolean
    denialReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    claimNumber?: boolean
    insuranceProvider?: boolean
    submissionDate?: boolean
    status?: boolean
    amount?: boolean
    approvedAmount?: boolean
    denialReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "patientId" | "claimNumber" | "insuranceProvider" | "submissionDate" | "status" | "amount" | "approvedAmount" | "denialReason" | "createdAt" | "updatedAt", ExtArgs["result"]["claim"]>
  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      patientId: string
      claimNumber: string
      insuranceProvider: string
      submissionDate: Date
      status: $Enums.ClaimStatus
      amount: number
      approvedAmount: number | null
      denialReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claims and returns the data saved in the database.
     * @param {ClaimCreateManyAndReturnArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims and returns the data updated in the database.
     * @param {ClaimUpdateManyAndReturnArgs} args - Arguments to update many Claims.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly invoiceId: FieldRef<"Claim", 'String'>
    readonly patientId: FieldRef<"Claim", 'String'>
    readonly claimNumber: FieldRef<"Claim", 'String'>
    readonly insuranceProvider: FieldRef<"Claim", 'String'>
    readonly submissionDate: FieldRef<"Claim", 'DateTime'>
    readonly status: FieldRef<"Claim", 'ClaimStatus'>
    readonly amount: FieldRef<"Claim", 'Float'>
    readonly approvedAmount: FieldRef<"Claim", 'Float'>
    readonly denialReason: FieldRef<"Claim", 'String'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Claim createManyAndReturn
   */
  export type ClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
  }

  /**
   * Claim updateManyAndReturn
   */
  export type ClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to delete.
     */
    limit?: number
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model MessageThread
   */

  export type AggregateMessageThread = {
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  export type MessageThreadMinAggregateOutputType = {
    id: string | null
    subject: string | null
    lastActivity: Date | null
    isArchived: boolean | null
    createdAt: Date | null
  }

  export type MessageThreadMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    lastActivity: Date | null
    isArchived: boolean | null
    createdAt: Date | null
  }

  export type MessageThreadCountAggregateOutputType = {
    id: number
    subject: number
    lastActivity: number
    isArchived: number
    createdAt: number
    _all: number
  }


  export type MessageThreadMinAggregateInputType = {
    id?: true
    subject?: true
    lastActivity?: true
    isArchived?: true
    createdAt?: true
  }

  export type MessageThreadMaxAggregateInputType = {
    id?: true
    subject?: true
    lastActivity?: true
    isArchived?: true
    createdAt?: true
  }

  export type MessageThreadCountAggregateInputType = {
    id?: true
    subject?: true
    lastActivity?: true
    isArchived?: true
    createdAt?: true
    _all?: true
  }

  export type MessageThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThread to aggregate.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageThreads
    **/
    _count?: true | MessageThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageThreadMaxAggregateInputType
  }

  export type GetMessageThreadAggregateType<T extends MessageThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageThread[P]>
      : GetScalarType<T[P], AggregateMessageThread[P]>
  }




  export type MessageThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithAggregationInput | MessageThreadOrderByWithAggregationInput[]
    by: MessageThreadScalarFieldEnum[] | MessageThreadScalarFieldEnum
    having?: MessageThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageThreadCountAggregateInputType | true
    _min?: MessageThreadMinAggregateInputType
    _max?: MessageThreadMaxAggregateInputType
  }

  export type MessageThreadGroupByOutputType = {
    id: string
    subject: string
    lastActivity: Date
    isArchived: boolean
    createdAt: Date
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  type GetMessageThreadGroupByPayload<T extends MessageThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
        }
      >
    >


  export type MessageThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    lastActivity?: boolean
    isArchived?: boolean
    createdAt?: boolean
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    participants?: boolean | MessageThread$participantsArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    lastActivity?: boolean
    isArchived?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    lastActivity?: boolean
    isArchived?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectScalar = {
    id?: boolean
    subject?: boolean
    lastActivity?: boolean
    isArchived?: boolean
    createdAt?: boolean
  }

  export type MessageThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "lastActivity" | "isArchived" | "createdAt", ExtArgs["result"]["messageThread"]>
  export type MessageThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    participants?: boolean | MessageThread$participantsArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MessageThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MessageThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageThread"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      participants: Prisma.$MessageThreadParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      lastActivity: Date
      isArchived: boolean
      createdAt: Date
    }, ExtArgs["result"]["messageThread"]>
    composites: {}
  }

  type MessageThreadGetPayload<S extends boolean | null | undefined | MessageThreadDefaultArgs> = $Result.GetResult<Prisma.$MessageThreadPayload, S>

  type MessageThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageThreadCountAggregateInputType | true
    }

  export interface MessageThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageThread'], meta: { name: 'MessageThread' } }
    /**
     * Find zero or one MessageThread that matches the filter.
     * @param {MessageThreadFindUniqueArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageThreadFindUniqueArgs>(args: SelectSubset<T, MessageThreadFindUniqueArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageThreadFindUniqueOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageThreadFindFirstArgs>(args?: SelectSubset<T, MessageThreadFindFirstArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageThreads
     * const messageThreads = await prisma.messageThread.findMany()
     * 
     * // Get first 10 MessageThreads
     * const messageThreads = await prisma.messageThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageThreadFindManyArgs>(args?: SelectSubset<T, MessageThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageThread.
     * @param {MessageThreadCreateArgs} args - Arguments to create a MessageThread.
     * @example
     * // Create one MessageThread
     * const MessageThread = await prisma.messageThread.create({
     *   data: {
     *     // ... data to create a MessageThread
     *   }
     * })
     * 
     */
    create<T extends MessageThreadCreateArgs>(args: SelectSubset<T, MessageThreadCreateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageThreads.
     * @param {MessageThreadCreateManyArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageThreadCreateManyArgs>(args?: SelectSubset<T, MessageThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageThreads and returns the data saved in the database.
     * @param {MessageThreadCreateManyAndReturnArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageThreads and only return the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageThread.
     * @param {MessageThreadDeleteArgs} args - Arguments to delete one MessageThread.
     * @example
     * // Delete one MessageThread
     * const MessageThread = await prisma.messageThread.delete({
     *   where: {
     *     // ... filter to delete one MessageThread
     *   }
     * })
     * 
     */
    delete<T extends MessageThreadDeleteArgs>(args: SelectSubset<T, MessageThreadDeleteArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageThread.
     * @param {MessageThreadUpdateArgs} args - Arguments to update one MessageThread.
     * @example
     * // Update one MessageThread
     * const messageThread = await prisma.messageThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageThreadUpdateArgs>(args: SelectSubset<T, MessageThreadUpdateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageThreads.
     * @param {MessageThreadDeleteManyArgs} args - Arguments to filter MessageThreads to delete.
     * @example
     * // Delete a few MessageThreads
     * const { count } = await prisma.messageThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageThreadDeleteManyArgs>(args?: SelectSubset<T, MessageThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageThreadUpdateManyArgs>(args: SelectSubset<T, MessageThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads and returns the data updated in the database.
     * @param {MessageThreadUpdateManyAndReturnArgs} args - Arguments to update many MessageThreads.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageThreads and only return the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageThread.
     * @param {MessageThreadUpsertArgs} args - Arguments to update or create a MessageThread.
     * @example
     * // Update or create a MessageThread
     * const messageThread = await prisma.messageThread.upsert({
     *   create: {
     *     // ... data to create a MessageThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageThread we want to update
     *   }
     * })
     */
    upsert<T extends MessageThreadUpsertArgs>(args: SelectSubset<T, MessageThreadUpsertArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadCountArgs} args - Arguments to filter MessageThreads to count.
     * @example
     * // Count the number of MessageThreads
     * const count = await prisma.messageThread.count({
     *   where: {
     *     // ... the filter for the MessageThreads we want to count
     *   }
     * })
    **/
    count<T extends MessageThreadCountArgs>(
      args?: Subset<T, MessageThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageThreadAggregateArgs>(args: Subset<T, MessageThreadAggregateArgs>): Prisma.PrismaPromise<GetMessageThreadAggregateType<T>>

    /**
     * Group by MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageThreadGroupByArgs['orderBy'] }
        : { orderBy?: MessageThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageThread model
   */
  readonly fields: MessageThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends MessageThread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participants<T extends MessageThread$participantsArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageThread model
   */
  interface MessageThreadFieldRefs {
    readonly id: FieldRef<"MessageThread", 'String'>
    readonly subject: FieldRef<"MessageThread", 'String'>
    readonly lastActivity: FieldRef<"MessageThread", 'DateTime'>
    readonly isArchived: FieldRef<"MessageThread", 'Boolean'>
    readonly createdAt: FieldRef<"MessageThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageThread findUnique
   */
  export type MessageThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findUniqueOrThrow
   */
  export type MessageThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findFirst
   */
  export type MessageThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findFirstOrThrow
   */
  export type MessageThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findMany
   */
  export type MessageThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreads to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread create
   */
  export type MessageThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageThread.
     */
    data: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
  }

  /**
   * MessageThread createMany
   */
  export type MessageThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageThread createManyAndReturn
   */
  export type MessageThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageThread update
   */
  export type MessageThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageThread.
     */
    data: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
    /**
     * Choose, which MessageThread to update.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread updateMany
   */
  export type MessageThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to update.
     */
    limit?: number
  }

  /**
   * MessageThread updateManyAndReturn
   */
  export type MessageThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to update.
     */
    limit?: number
  }

  /**
   * MessageThread upsert
   */
  export type MessageThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageThread to update in case it exists.
     */
    where: MessageThreadWhereUniqueInput
    /**
     * In case the MessageThread found by the `where` argument doesn't exist, create a new MessageThread with this data.
     */
    create: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
    /**
     * In case the MessageThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
  }

  /**
   * MessageThread delete
   */
  export type MessageThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter which MessageThread to delete.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread deleteMany
   */
  export type MessageThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreads to delete
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to delete.
     */
    limit?: number
  }

  /**
   * MessageThread.messages
   */
  export type MessageThread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * MessageThread.participants
   */
  export type MessageThread$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    where?: MessageThreadParticipantWhereInput
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    cursor?: MessageThreadParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageThreadParticipantScalarFieldEnum | MessageThreadParticipantScalarFieldEnum[]
  }

  /**
   * MessageThread without action
   */
  export type MessageThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
  }


  /**
   * Model MessageThreadParticipant
   */

  export type AggregateMessageThreadParticipant = {
    _count: MessageThreadParticipantCountAggregateOutputType | null
    _min: MessageThreadParticipantMinAggregateOutputType | null
    _max: MessageThreadParticipantMaxAggregateOutputType | null
  }

  export type MessageThreadParticipantMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type MessageThreadParticipantMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type MessageThreadParticipantCountAggregateOutputType = {
    id: number
    threadId: number
    userId: number
    joinedAt: number
    _all: number
  }


  export type MessageThreadParticipantMinAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    joinedAt?: true
  }

  export type MessageThreadParticipantMaxAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    joinedAt?: true
  }

  export type MessageThreadParticipantCountAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    joinedAt?: true
    _all?: true
  }

  export type MessageThreadParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreadParticipant to aggregate.
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreadParticipants to fetch.
     */
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageThreadParticipants
    **/
    _count?: true | MessageThreadParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageThreadParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageThreadParticipantMaxAggregateInputType
  }

  export type GetMessageThreadParticipantAggregateType<T extends MessageThreadParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageThreadParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageThreadParticipant[P]>
      : GetScalarType<T[P], AggregateMessageThreadParticipant[P]>
  }




  export type MessageThreadParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadParticipantWhereInput
    orderBy?: MessageThreadParticipantOrderByWithAggregationInput | MessageThreadParticipantOrderByWithAggregationInput[]
    by: MessageThreadParticipantScalarFieldEnum[] | MessageThreadParticipantScalarFieldEnum
    having?: MessageThreadParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageThreadParticipantCountAggregateInputType | true
    _min?: MessageThreadParticipantMinAggregateInputType
    _max?: MessageThreadParticipantMaxAggregateInputType
  }

  export type MessageThreadParticipantGroupByOutputType = {
    id: string
    threadId: string
    userId: string
    joinedAt: Date
    _count: MessageThreadParticipantCountAggregateOutputType | null
    _min: MessageThreadParticipantMinAggregateOutputType | null
    _max: MessageThreadParticipantMaxAggregateOutputType | null
  }

  type GetMessageThreadParticipantGroupByPayload<T extends MessageThreadParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageThreadParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageThreadParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageThreadParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], MessageThreadParticipantGroupByOutputType[P]>
        }
      >
    >


  export type MessageThreadParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    joinedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThreadParticipant"]>

  export type MessageThreadParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    joinedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThreadParticipant"]>

  export type MessageThreadParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    joinedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThreadParticipant"]>

  export type MessageThreadParticipantSelectScalar = {
    id?: boolean
    threadId?: boolean
    userId?: boolean
    joinedAt?: boolean
  }

  export type MessageThreadParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "userId" | "joinedAt", ExtArgs["result"]["messageThreadParticipant"]>
  export type MessageThreadParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageThreadParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageThreadParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageThreadParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageThreadParticipant"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      userId: string
      joinedAt: Date
    }, ExtArgs["result"]["messageThreadParticipant"]>
    composites: {}
  }

  type MessageThreadParticipantGetPayload<S extends boolean | null | undefined | MessageThreadParticipantDefaultArgs> = $Result.GetResult<Prisma.$MessageThreadParticipantPayload, S>

  type MessageThreadParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageThreadParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageThreadParticipantCountAggregateInputType | true
    }

  export interface MessageThreadParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageThreadParticipant'], meta: { name: 'MessageThreadParticipant' } }
    /**
     * Find zero or one MessageThreadParticipant that matches the filter.
     * @param {MessageThreadParticipantFindUniqueArgs} args - Arguments to find a MessageThreadParticipant
     * @example
     * // Get one MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageThreadParticipantFindUniqueArgs>(args: SelectSubset<T, MessageThreadParticipantFindUniqueArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageThreadParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageThreadParticipantFindUniqueOrThrowArgs} args - Arguments to find a MessageThreadParticipant
     * @example
     * // Get one MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageThreadParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageThreadParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThreadParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantFindFirstArgs} args - Arguments to find a MessageThreadParticipant
     * @example
     * // Get one MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageThreadParticipantFindFirstArgs>(args?: SelectSubset<T, MessageThreadParticipantFindFirstArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThreadParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantFindFirstOrThrowArgs} args - Arguments to find a MessageThreadParticipant
     * @example
     * // Get one MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageThreadParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageThreadParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageThreadParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageThreadParticipants
     * const messageThreadParticipants = await prisma.messageThreadParticipant.findMany()
     * 
     * // Get first 10 MessageThreadParticipants
     * const messageThreadParticipants = await prisma.messageThreadParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageThreadParticipantWithIdOnly = await prisma.messageThreadParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageThreadParticipantFindManyArgs>(args?: SelectSubset<T, MessageThreadParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageThreadParticipant.
     * @param {MessageThreadParticipantCreateArgs} args - Arguments to create a MessageThreadParticipant.
     * @example
     * // Create one MessageThreadParticipant
     * const MessageThreadParticipant = await prisma.messageThreadParticipant.create({
     *   data: {
     *     // ... data to create a MessageThreadParticipant
     *   }
     * })
     * 
     */
    create<T extends MessageThreadParticipantCreateArgs>(args: SelectSubset<T, MessageThreadParticipantCreateArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageThreadParticipants.
     * @param {MessageThreadParticipantCreateManyArgs} args - Arguments to create many MessageThreadParticipants.
     * @example
     * // Create many MessageThreadParticipants
     * const messageThreadParticipant = await prisma.messageThreadParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageThreadParticipantCreateManyArgs>(args?: SelectSubset<T, MessageThreadParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageThreadParticipants and returns the data saved in the database.
     * @param {MessageThreadParticipantCreateManyAndReturnArgs} args - Arguments to create many MessageThreadParticipants.
     * @example
     * // Create many MessageThreadParticipants
     * const messageThreadParticipant = await prisma.messageThreadParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageThreadParticipants and only return the `id`
     * const messageThreadParticipantWithIdOnly = await prisma.messageThreadParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageThreadParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageThreadParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageThreadParticipant.
     * @param {MessageThreadParticipantDeleteArgs} args - Arguments to delete one MessageThreadParticipant.
     * @example
     * // Delete one MessageThreadParticipant
     * const MessageThreadParticipant = await prisma.messageThreadParticipant.delete({
     *   where: {
     *     // ... filter to delete one MessageThreadParticipant
     *   }
     * })
     * 
     */
    delete<T extends MessageThreadParticipantDeleteArgs>(args: SelectSubset<T, MessageThreadParticipantDeleteArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageThreadParticipant.
     * @param {MessageThreadParticipantUpdateArgs} args - Arguments to update one MessageThreadParticipant.
     * @example
     * // Update one MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageThreadParticipantUpdateArgs>(args: SelectSubset<T, MessageThreadParticipantUpdateArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageThreadParticipants.
     * @param {MessageThreadParticipantDeleteManyArgs} args - Arguments to filter MessageThreadParticipants to delete.
     * @example
     * // Delete a few MessageThreadParticipants
     * const { count } = await prisma.messageThreadParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageThreadParticipantDeleteManyArgs>(args?: SelectSubset<T, MessageThreadParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreadParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageThreadParticipants
     * const messageThreadParticipant = await prisma.messageThreadParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageThreadParticipantUpdateManyArgs>(args: SelectSubset<T, MessageThreadParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreadParticipants and returns the data updated in the database.
     * @param {MessageThreadParticipantUpdateManyAndReturnArgs} args - Arguments to update many MessageThreadParticipants.
     * @example
     * // Update many MessageThreadParticipants
     * const messageThreadParticipant = await prisma.messageThreadParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageThreadParticipants and only return the `id`
     * const messageThreadParticipantWithIdOnly = await prisma.messageThreadParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageThreadParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageThreadParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageThreadParticipant.
     * @param {MessageThreadParticipantUpsertArgs} args - Arguments to update or create a MessageThreadParticipant.
     * @example
     * // Update or create a MessageThreadParticipant
     * const messageThreadParticipant = await prisma.messageThreadParticipant.upsert({
     *   create: {
     *     // ... data to create a MessageThreadParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageThreadParticipant we want to update
     *   }
     * })
     */
    upsert<T extends MessageThreadParticipantUpsertArgs>(args: SelectSubset<T, MessageThreadParticipantUpsertArgs<ExtArgs>>): Prisma__MessageThreadParticipantClient<$Result.GetResult<Prisma.$MessageThreadParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageThreadParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantCountArgs} args - Arguments to filter MessageThreadParticipants to count.
     * @example
     * // Count the number of MessageThreadParticipants
     * const count = await prisma.messageThreadParticipant.count({
     *   where: {
     *     // ... the filter for the MessageThreadParticipants we want to count
     *   }
     * })
    **/
    count<T extends MessageThreadParticipantCountArgs>(
      args?: Subset<T, MessageThreadParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageThreadParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageThreadParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageThreadParticipantAggregateArgs>(args: Subset<T, MessageThreadParticipantAggregateArgs>): Prisma.PrismaPromise<GetMessageThreadParticipantAggregateType<T>>

    /**
     * Group by MessageThreadParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageThreadParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageThreadParticipantGroupByArgs['orderBy'] }
        : { orderBy?: MessageThreadParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageThreadParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageThreadParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageThreadParticipant model
   */
  readonly fields: MessageThreadParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageThreadParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageThreadParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends MessageThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageThreadDefaultArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageThreadParticipant model
   */
  interface MessageThreadParticipantFieldRefs {
    readonly id: FieldRef<"MessageThreadParticipant", 'String'>
    readonly threadId: FieldRef<"MessageThreadParticipant", 'String'>
    readonly userId: FieldRef<"MessageThreadParticipant", 'String'>
    readonly joinedAt: FieldRef<"MessageThreadParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageThreadParticipant findUnique
   */
  export type MessageThreadParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreadParticipant to fetch.
     */
    where: MessageThreadParticipantWhereUniqueInput
  }

  /**
   * MessageThreadParticipant findUniqueOrThrow
   */
  export type MessageThreadParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreadParticipant to fetch.
     */
    where: MessageThreadParticipantWhereUniqueInput
  }

  /**
   * MessageThreadParticipant findFirst
   */
  export type MessageThreadParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreadParticipant to fetch.
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreadParticipants to fetch.
     */
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreadParticipants.
     */
    cursor?: MessageThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreadParticipants.
     */
    distinct?: MessageThreadParticipantScalarFieldEnum | MessageThreadParticipantScalarFieldEnum[]
  }

  /**
   * MessageThreadParticipant findFirstOrThrow
   */
  export type MessageThreadParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreadParticipant to fetch.
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreadParticipants to fetch.
     */
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreadParticipants.
     */
    cursor?: MessageThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreadParticipants.
     */
    distinct?: MessageThreadParticipantScalarFieldEnum | MessageThreadParticipantScalarFieldEnum[]
  }

  /**
   * MessageThreadParticipant findMany
   */
  export type MessageThreadParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreadParticipants to fetch.
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreadParticipants to fetch.
     */
    orderBy?: MessageThreadParticipantOrderByWithRelationInput | MessageThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageThreadParticipants.
     */
    cursor?: MessageThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreadParticipants.
     */
    skip?: number
    distinct?: MessageThreadParticipantScalarFieldEnum | MessageThreadParticipantScalarFieldEnum[]
  }

  /**
   * MessageThreadParticipant create
   */
  export type MessageThreadParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageThreadParticipant.
     */
    data: XOR<MessageThreadParticipantCreateInput, MessageThreadParticipantUncheckedCreateInput>
  }

  /**
   * MessageThreadParticipant createMany
   */
  export type MessageThreadParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageThreadParticipants.
     */
    data: MessageThreadParticipantCreateManyInput | MessageThreadParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageThreadParticipant createManyAndReturn
   */
  export type MessageThreadParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many MessageThreadParticipants.
     */
    data: MessageThreadParticipantCreateManyInput | MessageThreadParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageThreadParticipant update
   */
  export type MessageThreadParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageThreadParticipant.
     */
    data: XOR<MessageThreadParticipantUpdateInput, MessageThreadParticipantUncheckedUpdateInput>
    /**
     * Choose, which MessageThreadParticipant to update.
     */
    where: MessageThreadParticipantWhereUniqueInput
  }

  /**
   * MessageThreadParticipant updateMany
   */
  export type MessageThreadParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageThreadParticipants.
     */
    data: XOR<MessageThreadParticipantUpdateManyMutationInput, MessageThreadParticipantUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreadParticipants to update
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * Limit how many MessageThreadParticipants to update.
     */
    limit?: number
  }

  /**
   * MessageThreadParticipant updateManyAndReturn
   */
  export type MessageThreadParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * The data used to update MessageThreadParticipants.
     */
    data: XOR<MessageThreadParticipantUpdateManyMutationInput, MessageThreadParticipantUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreadParticipants to update
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * Limit how many MessageThreadParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageThreadParticipant upsert
   */
  export type MessageThreadParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageThreadParticipant to update in case it exists.
     */
    where: MessageThreadParticipantWhereUniqueInput
    /**
     * In case the MessageThreadParticipant found by the `where` argument doesn't exist, create a new MessageThreadParticipant with this data.
     */
    create: XOR<MessageThreadParticipantCreateInput, MessageThreadParticipantUncheckedCreateInput>
    /**
     * In case the MessageThreadParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageThreadParticipantUpdateInput, MessageThreadParticipantUncheckedUpdateInput>
  }

  /**
   * MessageThreadParticipant delete
   */
  export type MessageThreadParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter which MessageThreadParticipant to delete.
     */
    where: MessageThreadParticipantWhereUniqueInput
  }

  /**
   * MessageThreadParticipant deleteMany
   */
  export type MessageThreadParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreadParticipants to delete
     */
    where?: MessageThreadParticipantWhereInput
    /**
     * Limit how many MessageThreadParticipants to delete.
     */
    limit?: number
  }

  /**
   * MessageThreadParticipant without action
   */
  export type MessageThreadParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadParticipant
     */
    select?: MessageThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThreadParticipant
     */
    omit?: MessageThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    readerId: string | null
    content: string | null
    priority: string | null
    isRead: boolean | null
    isEncrypted: boolean | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    readerId: string | null
    content: string | null
    priority: string | null
    isRead: boolean | null
    isEncrypted: boolean | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    threadId: number
    senderId: number
    readerId: number
    content: number
    priority: number
    isRead: number
    isEncrypted: number
    sentAt: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    readerId?: true
    content?: true
    priority?: true
    isRead?: true
    isEncrypted?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    readerId?: true
    content?: true
    priority?: true
    isRead?: true
    isEncrypted?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    readerId?: true
    content?: true
    priority?: true
    isRead?: true
    isEncrypted?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    threadId: string
    senderId: string
    readerId: string | null
    content: string
    priority: string
    isRead: boolean
    isEncrypted: boolean
    sentAt: Date
    readAt: Date | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    readerId?: boolean
    content?: boolean
    priority?: boolean
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    readerId?: boolean
    content?: boolean
    priority?: boolean
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    readerId?: boolean
    content?: boolean
    priority?: boolean
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    readerId?: boolean
    content?: boolean
    priority?: boolean
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "senderId" | "readerId" | "content" | "priority" | "isRead" | "isEncrypted" | "sentAt" | "readAt" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    reader?: boolean | Message$readerArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      reader: Prisma.$UserPayload<ExtArgs> | null
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      senderId: string
      readerId: string | null
      content: string
      priority: string
      isRead: boolean
      isEncrypted: boolean
      sentAt: Date
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends MessageThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageThreadDefaultArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reader<T extends Message$readerArgs<ExtArgs> = {}>(args?: Subset<T, Message$readerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly readerId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly priority: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly isEncrypted: FieldRef<"Message", 'Boolean'>
    readonly sentAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.reader
   */
  export type Message$readerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    isEncrypted: boolean | null
    uploadedAt: Date | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    isEncrypted: boolean | null
    uploadedAt: Date | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    fileName: number
    fileSize: number
    mimeType: number
    isEncrypted: number
    uploadedAt: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    uploadedAt?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    uploadedAt?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    uploadedAt?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted: boolean
    uploadedAt: Date
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    uploadedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    uploadedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    uploadedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    uploadedAt?: boolean
  }

  export type MessageAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "fileName" | "fileSize" | "mimeType" | "isEncrypted" | "uploadedAt", ExtArgs["result"]["messageAttachment"]>
  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      fileName: string
      fileSize: number
      mimeType: string
      isEncrypted: boolean
      uploadedAt: Date
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }

  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAttachmentFindUniqueArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAttachmentFindFirstArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAttachmentFindManyArgs>(args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
     */
    create<T extends MessageAttachmentCreateArgs>(args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageAttachments.
     * @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAttachmentCreateManyArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAttachments and returns the data saved in the database.
     * @param {MessageAttachmentCreateManyAndReturnArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends MessageAttachmentDeleteArgs>(args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAttachmentUpdateArgs>(args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAttachmentUpdateManyArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments and returns the data updated in the database.
     * @param {MessageAttachmentUpdateManyAndReturnArgs} args - Arguments to update many MessageAttachments.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAttachmentUpsertArgs>(args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAttachment model
   */
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
    readonly fileName: FieldRef<"MessageAttachment", 'String'>
    readonly fileSize: FieldRef<"MessageAttachment", 'Int'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly isEncrypted: FieldRef<"MessageAttachment", 'Boolean'>
    readonly uploadedAt: FieldRef<"MessageAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }

  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAttachment createManyAndReturn
   */
  export type MessageAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
  }

  /**
   * MessageAttachment updateManyAndReturn
   */
  export type MessageAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }

  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to delete.
     */
    limit?: number
  }

  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    description: string | null
    category: $Enums.DocumentCategory | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    isEncrypted: boolean | null
    signature: string | null
    signatureDate: Date | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    description: string | null
    category: $Enums.DocumentCategory | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    isEncrypted: boolean | null
    signature: string | null
    signatureDate: Date | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    patientId: number
    title: number
    description: number
    category: number
    tags: number
    fileUrl: number
    fileName: number
    fileSize: number
    mimeType: number
    isEncrypted: number
    signature: number
    signatureDate: number
    isSigned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    category?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    signature?: true
    signatureDate?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    category?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    signature?: true
    signatureDate?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    category?: true
    tags?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    isEncrypted?: true
    signature?: true
    signatureDate?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    patientId: string
    title: string
    description: string | null
    category: $Enums.DocumentCategory
    tags: string[]
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    isEncrypted: boolean
    signature: string | null
    signatureDate: Date | null
    isSigned: boolean
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    signature?: boolean
    signatureDate?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    shares?: boolean | Document$sharesArgs<ExtArgs>
    accessHistory?: boolean | Document$accessHistoryArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    signature?: boolean
    signatureDate?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    signature?: boolean
    signatureDate?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isEncrypted?: boolean
    signature?: boolean
    signatureDate?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "title" | "description" | "category" | "tags" | "fileUrl" | "fileName" | "fileSize" | "mimeType" | "isEncrypted" | "signature" | "signatureDate" | "isSigned" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    shares?: boolean | Document$sharesArgs<ExtArgs>
    accessHistory?: boolean | Document$accessHistoryArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      shares: Prisma.$DocumentSharePayload<ExtArgs>[]
      accessHistory: Prisma.$DocumentAccessLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      title: string
      description: string | null
      category: $Enums.DocumentCategory
      tags: string[]
      fileUrl: string | null
      fileName: string | null
      fileSize: number | null
      mimeType: string | null
      isEncrypted: boolean
      signature: string | null
      signatureDate: Date | null
      isSigned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shares<T extends Document$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Document$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accessHistory<T extends Document$accessHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Document$accessHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly patientId: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'DocumentCategory'>
    readonly tags: FieldRef<"Document", 'String[]'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly isEncrypted: FieldRef<"Document", 'Boolean'>
    readonly signature: FieldRef<"Document", 'String'>
    readonly signatureDate: FieldRef<"Document", 'DateTime'>
    readonly isSigned: FieldRef<"Document", 'Boolean'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.shares
   */
  export type Document$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    where?: DocumentShareWhereInput
    orderBy?: DocumentShareOrderByWithRelationInput | DocumentShareOrderByWithRelationInput[]
    cursor?: DocumentShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentShareScalarFieldEnum | DocumentShareScalarFieldEnum[]
  }

  /**
   * Document.accessHistory
   */
  export type Document$accessHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    where?: DocumentAccessLogWhereInput
    orderBy?: DocumentAccessLogOrderByWithRelationInput | DocumentAccessLogOrderByWithRelationInput[]
    cursor?: DocumentAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAccessLogScalarFieldEnum | DocumentAccessLogScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentShare
   */

  export type AggregateDocumentShare = {
    _count: DocumentShareCountAggregateOutputType | null
    _min: DocumentShareMinAggregateOutputType | null
    _max: DocumentShareMaxAggregateOutputType | null
  }

  export type DocumentShareMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    recipientEmail: string | null
    shareType: string | null
    expiresAt: Date | null
    message: string | null
    createdAt: Date | null
  }

  export type DocumentShareMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    recipientEmail: string | null
    shareType: string | null
    expiresAt: Date | null
    message: string | null
    createdAt: Date | null
  }

  export type DocumentShareCountAggregateOutputType = {
    id: number
    documentId: number
    recipientEmail: number
    shareType: number
    expiresAt: number
    message: number
    createdAt: number
    _all: number
  }


  export type DocumentShareMinAggregateInputType = {
    id?: true
    documentId?: true
    recipientEmail?: true
    shareType?: true
    expiresAt?: true
    message?: true
    createdAt?: true
  }

  export type DocumentShareMaxAggregateInputType = {
    id?: true
    documentId?: true
    recipientEmail?: true
    shareType?: true
    expiresAt?: true
    message?: true
    createdAt?: true
  }

  export type DocumentShareCountAggregateInputType = {
    id?: true
    documentId?: true
    recipientEmail?: true
    shareType?: true
    expiresAt?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentShare to aggregate.
     */
    where?: DocumentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentShares to fetch.
     */
    orderBy?: DocumentShareOrderByWithRelationInput | DocumentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentShares
    **/
    _count?: true | DocumentShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentShareMaxAggregateInputType
  }

  export type GetDocumentShareAggregateType<T extends DocumentShareAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentShare[P]>
      : GetScalarType<T[P], AggregateDocumentShare[P]>
  }




  export type DocumentShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentShareWhereInput
    orderBy?: DocumentShareOrderByWithAggregationInput | DocumentShareOrderByWithAggregationInput[]
    by: DocumentShareScalarFieldEnum[] | DocumentShareScalarFieldEnum
    having?: DocumentShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentShareCountAggregateInputType | true
    _min?: DocumentShareMinAggregateInputType
    _max?: DocumentShareMaxAggregateInputType
  }

  export type DocumentShareGroupByOutputType = {
    id: string
    documentId: string
    recipientEmail: string
    shareType: string
    expiresAt: Date | null
    message: string | null
    createdAt: Date
    _count: DocumentShareCountAggregateOutputType | null
    _min: DocumentShareMinAggregateOutputType | null
    _max: DocumentShareMaxAggregateOutputType | null
  }

  type GetDocumentShareGroupByPayload<T extends DocumentShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentShareGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentShareGroupByOutputType[P]>
        }
      >
    >


  export type DocumentShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    recipientEmail?: boolean
    shareType?: boolean
    expiresAt?: boolean
    message?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentShare"]>

  export type DocumentShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    recipientEmail?: boolean
    shareType?: boolean
    expiresAt?: boolean
    message?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentShare"]>

  export type DocumentShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    recipientEmail?: boolean
    shareType?: boolean
    expiresAt?: boolean
    message?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentShare"]>

  export type DocumentShareSelectScalar = {
    id?: boolean
    documentId?: boolean
    recipientEmail?: boolean
    shareType?: boolean
    expiresAt?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type DocumentShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "recipientEmail" | "shareType" | "expiresAt" | "message" | "createdAt", ExtArgs["result"]["documentShare"]>
  export type DocumentShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentShare"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      recipientEmail: string
      shareType: string
      expiresAt: Date | null
      message: string | null
      createdAt: Date
    }, ExtArgs["result"]["documentShare"]>
    composites: {}
  }

  type DocumentShareGetPayload<S extends boolean | null | undefined | DocumentShareDefaultArgs> = $Result.GetResult<Prisma.$DocumentSharePayload, S>

  type DocumentShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentShareCountAggregateInputType | true
    }

  export interface DocumentShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentShare'], meta: { name: 'DocumentShare' } }
    /**
     * Find zero or one DocumentShare that matches the filter.
     * @param {DocumentShareFindUniqueArgs} args - Arguments to find a DocumentShare
     * @example
     * // Get one DocumentShare
     * const documentShare = await prisma.documentShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentShareFindUniqueArgs>(args: SelectSubset<T, DocumentShareFindUniqueArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentShareFindUniqueOrThrowArgs} args - Arguments to find a DocumentShare
     * @example
     * // Get one DocumentShare
     * const documentShare = await prisma.documentShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentShareFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareFindFirstArgs} args - Arguments to find a DocumentShare
     * @example
     * // Get one DocumentShare
     * const documentShare = await prisma.documentShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentShareFindFirstArgs>(args?: SelectSubset<T, DocumentShareFindFirstArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareFindFirstOrThrowArgs} args - Arguments to find a DocumentShare
     * @example
     * // Get one DocumentShare
     * const documentShare = await prisma.documentShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentShareFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentShares
     * const documentShares = await prisma.documentShare.findMany()
     * 
     * // Get first 10 DocumentShares
     * const documentShares = await prisma.documentShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentShareWithIdOnly = await prisma.documentShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentShareFindManyArgs>(args?: SelectSubset<T, DocumentShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentShare.
     * @param {DocumentShareCreateArgs} args - Arguments to create a DocumentShare.
     * @example
     * // Create one DocumentShare
     * const DocumentShare = await prisma.documentShare.create({
     *   data: {
     *     // ... data to create a DocumentShare
     *   }
     * })
     * 
     */
    create<T extends DocumentShareCreateArgs>(args: SelectSubset<T, DocumentShareCreateArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentShares.
     * @param {DocumentShareCreateManyArgs} args - Arguments to create many DocumentShares.
     * @example
     * // Create many DocumentShares
     * const documentShare = await prisma.documentShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentShareCreateManyArgs>(args?: SelectSubset<T, DocumentShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentShares and returns the data saved in the database.
     * @param {DocumentShareCreateManyAndReturnArgs} args - Arguments to create many DocumentShares.
     * @example
     * // Create many DocumentShares
     * const documentShare = await prisma.documentShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentShares and only return the `id`
     * const documentShareWithIdOnly = await prisma.documentShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentShareCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentShare.
     * @param {DocumentShareDeleteArgs} args - Arguments to delete one DocumentShare.
     * @example
     * // Delete one DocumentShare
     * const DocumentShare = await prisma.documentShare.delete({
     *   where: {
     *     // ... filter to delete one DocumentShare
     *   }
     * })
     * 
     */
    delete<T extends DocumentShareDeleteArgs>(args: SelectSubset<T, DocumentShareDeleteArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentShare.
     * @param {DocumentShareUpdateArgs} args - Arguments to update one DocumentShare.
     * @example
     * // Update one DocumentShare
     * const documentShare = await prisma.documentShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentShareUpdateArgs>(args: SelectSubset<T, DocumentShareUpdateArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentShares.
     * @param {DocumentShareDeleteManyArgs} args - Arguments to filter DocumentShares to delete.
     * @example
     * // Delete a few DocumentShares
     * const { count } = await prisma.documentShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentShareDeleteManyArgs>(args?: SelectSubset<T, DocumentShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentShares
     * const documentShare = await prisma.documentShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentShareUpdateManyArgs>(args: SelectSubset<T, DocumentShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentShares and returns the data updated in the database.
     * @param {DocumentShareUpdateManyAndReturnArgs} args - Arguments to update many DocumentShares.
     * @example
     * // Update many DocumentShares
     * const documentShare = await prisma.documentShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentShares and only return the `id`
     * const documentShareWithIdOnly = await prisma.documentShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentShareUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentShare.
     * @param {DocumentShareUpsertArgs} args - Arguments to update or create a DocumentShare.
     * @example
     * // Update or create a DocumentShare
     * const documentShare = await prisma.documentShare.upsert({
     *   create: {
     *     // ... data to create a DocumentShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentShare we want to update
     *   }
     * })
     */
    upsert<T extends DocumentShareUpsertArgs>(args: SelectSubset<T, DocumentShareUpsertArgs<ExtArgs>>): Prisma__DocumentShareClient<$Result.GetResult<Prisma.$DocumentSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareCountArgs} args - Arguments to filter DocumentShares to count.
     * @example
     * // Count the number of DocumentShares
     * const count = await prisma.documentShare.count({
     *   where: {
     *     // ... the filter for the DocumentShares we want to count
     *   }
     * })
    **/
    count<T extends DocumentShareCountArgs>(
      args?: Subset<T, DocumentShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentShareAggregateArgs>(args: Subset<T, DocumentShareAggregateArgs>): Prisma.PrismaPromise<GetDocumentShareAggregateType<T>>

    /**
     * Group by DocumentShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentShareGroupByArgs['orderBy'] }
        : { orderBy?: DocumentShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentShare model
   */
  readonly fields: DocumentShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentShare model
   */
  interface DocumentShareFieldRefs {
    readonly id: FieldRef<"DocumentShare", 'String'>
    readonly documentId: FieldRef<"DocumentShare", 'String'>
    readonly recipientEmail: FieldRef<"DocumentShare", 'String'>
    readonly shareType: FieldRef<"DocumentShare", 'String'>
    readonly expiresAt: FieldRef<"DocumentShare", 'DateTime'>
    readonly message: FieldRef<"DocumentShare", 'String'>
    readonly createdAt: FieldRef<"DocumentShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentShare findUnique
   */
  export type DocumentShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter, which DocumentShare to fetch.
     */
    where: DocumentShareWhereUniqueInput
  }

  /**
   * DocumentShare findUniqueOrThrow
   */
  export type DocumentShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter, which DocumentShare to fetch.
     */
    where: DocumentShareWhereUniqueInput
  }

  /**
   * DocumentShare findFirst
   */
  export type DocumentShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter, which DocumentShare to fetch.
     */
    where?: DocumentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentShares to fetch.
     */
    orderBy?: DocumentShareOrderByWithRelationInput | DocumentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentShares.
     */
    cursor?: DocumentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentShares.
     */
    distinct?: DocumentShareScalarFieldEnum | DocumentShareScalarFieldEnum[]
  }

  /**
   * DocumentShare findFirstOrThrow
   */
  export type DocumentShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter, which DocumentShare to fetch.
     */
    where?: DocumentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentShares to fetch.
     */
    orderBy?: DocumentShareOrderByWithRelationInput | DocumentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentShares.
     */
    cursor?: DocumentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentShares.
     */
    distinct?: DocumentShareScalarFieldEnum | DocumentShareScalarFieldEnum[]
  }

  /**
   * DocumentShare findMany
   */
  export type DocumentShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter, which DocumentShares to fetch.
     */
    where?: DocumentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentShares to fetch.
     */
    orderBy?: DocumentShareOrderByWithRelationInput | DocumentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentShares.
     */
    cursor?: DocumentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentShares.
     */
    skip?: number
    distinct?: DocumentShareScalarFieldEnum | DocumentShareScalarFieldEnum[]
  }

  /**
   * DocumentShare create
   */
  export type DocumentShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentShare.
     */
    data: XOR<DocumentShareCreateInput, DocumentShareUncheckedCreateInput>
  }

  /**
   * DocumentShare createMany
   */
  export type DocumentShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentShares.
     */
    data: DocumentShareCreateManyInput | DocumentShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentShare createManyAndReturn
   */
  export type DocumentShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentShares.
     */
    data: DocumentShareCreateManyInput | DocumentShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentShare update
   */
  export type DocumentShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentShare.
     */
    data: XOR<DocumentShareUpdateInput, DocumentShareUncheckedUpdateInput>
    /**
     * Choose, which DocumentShare to update.
     */
    where: DocumentShareWhereUniqueInput
  }

  /**
   * DocumentShare updateMany
   */
  export type DocumentShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentShares.
     */
    data: XOR<DocumentShareUpdateManyMutationInput, DocumentShareUncheckedUpdateManyInput>
    /**
     * Filter which DocumentShares to update
     */
    where?: DocumentShareWhereInput
    /**
     * Limit how many DocumentShares to update.
     */
    limit?: number
  }

  /**
   * DocumentShare updateManyAndReturn
   */
  export type DocumentShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * The data used to update DocumentShares.
     */
    data: XOR<DocumentShareUpdateManyMutationInput, DocumentShareUncheckedUpdateManyInput>
    /**
     * Filter which DocumentShares to update
     */
    where?: DocumentShareWhereInput
    /**
     * Limit how many DocumentShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentShare upsert
   */
  export type DocumentShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentShare to update in case it exists.
     */
    where: DocumentShareWhereUniqueInput
    /**
     * In case the DocumentShare found by the `where` argument doesn't exist, create a new DocumentShare with this data.
     */
    create: XOR<DocumentShareCreateInput, DocumentShareUncheckedCreateInput>
    /**
     * In case the DocumentShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentShareUpdateInput, DocumentShareUncheckedUpdateInput>
  }

  /**
   * DocumentShare delete
   */
  export type DocumentShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
    /**
     * Filter which DocumentShare to delete.
     */
    where: DocumentShareWhereUniqueInput
  }

  /**
   * DocumentShare deleteMany
   */
  export type DocumentShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentShares to delete
     */
    where?: DocumentShareWhereInput
    /**
     * Limit how many DocumentShares to delete.
     */
    limit?: number
  }

  /**
   * DocumentShare without action
   */
  export type DocumentShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentShare
     */
    select?: DocumentShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentShare
     */
    omit?: DocumentShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentShareInclude<ExtArgs> | null
  }


  /**
   * Model DocumentAccessLog
   */

  export type AggregateDocumentAccessLog = {
    _count: DocumentAccessLogCountAggregateOutputType | null
    _min: DocumentAccessLogMinAggregateOutputType | null
    _max: DocumentAccessLogMaxAggregateOutputType | null
  }

  export type DocumentAccessLogMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    accessedAt: Date | null
    action: string | null
  }

  export type DocumentAccessLogMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    accessedAt: Date | null
    action: string | null
  }

  export type DocumentAccessLogCountAggregateOutputType = {
    id: number
    documentId: number
    accessedAt: number
    action: number
    _all: number
  }


  export type DocumentAccessLogMinAggregateInputType = {
    id?: true
    documentId?: true
    accessedAt?: true
    action?: true
  }

  export type DocumentAccessLogMaxAggregateInputType = {
    id?: true
    documentId?: true
    accessedAt?: true
    action?: true
  }

  export type DocumentAccessLogCountAggregateInputType = {
    id?: true
    documentId?: true
    accessedAt?: true
    action?: true
    _all?: true
  }

  export type DocumentAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAccessLog to aggregate.
     */
    where?: DocumentAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAccessLogs to fetch.
     */
    orderBy?: DocumentAccessLogOrderByWithRelationInput | DocumentAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentAccessLogs
    **/
    _count?: true | DocumentAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAccessLogMaxAggregateInputType
  }

  export type GetDocumentAccessLogAggregateType<T extends DocumentAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAccessLog[P]>
      : GetScalarType<T[P], AggregateDocumentAccessLog[P]>
  }




  export type DocumentAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAccessLogWhereInput
    orderBy?: DocumentAccessLogOrderByWithAggregationInput | DocumentAccessLogOrderByWithAggregationInput[]
    by: DocumentAccessLogScalarFieldEnum[] | DocumentAccessLogScalarFieldEnum
    having?: DocumentAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAccessLogCountAggregateInputType | true
    _min?: DocumentAccessLogMinAggregateInputType
    _max?: DocumentAccessLogMaxAggregateInputType
  }

  export type DocumentAccessLogGroupByOutputType = {
    id: string
    documentId: string
    accessedAt: Date
    action: string
    _count: DocumentAccessLogCountAggregateOutputType | null
    _min: DocumentAccessLogMinAggregateOutputType | null
    _max: DocumentAccessLogMaxAggregateOutputType | null
  }

  type GetDocumentAccessLogGroupByPayload<T extends DocumentAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type DocumentAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    accessedAt?: boolean
    action?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAccessLog"]>

  export type DocumentAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    accessedAt?: boolean
    action?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAccessLog"]>

  export type DocumentAccessLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    accessedAt?: boolean
    action?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAccessLog"]>

  export type DocumentAccessLogSelectScalar = {
    id?: boolean
    documentId?: boolean
    accessedAt?: boolean
    action?: boolean
  }

  export type DocumentAccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "accessedAt" | "action", ExtArgs["result"]["documentAccessLog"]>
  export type DocumentAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentAccessLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAccessLog"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      accessedAt: Date
      action: string
    }, ExtArgs["result"]["documentAccessLog"]>
    composites: {}
  }

  type DocumentAccessLogGetPayload<S extends boolean | null | undefined | DocumentAccessLogDefaultArgs> = $Result.GetResult<Prisma.$DocumentAccessLogPayload, S>

  type DocumentAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentAccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentAccessLogCountAggregateInputType | true
    }

  export interface DocumentAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAccessLog'], meta: { name: 'DocumentAccessLog' } }
    /**
     * Find zero or one DocumentAccessLog that matches the filter.
     * @param {DocumentAccessLogFindUniqueArgs} args - Arguments to find a DocumentAccessLog
     * @example
     * // Get one DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentAccessLogFindUniqueArgs>(args: SelectSubset<T, DocumentAccessLogFindUniqueArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentAccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentAccessLogFindUniqueOrThrowArgs} args - Arguments to find a DocumentAccessLog
     * @example
     * // Get one DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogFindFirstArgs} args - Arguments to find a DocumentAccessLog
     * @example
     * // Get one DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentAccessLogFindFirstArgs>(args?: SelectSubset<T, DocumentAccessLogFindFirstArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogFindFirstOrThrowArgs} args - Arguments to find a DocumentAccessLog
     * @example
     * // Get one DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAccessLogs
     * const documentAccessLogs = await prisma.documentAccessLog.findMany()
     * 
     * // Get first 10 DocumentAccessLogs
     * const documentAccessLogs = await prisma.documentAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAccessLogWithIdOnly = await prisma.documentAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentAccessLogFindManyArgs>(args?: SelectSubset<T, DocumentAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentAccessLog.
     * @param {DocumentAccessLogCreateArgs} args - Arguments to create a DocumentAccessLog.
     * @example
     * // Create one DocumentAccessLog
     * const DocumentAccessLog = await prisma.documentAccessLog.create({
     *   data: {
     *     // ... data to create a DocumentAccessLog
     *   }
     * })
     * 
     */
    create<T extends DocumentAccessLogCreateArgs>(args: SelectSubset<T, DocumentAccessLogCreateArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentAccessLogs.
     * @param {DocumentAccessLogCreateManyArgs} args - Arguments to create many DocumentAccessLogs.
     * @example
     * // Create many DocumentAccessLogs
     * const documentAccessLog = await prisma.documentAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentAccessLogCreateManyArgs>(args?: SelectSubset<T, DocumentAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentAccessLogs and returns the data saved in the database.
     * @param {DocumentAccessLogCreateManyAndReturnArgs} args - Arguments to create many DocumentAccessLogs.
     * @example
     * // Create many DocumentAccessLogs
     * const documentAccessLog = await prisma.documentAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentAccessLogs and only return the `id`
     * const documentAccessLogWithIdOnly = await prisma.documentAccessLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentAccessLog.
     * @param {DocumentAccessLogDeleteArgs} args - Arguments to delete one DocumentAccessLog.
     * @example
     * // Delete one DocumentAccessLog
     * const DocumentAccessLog = await prisma.documentAccessLog.delete({
     *   where: {
     *     // ... filter to delete one DocumentAccessLog
     *   }
     * })
     * 
     */
    delete<T extends DocumentAccessLogDeleteArgs>(args: SelectSubset<T, DocumentAccessLogDeleteArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentAccessLog.
     * @param {DocumentAccessLogUpdateArgs} args - Arguments to update one DocumentAccessLog.
     * @example
     * // Update one DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentAccessLogUpdateArgs>(args: SelectSubset<T, DocumentAccessLogUpdateArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentAccessLogs.
     * @param {DocumentAccessLogDeleteManyArgs} args - Arguments to filter DocumentAccessLogs to delete.
     * @example
     * // Delete a few DocumentAccessLogs
     * const { count } = await prisma.documentAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentAccessLogDeleteManyArgs>(args?: SelectSubset<T, DocumentAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAccessLogs
     * const documentAccessLog = await prisma.documentAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentAccessLogUpdateManyArgs>(args: SelectSubset<T, DocumentAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAccessLogs and returns the data updated in the database.
     * @param {DocumentAccessLogUpdateManyAndReturnArgs} args - Arguments to update many DocumentAccessLogs.
     * @example
     * // Update many DocumentAccessLogs
     * const documentAccessLog = await prisma.documentAccessLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentAccessLogs and only return the `id`
     * const documentAccessLogWithIdOnly = await prisma.documentAccessLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentAccessLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentAccessLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentAccessLog.
     * @param {DocumentAccessLogUpsertArgs} args - Arguments to update or create a DocumentAccessLog.
     * @example
     * // Update or create a DocumentAccessLog
     * const documentAccessLog = await prisma.documentAccessLog.upsert({
     *   create: {
     *     // ... data to create a DocumentAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends DocumentAccessLogUpsertArgs>(args: SelectSubset<T, DocumentAccessLogUpsertArgs<ExtArgs>>): Prisma__DocumentAccessLogClient<$Result.GetResult<Prisma.$DocumentAccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogCountArgs} args - Arguments to filter DocumentAccessLogs to count.
     * @example
     * // Count the number of DocumentAccessLogs
     * const count = await prisma.documentAccessLog.count({
     *   where: {
     *     // ... the filter for the DocumentAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends DocumentAccessLogCountArgs>(
      args?: Subset<T, DocumentAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAccessLogAggregateArgs>(args: Subset<T, DocumentAccessLogAggregateArgs>): Prisma.PrismaPromise<GetDocumentAccessLogAggregateType<T>>

    /**
     * Group by DocumentAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: DocumentAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAccessLog model
   */
  readonly fields: DocumentAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentAccessLog model
   */
  interface DocumentAccessLogFieldRefs {
    readonly id: FieldRef<"DocumentAccessLog", 'String'>
    readonly documentId: FieldRef<"DocumentAccessLog", 'String'>
    readonly accessedAt: FieldRef<"DocumentAccessLog", 'DateTime'>
    readonly action: FieldRef<"DocumentAccessLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentAccessLog findUnique
   */
  export type DocumentAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAccessLog to fetch.
     */
    where: DocumentAccessLogWhereUniqueInput
  }

  /**
   * DocumentAccessLog findUniqueOrThrow
   */
  export type DocumentAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAccessLog to fetch.
     */
    where: DocumentAccessLogWhereUniqueInput
  }

  /**
   * DocumentAccessLog findFirst
   */
  export type DocumentAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAccessLog to fetch.
     */
    where?: DocumentAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAccessLogs to fetch.
     */
    orderBy?: DocumentAccessLogOrderByWithRelationInput | DocumentAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAccessLogs.
     */
    cursor?: DocumentAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAccessLogs.
     */
    distinct?: DocumentAccessLogScalarFieldEnum | DocumentAccessLogScalarFieldEnum[]
  }

  /**
   * DocumentAccessLog findFirstOrThrow
   */
  export type DocumentAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAccessLog to fetch.
     */
    where?: DocumentAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAccessLogs to fetch.
     */
    orderBy?: DocumentAccessLogOrderByWithRelationInput | DocumentAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAccessLogs.
     */
    cursor?: DocumentAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAccessLogs.
     */
    distinct?: DocumentAccessLogScalarFieldEnum | DocumentAccessLogScalarFieldEnum[]
  }

  /**
   * DocumentAccessLog findMany
   */
  export type DocumentAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAccessLogs to fetch.
     */
    where?: DocumentAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAccessLogs to fetch.
     */
    orderBy?: DocumentAccessLogOrderByWithRelationInput | DocumentAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentAccessLogs.
     */
    cursor?: DocumentAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAccessLogs.
     */
    skip?: number
    distinct?: DocumentAccessLogScalarFieldEnum | DocumentAccessLogScalarFieldEnum[]
  }

  /**
   * DocumentAccessLog create
   */
  export type DocumentAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAccessLog.
     */
    data: XOR<DocumentAccessLogCreateInput, DocumentAccessLogUncheckedCreateInput>
  }

  /**
   * DocumentAccessLog createMany
   */
  export type DocumentAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentAccessLogs.
     */
    data: DocumentAccessLogCreateManyInput | DocumentAccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentAccessLog createManyAndReturn
   */
  export type DocumentAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentAccessLogs.
     */
    data: DocumentAccessLogCreateManyInput | DocumentAccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAccessLog update
   */
  export type DocumentAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAccessLog.
     */
    data: XOR<DocumentAccessLogUpdateInput, DocumentAccessLogUncheckedUpdateInput>
    /**
     * Choose, which DocumentAccessLog to update.
     */
    where: DocumentAccessLogWhereUniqueInput
  }

  /**
   * DocumentAccessLog updateMany
   */
  export type DocumentAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentAccessLogs.
     */
    data: XOR<DocumentAccessLogUpdateManyMutationInput, DocumentAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAccessLogs to update
     */
    where?: DocumentAccessLogWhereInput
    /**
     * Limit how many DocumentAccessLogs to update.
     */
    limit?: number
  }

  /**
   * DocumentAccessLog updateManyAndReturn
   */
  export type DocumentAccessLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * The data used to update DocumentAccessLogs.
     */
    data: XOR<DocumentAccessLogUpdateManyMutationInput, DocumentAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAccessLogs to update
     */
    where?: DocumentAccessLogWhereInput
    /**
     * Limit how many DocumentAccessLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAccessLog upsert
   */
  export type DocumentAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAccessLog to update in case it exists.
     */
    where: DocumentAccessLogWhereUniqueInput
    /**
     * In case the DocumentAccessLog found by the `where` argument doesn't exist, create a new DocumentAccessLog with this data.
     */
    create: XOR<DocumentAccessLogCreateInput, DocumentAccessLogUncheckedCreateInput>
    /**
     * In case the DocumentAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentAccessLogUpdateInput, DocumentAccessLogUncheckedUpdateInput>
  }

  /**
   * DocumentAccessLog delete
   */
  export type DocumentAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
    /**
     * Filter which DocumentAccessLog to delete.
     */
    where: DocumentAccessLogWhereUniqueInput
  }

  /**
   * DocumentAccessLog deleteMany
   */
  export type DocumentAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAccessLogs to delete
     */
    where?: DocumentAccessLogWhereInput
    /**
     * Limit how many DocumentAccessLogs to delete.
     */
    limit?: number
  }

  /**
   * DocumentAccessLog without action
   */
  export type DocumentAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAccessLog
     */
    select?: DocumentAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAccessLog
     */
    omit?: DocumentAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model TelehealthSession
   */

  export type AggregateTelehealthSession = {
    _count: TelehealthSessionCountAggregateOutputType | null
    _avg: TelehealthSessionAvgAggregateOutputType | null
    _sum: TelehealthSessionSumAggregateOutputType | null
    _min: TelehealthSessionMinAggregateOutputType | null
    _max: TelehealthSessionMaxAggregateOutputType | null
  }

  export type TelehealthSessionAvgAggregateOutputType = {
    scheduledDuration: number | null
    actualDuration: number | null
    recordingSize: number | null
    recordingDuration: number | null
  }

  export type TelehealthSessionSumAggregateOutputType = {
    scheduledDuration: number | null
    actualDuration: number | null
    recordingSize: number | null
    recordingDuration: number | null
  }

  export type TelehealthSessionMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    patientId: string | null
    roomId: string | null
    sessionUrl: string | null
    status: $Enums.TelehealthStatus | null
    startedAt: Date | null
    endedAt: Date | null
    scheduledDuration: number | null
    actualDuration: number | null
    platform: string | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    recordingSize: number | null
    recordingDuration: number | null
    chatEnabled: boolean | null
    screenShareEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelehealthSessionMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    patientId: string | null
    roomId: string | null
    sessionUrl: string | null
    status: $Enums.TelehealthStatus | null
    startedAt: Date | null
    endedAt: Date | null
    scheduledDuration: number | null
    actualDuration: number | null
    platform: string | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    recordingSize: number | null
    recordingDuration: number | null
    chatEnabled: boolean | null
    screenShareEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelehealthSessionCountAggregateOutputType = {
    id: number
    appointmentId: number
    patientId: number
    roomId: number
    sessionUrl: number
    status: number
    startedAt: number
    endedAt: number
    scheduledDuration: number
    actualDuration: number
    platform: number
    recordingEnabled: number
    recordingUrl: number
    recordingSize: number
    recordingDuration: number
    chatEnabled: number
    screenShareEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelehealthSessionAvgAggregateInputType = {
    scheduledDuration?: true
    actualDuration?: true
    recordingSize?: true
    recordingDuration?: true
  }

  export type TelehealthSessionSumAggregateInputType = {
    scheduledDuration?: true
    actualDuration?: true
    recordingSize?: true
    recordingDuration?: true
  }

  export type TelehealthSessionMinAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    roomId?: true
    sessionUrl?: true
    status?: true
    startedAt?: true
    endedAt?: true
    scheduledDuration?: true
    actualDuration?: true
    platform?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingSize?: true
    recordingDuration?: true
    chatEnabled?: true
    screenShareEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelehealthSessionMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    roomId?: true
    sessionUrl?: true
    status?: true
    startedAt?: true
    endedAt?: true
    scheduledDuration?: true
    actualDuration?: true
    platform?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingSize?: true
    recordingDuration?: true
    chatEnabled?: true
    screenShareEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelehealthSessionCountAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    roomId?: true
    sessionUrl?: true
    status?: true
    startedAt?: true
    endedAt?: true
    scheduledDuration?: true
    actualDuration?: true
    platform?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingSize?: true
    recordingDuration?: true
    chatEnabled?: true
    screenShareEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelehealthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelehealthSession to aggregate.
     */
    where?: TelehealthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthSessions to fetch.
     */
    orderBy?: TelehealthSessionOrderByWithRelationInput | TelehealthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelehealthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelehealthSessions
    **/
    _count?: true | TelehealthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelehealthSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelehealthSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelehealthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelehealthSessionMaxAggregateInputType
  }

  export type GetTelehealthSessionAggregateType<T extends TelehealthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTelehealthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelehealthSession[P]>
      : GetScalarType<T[P], AggregateTelehealthSession[P]>
  }




  export type TelehealthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelehealthSessionWhereInput
    orderBy?: TelehealthSessionOrderByWithAggregationInput | TelehealthSessionOrderByWithAggregationInput[]
    by: TelehealthSessionScalarFieldEnum[] | TelehealthSessionScalarFieldEnum
    having?: TelehealthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelehealthSessionCountAggregateInputType | true
    _avg?: TelehealthSessionAvgAggregateInputType
    _sum?: TelehealthSessionSumAggregateInputType
    _min?: TelehealthSessionMinAggregateInputType
    _max?: TelehealthSessionMaxAggregateInputType
  }

  export type TelehealthSessionGroupByOutputType = {
    id: string
    appointmentId: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status: $Enums.TelehealthStatus
    startedAt: Date | null
    endedAt: Date | null
    scheduledDuration: number
    actualDuration: number | null
    platform: string
    recordingEnabled: boolean
    recordingUrl: string | null
    recordingSize: number | null
    recordingDuration: number | null
    chatEnabled: boolean
    screenShareEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: TelehealthSessionCountAggregateOutputType | null
    _avg: TelehealthSessionAvgAggregateOutputType | null
    _sum: TelehealthSessionSumAggregateOutputType | null
    _min: TelehealthSessionMinAggregateOutputType | null
    _max: TelehealthSessionMaxAggregateOutputType | null
  }

  type GetTelehealthSessionGroupByPayload<T extends TelehealthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelehealthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelehealthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelehealthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TelehealthSessionGroupByOutputType[P]>
        }
      >
    >


  export type TelehealthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    roomId?: boolean
    sessionUrl?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scheduledDuration?: boolean
    actualDuration?: boolean
    platform?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingSize?: boolean
    recordingDuration?: boolean
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    participants?: boolean | TelehealthSession$participantsArgs<ExtArgs>
    recordings?: boolean | TelehealthSession$recordingsArgs<ExtArgs>
    transcripts?: boolean | TelehealthSession$transcriptsArgs<ExtArgs>
    _count?: boolean | TelehealthSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthSession"]>

  export type TelehealthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    roomId?: boolean
    sessionUrl?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scheduledDuration?: boolean
    actualDuration?: boolean
    platform?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingSize?: boolean
    recordingDuration?: boolean
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthSession"]>

  export type TelehealthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    roomId?: boolean
    sessionUrl?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scheduledDuration?: boolean
    actualDuration?: boolean
    platform?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingSize?: boolean
    recordingDuration?: boolean
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthSession"]>

  export type TelehealthSessionSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    roomId?: boolean
    sessionUrl?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scheduledDuration?: boolean
    actualDuration?: boolean
    platform?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingSize?: boolean
    recordingDuration?: boolean
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelehealthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "patientId" | "roomId" | "sessionUrl" | "status" | "startedAt" | "endedAt" | "scheduledDuration" | "actualDuration" | "platform" | "recordingEnabled" | "recordingUrl" | "recordingSize" | "recordingDuration" | "chatEnabled" | "screenShareEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["telehealthSession"]>
  export type TelehealthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    participants?: boolean | TelehealthSession$participantsArgs<ExtArgs>
    recordings?: boolean | TelehealthSession$recordingsArgs<ExtArgs>
    transcripts?: boolean | TelehealthSession$transcriptsArgs<ExtArgs>
    _count?: boolean | TelehealthSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TelehealthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type TelehealthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | TelehealthSession$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $TelehealthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelehealthSession"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      participants: Prisma.$TelehealthParticipantPayload<ExtArgs>[]
      recordings: Prisma.$RecordingMetadataPayload<ExtArgs>[]
      transcripts: Prisma.$TranscriptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string | null
      patientId: string
      roomId: string
      sessionUrl: string
      status: $Enums.TelehealthStatus
      startedAt: Date | null
      endedAt: Date | null
      scheduledDuration: number
      actualDuration: number | null
      platform: string
      recordingEnabled: boolean
      recordingUrl: string | null
      recordingSize: number | null
      recordingDuration: number | null
      chatEnabled: boolean
      screenShareEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telehealthSession"]>
    composites: {}
  }

  type TelehealthSessionGetPayload<S extends boolean | null | undefined | TelehealthSessionDefaultArgs> = $Result.GetResult<Prisma.$TelehealthSessionPayload, S>

  type TelehealthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelehealthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelehealthSessionCountAggregateInputType | true
    }

  export interface TelehealthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelehealthSession'], meta: { name: 'TelehealthSession' } }
    /**
     * Find zero or one TelehealthSession that matches the filter.
     * @param {TelehealthSessionFindUniqueArgs} args - Arguments to find a TelehealthSession
     * @example
     * // Get one TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelehealthSessionFindUniqueArgs>(args: SelectSubset<T, TelehealthSessionFindUniqueArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelehealthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelehealthSessionFindUniqueOrThrowArgs} args - Arguments to find a TelehealthSession
     * @example
     * // Get one TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelehealthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TelehealthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelehealthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionFindFirstArgs} args - Arguments to find a TelehealthSession
     * @example
     * // Get one TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelehealthSessionFindFirstArgs>(args?: SelectSubset<T, TelehealthSessionFindFirstArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelehealthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionFindFirstOrThrowArgs} args - Arguments to find a TelehealthSession
     * @example
     * // Get one TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelehealthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TelehealthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelehealthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelehealthSessions
     * const telehealthSessions = await prisma.telehealthSession.findMany()
     * 
     * // Get first 10 TelehealthSessions
     * const telehealthSessions = await prisma.telehealthSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telehealthSessionWithIdOnly = await prisma.telehealthSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelehealthSessionFindManyArgs>(args?: SelectSubset<T, TelehealthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelehealthSession.
     * @param {TelehealthSessionCreateArgs} args - Arguments to create a TelehealthSession.
     * @example
     * // Create one TelehealthSession
     * const TelehealthSession = await prisma.telehealthSession.create({
     *   data: {
     *     // ... data to create a TelehealthSession
     *   }
     * })
     * 
     */
    create<T extends TelehealthSessionCreateArgs>(args: SelectSubset<T, TelehealthSessionCreateArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelehealthSessions.
     * @param {TelehealthSessionCreateManyArgs} args - Arguments to create many TelehealthSessions.
     * @example
     * // Create many TelehealthSessions
     * const telehealthSession = await prisma.telehealthSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelehealthSessionCreateManyArgs>(args?: SelectSubset<T, TelehealthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelehealthSessions and returns the data saved in the database.
     * @param {TelehealthSessionCreateManyAndReturnArgs} args - Arguments to create many TelehealthSessions.
     * @example
     * // Create many TelehealthSessions
     * const telehealthSession = await prisma.telehealthSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelehealthSessions and only return the `id`
     * const telehealthSessionWithIdOnly = await prisma.telehealthSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelehealthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TelehealthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelehealthSession.
     * @param {TelehealthSessionDeleteArgs} args - Arguments to delete one TelehealthSession.
     * @example
     * // Delete one TelehealthSession
     * const TelehealthSession = await prisma.telehealthSession.delete({
     *   where: {
     *     // ... filter to delete one TelehealthSession
     *   }
     * })
     * 
     */
    delete<T extends TelehealthSessionDeleteArgs>(args: SelectSubset<T, TelehealthSessionDeleteArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelehealthSession.
     * @param {TelehealthSessionUpdateArgs} args - Arguments to update one TelehealthSession.
     * @example
     * // Update one TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelehealthSessionUpdateArgs>(args: SelectSubset<T, TelehealthSessionUpdateArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelehealthSessions.
     * @param {TelehealthSessionDeleteManyArgs} args - Arguments to filter TelehealthSessions to delete.
     * @example
     * // Delete a few TelehealthSessions
     * const { count } = await prisma.telehealthSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelehealthSessionDeleteManyArgs>(args?: SelectSubset<T, TelehealthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelehealthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelehealthSessions
     * const telehealthSession = await prisma.telehealthSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelehealthSessionUpdateManyArgs>(args: SelectSubset<T, TelehealthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelehealthSessions and returns the data updated in the database.
     * @param {TelehealthSessionUpdateManyAndReturnArgs} args - Arguments to update many TelehealthSessions.
     * @example
     * // Update many TelehealthSessions
     * const telehealthSession = await prisma.telehealthSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelehealthSessions and only return the `id`
     * const telehealthSessionWithIdOnly = await prisma.telehealthSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelehealthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, TelehealthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelehealthSession.
     * @param {TelehealthSessionUpsertArgs} args - Arguments to update or create a TelehealthSession.
     * @example
     * // Update or create a TelehealthSession
     * const telehealthSession = await prisma.telehealthSession.upsert({
     *   create: {
     *     // ... data to create a TelehealthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelehealthSession we want to update
     *   }
     * })
     */
    upsert<T extends TelehealthSessionUpsertArgs>(args: SelectSubset<T, TelehealthSessionUpsertArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelehealthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionCountArgs} args - Arguments to filter TelehealthSessions to count.
     * @example
     * // Count the number of TelehealthSessions
     * const count = await prisma.telehealthSession.count({
     *   where: {
     *     // ... the filter for the TelehealthSessions we want to count
     *   }
     * })
    **/
    count<T extends TelehealthSessionCountArgs>(
      args?: Subset<T, TelehealthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelehealthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelehealthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelehealthSessionAggregateArgs>(args: Subset<T, TelehealthSessionAggregateArgs>): Prisma.PrismaPromise<GetTelehealthSessionAggregateType<T>>

    /**
     * Group by TelehealthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelehealthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelehealthSessionGroupByArgs['orderBy'] }
        : { orderBy?: TelehealthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelehealthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelehealthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelehealthSession model
   */
  readonly fields: TelehealthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelehealthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelehealthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends TelehealthSession$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSession$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends TelehealthSession$participantsArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSession$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recordings<T extends TelehealthSession$recordingsArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSession$recordingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcripts<T extends TelehealthSession$transcriptsArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSession$transcriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelehealthSession model
   */
  interface TelehealthSessionFieldRefs {
    readonly id: FieldRef<"TelehealthSession", 'String'>
    readonly appointmentId: FieldRef<"TelehealthSession", 'String'>
    readonly patientId: FieldRef<"TelehealthSession", 'String'>
    readonly roomId: FieldRef<"TelehealthSession", 'String'>
    readonly sessionUrl: FieldRef<"TelehealthSession", 'String'>
    readonly status: FieldRef<"TelehealthSession", 'TelehealthStatus'>
    readonly startedAt: FieldRef<"TelehealthSession", 'DateTime'>
    readonly endedAt: FieldRef<"TelehealthSession", 'DateTime'>
    readonly scheduledDuration: FieldRef<"TelehealthSession", 'Int'>
    readonly actualDuration: FieldRef<"TelehealthSession", 'Int'>
    readonly platform: FieldRef<"TelehealthSession", 'String'>
    readonly recordingEnabled: FieldRef<"TelehealthSession", 'Boolean'>
    readonly recordingUrl: FieldRef<"TelehealthSession", 'String'>
    readonly recordingSize: FieldRef<"TelehealthSession", 'Int'>
    readonly recordingDuration: FieldRef<"TelehealthSession", 'Int'>
    readonly chatEnabled: FieldRef<"TelehealthSession", 'Boolean'>
    readonly screenShareEnabled: FieldRef<"TelehealthSession", 'Boolean'>
    readonly createdAt: FieldRef<"TelehealthSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TelehealthSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelehealthSession findUnique
   */
  export type TelehealthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthSession to fetch.
     */
    where: TelehealthSessionWhereUniqueInput
  }

  /**
   * TelehealthSession findUniqueOrThrow
   */
  export type TelehealthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthSession to fetch.
     */
    where: TelehealthSessionWhereUniqueInput
  }

  /**
   * TelehealthSession findFirst
   */
  export type TelehealthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthSession to fetch.
     */
    where?: TelehealthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthSessions to fetch.
     */
    orderBy?: TelehealthSessionOrderByWithRelationInput | TelehealthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelehealthSessions.
     */
    cursor?: TelehealthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelehealthSessions.
     */
    distinct?: TelehealthSessionScalarFieldEnum | TelehealthSessionScalarFieldEnum[]
  }

  /**
   * TelehealthSession findFirstOrThrow
   */
  export type TelehealthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthSession to fetch.
     */
    where?: TelehealthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthSessions to fetch.
     */
    orderBy?: TelehealthSessionOrderByWithRelationInput | TelehealthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelehealthSessions.
     */
    cursor?: TelehealthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelehealthSessions.
     */
    distinct?: TelehealthSessionScalarFieldEnum | TelehealthSessionScalarFieldEnum[]
  }

  /**
   * TelehealthSession findMany
   */
  export type TelehealthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthSessions to fetch.
     */
    where?: TelehealthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthSessions to fetch.
     */
    orderBy?: TelehealthSessionOrderByWithRelationInput | TelehealthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelehealthSessions.
     */
    cursor?: TelehealthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthSessions.
     */
    skip?: number
    distinct?: TelehealthSessionScalarFieldEnum | TelehealthSessionScalarFieldEnum[]
  }

  /**
   * TelehealthSession create
   */
  export type TelehealthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TelehealthSession.
     */
    data: XOR<TelehealthSessionCreateInput, TelehealthSessionUncheckedCreateInput>
  }

  /**
   * TelehealthSession createMany
   */
  export type TelehealthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelehealthSessions.
     */
    data: TelehealthSessionCreateManyInput | TelehealthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelehealthSession createManyAndReturn
   */
  export type TelehealthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many TelehealthSessions.
     */
    data: TelehealthSessionCreateManyInput | TelehealthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelehealthSession update
   */
  export type TelehealthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TelehealthSession.
     */
    data: XOR<TelehealthSessionUpdateInput, TelehealthSessionUncheckedUpdateInput>
    /**
     * Choose, which TelehealthSession to update.
     */
    where: TelehealthSessionWhereUniqueInput
  }

  /**
   * TelehealthSession updateMany
   */
  export type TelehealthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelehealthSessions.
     */
    data: XOR<TelehealthSessionUpdateManyMutationInput, TelehealthSessionUncheckedUpdateManyInput>
    /**
     * Filter which TelehealthSessions to update
     */
    where?: TelehealthSessionWhereInput
    /**
     * Limit how many TelehealthSessions to update.
     */
    limit?: number
  }

  /**
   * TelehealthSession updateManyAndReturn
   */
  export type TelehealthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * The data used to update TelehealthSessions.
     */
    data: XOR<TelehealthSessionUpdateManyMutationInput, TelehealthSessionUncheckedUpdateManyInput>
    /**
     * Filter which TelehealthSessions to update
     */
    where?: TelehealthSessionWhereInput
    /**
     * Limit how many TelehealthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelehealthSession upsert
   */
  export type TelehealthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TelehealthSession to update in case it exists.
     */
    where: TelehealthSessionWhereUniqueInput
    /**
     * In case the TelehealthSession found by the `where` argument doesn't exist, create a new TelehealthSession with this data.
     */
    create: XOR<TelehealthSessionCreateInput, TelehealthSessionUncheckedCreateInput>
    /**
     * In case the TelehealthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelehealthSessionUpdateInput, TelehealthSessionUncheckedUpdateInput>
  }

  /**
   * TelehealthSession delete
   */
  export type TelehealthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
    /**
     * Filter which TelehealthSession to delete.
     */
    where: TelehealthSessionWhereUniqueInput
  }

  /**
   * TelehealthSession deleteMany
   */
  export type TelehealthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelehealthSessions to delete
     */
    where?: TelehealthSessionWhereInput
    /**
     * Limit how many TelehealthSessions to delete.
     */
    limit?: number
  }

  /**
   * TelehealthSession.appointment
   */
  export type TelehealthSession$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * TelehealthSession.participants
   */
  export type TelehealthSession$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    where?: TelehealthParticipantWhereInput
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    cursor?: TelehealthParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelehealthParticipantScalarFieldEnum | TelehealthParticipantScalarFieldEnum[]
  }

  /**
   * TelehealthSession.recordings
   */
  export type TelehealthSession$recordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    where?: RecordingMetadataWhereInput
    orderBy?: RecordingMetadataOrderByWithRelationInput | RecordingMetadataOrderByWithRelationInput[]
    cursor?: RecordingMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordingMetadataScalarFieldEnum | RecordingMetadataScalarFieldEnum[]
  }

  /**
   * TelehealthSession.transcripts
   */
  export type TelehealthSession$transcriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    cursor?: TranscriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * TelehealthSession without action
   */
  export type TelehealthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthSession
     */
    select?: TelehealthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthSession
     */
    omit?: TelehealthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthSessionInclude<ExtArgs> | null
  }


  /**
   * Model TelehealthParticipant
   */

  export type AggregateTelehealthParticipant = {
    _count: TelehealthParticipantCountAggregateOutputType | null
    _min: TelehealthParticipantMinAggregateOutputType | null
    _max: TelehealthParticipantMaxAggregateOutputType | null
  }

  export type TelehealthParticipantMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    role: string | null
    status: string | null
    joinedAt: Date | null
    leftAt: Date | null
    connectionQuality: string | null
    cameraEnabled: boolean | null
    micEnabled: boolean | null
    screenSharing: boolean | null
    createdAt: Date | null
  }

  export type TelehealthParticipantMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    role: string | null
    status: string | null
    joinedAt: Date | null
    leftAt: Date | null
    connectionQuality: string | null
    cameraEnabled: boolean | null
    micEnabled: boolean | null
    screenSharing: boolean | null
    createdAt: Date | null
  }

  export type TelehealthParticipantCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    role: number
    status: number
    joinedAt: number
    leftAt: number
    connectionQuality: number
    cameraEnabled: number
    micEnabled: number
    screenSharing: number
    createdAt: number
    _all: number
  }


  export type TelehealthParticipantMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    connectionQuality?: true
    cameraEnabled?: true
    micEnabled?: true
    screenSharing?: true
    createdAt?: true
  }

  export type TelehealthParticipantMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    connectionQuality?: true
    cameraEnabled?: true
    micEnabled?: true
    screenSharing?: true
    createdAt?: true
  }

  export type TelehealthParticipantCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    connectionQuality?: true
    cameraEnabled?: true
    micEnabled?: true
    screenSharing?: true
    createdAt?: true
    _all?: true
  }

  export type TelehealthParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelehealthParticipant to aggregate.
     */
    where?: TelehealthParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthParticipants to fetch.
     */
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelehealthParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelehealthParticipants
    **/
    _count?: true | TelehealthParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelehealthParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelehealthParticipantMaxAggregateInputType
  }

  export type GetTelehealthParticipantAggregateType<T extends TelehealthParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTelehealthParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelehealthParticipant[P]>
      : GetScalarType<T[P], AggregateTelehealthParticipant[P]>
  }




  export type TelehealthParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelehealthParticipantWhereInput
    orderBy?: TelehealthParticipantOrderByWithAggregationInput | TelehealthParticipantOrderByWithAggregationInput[]
    by: TelehealthParticipantScalarFieldEnum[] | TelehealthParticipantScalarFieldEnum
    having?: TelehealthParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelehealthParticipantCountAggregateInputType | true
    _min?: TelehealthParticipantMinAggregateInputType
    _max?: TelehealthParticipantMaxAggregateInputType
  }

  export type TelehealthParticipantGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    role: string
    status: string
    joinedAt: Date | null
    leftAt: Date | null
    connectionQuality: string | null
    cameraEnabled: boolean
    micEnabled: boolean
    screenSharing: boolean
    createdAt: Date
    _count: TelehealthParticipantCountAggregateOutputType | null
    _min: TelehealthParticipantMinAggregateOutputType | null
    _max: TelehealthParticipantMaxAggregateOutputType | null
  }

  type GetTelehealthParticipantGroupByPayload<T extends TelehealthParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelehealthParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelehealthParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelehealthParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TelehealthParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TelehealthParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    connectionQuality?: boolean
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthParticipant"]>

  export type TelehealthParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    connectionQuality?: boolean
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthParticipant"]>

  export type TelehealthParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    connectionQuality?: boolean
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telehealthParticipant"]>

  export type TelehealthParticipantSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    connectionQuality?: boolean
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: boolean
  }

  export type TelehealthParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "role" | "status" | "joinedAt" | "leftAt" | "connectionQuality" | "cameraEnabled" | "micEnabled" | "screenSharing" | "createdAt", ExtArgs["result"]["telehealthParticipant"]>
  export type TelehealthParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelehealthParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelehealthParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TelehealthParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelehealthParticipant"
    objects: {
      session: Prisma.$TelehealthSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      role: string
      status: string
      joinedAt: Date | null
      leftAt: Date | null
      connectionQuality: string | null
      cameraEnabled: boolean
      micEnabled: boolean
      screenSharing: boolean
      createdAt: Date
    }, ExtArgs["result"]["telehealthParticipant"]>
    composites: {}
  }

  type TelehealthParticipantGetPayload<S extends boolean | null | undefined | TelehealthParticipantDefaultArgs> = $Result.GetResult<Prisma.$TelehealthParticipantPayload, S>

  type TelehealthParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelehealthParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelehealthParticipantCountAggregateInputType | true
    }

  export interface TelehealthParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelehealthParticipant'], meta: { name: 'TelehealthParticipant' } }
    /**
     * Find zero or one TelehealthParticipant that matches the filter.
     * @param {TelehealthParticipantFindUniqueArgs} args - Arguments to find a TelehealthParticipant
     * @example
     * // Get one TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelehealthParticipantFindUniqueArgs>(args: SelectSubset<T, TelehealthParticipantFindUniqueArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelehealthParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelehealthParticipantFindUniqueOrThrowArgs} args - Arguments to find a TelehealthParticipant
     * @example
     * // Get one TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelehealthParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TelehealthParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelehealthParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantFindFirstArgs} args - Arguments to find a TelehealthParticipant
     * @example
     * // Get one TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelehealthParticipantFindFirstArgs>(args?: SelectSubset<T, TelehealthParticipantFindFirstArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelehealthParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantFindFirstOrThrowArgs} args - Arguments to find a TelehealthParticipant
     * @example
     * // Get one TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelehealthParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TelehealthParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelehealthParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelehealthParticipants
     * const telehealthParticipants = await prisma.telehealthParticipant.findMany()
     * 
     * // Get first 10 TelehealthParticipants
     * const telehealthParticipants = await prisma.telehealthParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telehealthParticipantWithIdOnly = await prisma.telehealthParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelehealthParticipantFindManyArgs>(args?: SelectSubset<T, TelehealthParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelehealthParticipant.
     * @param {TelehealthParticipantCreateArgs} args - Arguments to create a TelehealthParticipant.
     * @example
     * // Create one TelehealthParticipant
     * const TelehealthParticipant = await prisma.telehealthParticipant.create({
     *   data: {
     *     // ... data to create a TelehealthParticipant
     *   }
     * })
     * 
     */
    create<T extends TelehealthParticipantCreateArgs>(args: SelectSubset<T, TelehealthParticipantCreateArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelehealthParticipants.
     * @param {TelehealthParticipantCreateManyArgs} args - Arguments to create many TelehealthParticipants.
     * @example
     * // Create many TelehealthParticipants
     * const telehealthParticipant = await prisma.telehealthParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelehealthParticipantCreateManyArgs>(args?: SelectSubset<T, TelehealthParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelehealthParticipants and returns the data saved in the database.
     * @param {TelehealthParticipantCreateManyAndReturnArgs} args - Arguments to create many TelehealthParticipants.
     * @example
     * // Create many TelehealthParticipants
     * const telehealthParticipant = await prisma.telehealthParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelehealthParticipants and only return the `id`
     * const telehealthParticipantWithIdOnly = await prisma.telehealthParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelehealthParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TelehealthParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelehealthParticipant.
     * @param {TelehealthParticipantDeleteArgs} args - Arguments to delete one TelehealthParticipant.
     * @example
     * // Delete one TelehealthParticipant
     * const TelehealthParticipant = await prisma.telehealthParticipant.delete({
     *   where: {
     *     // ... filter to delete one TelehealthParticipant
     *   }
     * })
     * 
     */
    delete<T extends TelehealthParticipantDeleteArgs>(args: SelectSubset<T, TelehealthParticipantDeleteArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelehealthParticipant.
     * @param {TelehealthParticipantUpdateArgs} args - Arguments to update one TelehealthParticipant.
     * @example
     * // Update one TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelehealthParticipantUpdateArgs>(args: SelectSubset<T, TelehealthParticipantUpdateArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelehealthParticipants.
     * @param {TelehealthParticipantDeleteManyArgs} args - Arguments to filter TelehealthParticipants to delete.
     * @example
     * // Delete a few TelehealthParticipants
     * const { count } = await prisma.telehealthParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelehealthParticipantDeleteManyArgs>(args?: SelectSubset<T, TelehealthParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelehealthParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelehealthParticipants
     * const telehealthParticipant = await prisma.telehealthParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelehealthParticipantUpdateManyArgs>(args: SelectSubset<T, TelehealthParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelehealthParticipants and returns the data updated in the database.
     * @param {TelehealthParticipantUpdateManyAndReturnArgs} args - Arguments to update many TelehealthParticipants.
     * @example
     * // Update many TelehealthParticipants
     * const telehealthParticipant = await prisma.telehealthParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelehealthParticipants and only return the `id`
     * const telehealthParticipantWithIdOnly = await prisma.telehealthParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelehealthParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TelehealthParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelehealthParticipant.
     * @param {TelehealthParticipantUpsertArgs} args - Arguments to update or create a TelehealthParticipant.
     * @example
     * // Update or create a TelehealthParticipant
     * const telehealthParticipant = await prisma.telehealthParticipant.upsert({
     *   create: {
     *     // ... data to create a TelehealthParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelehealthParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TelehealthParticipantUpsertArgs>(args: SelectSubset<T, TelehealthParticipantUpsertArgs<ExtArgs>>): Prisma__TelehealthParticipantClient<$Result.GetResult<Prisma.$TelehealthParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelehealthParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantCountArgs} args - Arguments to filter TelehealthParticipants to count.
     * @example
     * // Count the number of TelehealthParticipants
     * const count = await prisma.telehealthParticipant.count({
     *   where: {
     *     // ... the filter for the TelehealthParticipants we want to count
     *   }
     * })
    **/
    count<T extends TelehealthParticipantCountArgs>(
      args?: Subset<T, TelehealthParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelehealthParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelehealthParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelehealthParticipantAggregateArgs>(args: Subset<T, TelehealthParticipantAggregateArgs>): Prisma.PrismaPromise<GetTelehealthParticipantAggregateType<T>>

    /**
     * Group by TelehealthParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelehealthParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelehealthParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelehealthParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TelehealthParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelehealthParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelehealthParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelehealthParticipant model
   */
  readonly fields: TelehealthParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelehealthParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelehealthParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TelehealthSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSessionDefaultArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelehealthParticipant model
   */
  interface TelehealthParticipantFieldRefs {
    readonly id: FieldRef<"TelehealthParticipant", 'String'>
    readonly sessionId: FieldRef<"TelehealthParticipant", 'String'>
    readonly userId: FieldRef<"TelehealthParticipant", 'String'>
    readonly role: FieldRef<"TelehealthParticipant", 'String'>
    readonly status: FieldRef<"TelehealthParticipant", 'String'>
    readonly joinedAt: FieldRef<"TelehealthParticipant", 'DateTime'>
    readonly leftAt: FieldRef<"TelehealthParticipant", 'DateTime'>
    readonly connectionQuality: FieldRef<"TelehealthParticipant", 'String'>
    readonly cameraEnabled: FieldRef<"TelehealthParticipant", 'Boolean'>
    readonly micEnabled: FieldRef<"TelehealthParticipant", 'Boolean'>
    readonly screenSharing: FieldRef<"TelehealthParticipant", 'Boolean'>
    readonly createdAt: FieldRef<"TelehealthParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelehealthParticipant findUnique
   */
  export type TelehealthParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthParticipant to fetch.
     */
    where: TelehealthParticipantWhereUniqueInput
  }

  /**
   * TelehealthParticipant findUniqueOrThrow
   */
  export type TelehealthParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthParticipant to fetch.
     */
    where: TelehealthParticipantWhereUniqueInput
  }

  /**
   * TelehealthParticipant findFirst
   */
  export type TelehealthParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthParticipant to fetch.
     */
    where?: TelehealthParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthParticipants to fetch.
     */
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelehealthParticipants.
     */
    cursor?: TelehealthParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelehealthParticipants.
     */
    distinct?: TelehealthParticipantScalarFieldEnum | TelehealthParticipantScalarFieldEnum[]
  }

  /**
   * TelehealthParticipant findFirstOrThrow
   */
  export type TelehealthParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthParticipant to fetch.
     */
    where?: TelehealthParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthParticipants to fetch.
     */
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelehealthParticipants.
     */
    cursor?: TelehealthParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelehealthParticipants.
     */
    distinct?: TelehealthParticipantScalarFieldEnum | TelehealthParticipantScalarFieldEnum[]
  }

  /**
   * TelehealthParticipant findMany
   */
  export type TelehealthParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TelehealthParticipants to fetch.
     */
    where?: TelehealthParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelehealthParticipants to fetch.
     */
    orderBy?: TelehealthParticipantOrderByWithRelationInput | TelehealthParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelehealthParticipants.
     */
    cursor?: TelehealthParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelehealthParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelehealthParticipants.
     */
    skip?: number
    distinct?: TelehealthParticipantScalarFieldEnum | TelehealthParticipantScalarFieldEnum[]
  }

  /**
   * TelehealthParticipant create
   */
  export type TelehealthParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TelehealthParticipant.
     */
    data: XOR<TelehealthParticipantCreateInput, TelehealthParticipantUncheckedCreateInput>
  }

  /**
   * TelehealthParticipant createMany
   */
  export type TelehealthParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelehealthParticipants.
     */
    data: TelehealthParticipantCreateManyInput | TelehealthParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelehealthParticipant createManyAndReturn
   */
  export type TelehealthParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TelehealthParticipants.
     */
    data: TelehealthParticipantCreateManyInput | TelehealthParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelehealthParticipant update
   */
  export type TelehealthParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TelehealthParticipant.
     */
    data: XOR<TelehealthParticipantUpdateInput, TelehealthParticipantUncheckedUpdateInput>
    /**
     * Choose, which TelehealthParticipant to update.
     */
    where: TelehealthParticipantWhereUniqueInput
  }

  /**
   * TelehealthParticipant updateMany
   */
  export type TelehealthParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelehealthParticipants.
     */
    data: XOR<TelehealthParticipantUpdateManyMutationInput, TelehealthParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TelehealthParticipants to update
     */
    where?: TelehealthParticipantWhereInput
    /**
     * Limit how many TelehealthParticipants to update.
     */
    limit?: number
  }

  /**
   * TelehealthParticipant updateManyAndReturn
   */
  export type TelehealthParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TelehealthParticipants.
     */
    data: XOR<TelehealthParticipantUpdateManyMutationInput, TelehealthParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TelehealthParticipants to update
     */
    where?: TelehealthParticipantWhereInput
    /**
     * Limit how many TelehealthParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelehealthParticipant upsert
   */
  export type TelehealthParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TelehealthParticipant to update in case it exists.
     */
    where: TelehealthParticipantWhereUniqueInput
    /**
     * In case the TelehealthParticipant found by the `where` argument doesn't exist, create a new TelehealthParticipant with this data.
     */
    create: XOR<TelehealthParticipantCreateInput, TelehealthParticipantUncheckedCreateInput>
    /**
     * In case the TelehealthParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelehealthParticipantUpdateInput, TelehealthParticipantUncheckedUpdateInput>
  }

  /**
   * TelehealthParticipant delete
   */
  export type TelehealthParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
    /**
     * Filter which TelehealthParticipant to delete.
     */
    where: TelehealthParticipantWhereUniqueInput
  }

  /**
   * TelehealthParticipant deleteMany
   */
  export type TelehealthParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelehealthParticipants to delete
     */
    where?: TelehealthParticipantWhereInput
    /**
     * Limit how many TelehealthParticipants to delete.
     */
    limit?: number
  }

  /**
   * TelehealthParticipant without action
   */
  export type TelehealthParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelehealthParticipant
     */
    select?: TelehealthParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelehealthParticipant
     */
    omit?: TelehealthParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelehealthParticipantInclude<ExtArgs> | null
  }


  /**
   * Model RecordingMetadata
   */

  export type AggregateRecordingMetadata = {
    _count: RecordingMetadataCountAggregateOutputType | null
    _avg: RecordingMetadataAvgAggregateOutputType | null
    _sum: RecordingMetadataSumAggregateOutputType | null
    _min: RecordingMetadataMinAggregateOutputType | null
    _max: RecordingMetadataMaxAggregateOutputType | null
  }

  export type RecordingMetadataAvgAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type RecordingMetadataSumAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type RecordingMetadataMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    fileName: string | null
    fileSize: number | null
    duration: number | null
    mimeType: string | null
    downloadUrl: string | null
    createdAt: Date | null
  }

  export type RecordingMetadataMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    fileName: string | null
    fileSize: number | null
    duration: number | null
    mimeType: string | null
    downloadUrl: string | null
    createdAt: Date | null
  }

  export type RecordingMetadataCountAggregateOutputType = {
    id: number
    sessionId: number
    fileName: number
    fileSize: number
    duration: number
    mimeType: number
    downloadUrl: number
    createdAt: number
    _all: number
  }


  export type RecordingMetadataAvgAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type RecordingMetadataSumAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type RecordingMetadataMinAggregateInputType = {
    id?: true
    sessionId?: true
    fileName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    downloadUrl?: true
    createdAt?: true
  }

  export type RecordingMetadataMaxAggregateInputType = {
    id?: true
    sessionId?: true
    fileName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    downloadUrl?: true
    createdAt?: true
  }

  export type RecordingMetadataCountAggregateInputType = {
    id?: true
    sessionId?: true
    fileName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    downloadUrl?: true
    createdAt?: true
    _all?: true
  }

  export type RecordingMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecordingMetadata to aggregate.
     */
    where?: RecordingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingMetadata to fetch.
     */
    orderBy?: RecordingMetadataOrderByWithRelationInput | RecordingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecordingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecordingMetadata
    **/
    _count?: true | RecordingMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecordingMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecordingMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecordingMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecordingMetadataMaxAggregateInputType
  }

  export type GetRecordingMetadataAggregateType<T extends RecordingMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateRecordingMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecordingMetadata[P]>
      : GetScalarType<T[P], AggregateRecordingMetadata[P]>
  }




  export type RecordingMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordingMetadataWhereInput
    orderBy?: RecordingMetadataOrderByWithAggregationInput | RecordingMetadataOrderByWithAggregationInput[]
    by: RecordingMetadataScalarFieldEnum[] | RecordingMetadataScalarFieldEnum
    having?: RecordingMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecordingMetadataCountAggregateInputType | true
    _avg?: RecordingMetadataAvgAggregateInputType
    _sum?: RecordingMetadataSumAggregateInputType
    _min?: RecordingMetadataMinAggregateInputType
    _max?: RecordingMetadataMaxAggregateInputType
  }

  export type RecordingMetadataGroupByOutputType = {
    id: string
    sessionId: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl: string | null
    createdAt: Date
    _count: RecordingMetadataCountAggregateOutputType | null
    _avg: RecordingMetadataAvgAggregateOutputType | null
    _sum: RecordingMetadataSumAggregateOutputType | null
    _min: RecordingMetadataMinAggregateOutputType | null
    _max: RecordingMetadataMaxAggregateOutputType | null
  }

  type GetRecordingMetadataGroupByPayload<T extends RecordingMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecordingMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecordingMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecordingMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], RecordingMetadataGroupByOutputType[P]>
        }
      >
    >


  export type RecordingMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    fileName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recordingMetadata"]>

  export type RecordingMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    fileName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recordingMetadata"]>

  export type RecordingMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    fileName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recordingMetadata"]>

  export type RecordingMetadataSelectScalar = {
    id?: boolean
    sessionId?: boolean
    fileName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
  }

  export type RecordingMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "fileName" | "fileSize" | "duration" | "mimeType" | "downloadUrl" | "createdAt", ExtArgs["result"]["recordingMetadata"]>
  export type RecordingMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }
  export type RecordingMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }
  export type RecordingMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }

  export type $RecordingMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecordingMetadata"
    objects: {
      session: Prisma.$TelehealthSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      fileName: string
      fileSize: number
      duration: number
      mimeType: string
      downloadUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["recordingMetadata"]>
    composites: {}
  }

  type RecordingMetadataGetPayload<S extends boolean | null | undefined | RecordingMetadataDefaultArgs> = $Result.GetResult<Prisma.$RecordingMetadataPayload, S>

  type RecordingMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecordingMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecordingMetadataCountAggregateInputType | true
    }

  export interface RecordingMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecordingMetadata'], meta: { name: 'RecordingMetadata' } }
    /**
     * Find zero or one RecordingMetadata that matches the filter.
     * @param {RecordingMetadataFindUniqueArgs} args - Arguments to find a RecordingMetadata
     * @example
     * // Get one RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecordingMetadataFindUniqueArgs>(args: SelectSubset<T, RecordingMetadataFindUniqueArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecordingMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecordingMetadataFindUniqueOrThrowArgs} args - Arguments to find a RecordingMetadata
     * @example
     * // Get one RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecordingMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, RecordingMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecordingMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataFindFirstArgs} args - Arguments to find a RecordingMetadata
     * @example
     * // Get one RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecordingMetadataFindFirstArgs>(args?: SelectSubset<T, RecordingMetadataFindFirstArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecordingMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataFindFirstOrThrowArgs} args - Arguments to find a RecordingMetadata
     * @example
     * // Get one RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecordingMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, RecordingMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecordingMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findMany()
     * 
     * // Get first 10 RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recordingMetadataWithIdOnly = await prisma.recordingMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecordingMetadataFindManyArgs>(args?: SelectSubset<T, RecordingMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecordingMetadata.
     * @param {RecordingMetadataCreateArgs} args - Arguments to create a RecordingMetadata.
     * @example
     * // Create one RecordingMetadata
     * const RecordingMetadata = await prisma.recordingMetadata.create({
     *   data: {
     *     // ... data to create a RecordingMetadata
     *   }
     * })
     * 
     */
    create<T extends RecordingMetadataCreateArgs>(args: SelectSubset<T, RecordingMetadataCreateArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecordingMetadata.
     * @param {RecordingMetadataCreateManyArgs} args - Arguments to create many RecordingMetadata.
     * @example
     * // Create many RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecordingMetadataCreateManyArgs>(args?: SelectSubset<T, RecordingMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecordingMetadata and returns the data saved in the database.
     * @param {RecordingMetadataCreateManyAndReturnArgs} args - Arguments to create many RecordingMetadata.
     * @example
     * // Create many RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecordingMetadata and only return the `id`
     * const recordingMetadataWithIdOnly = await prisma.recordingMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecordingMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, RecordingMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecordingMetadata.
     * @param {RecordingMetadataDeleteArgs} args - Arguments to delete one RecordingMetadata.
     * @example
     * // Delete one RecordingMetadata
     * const RecordingMetadata = await prisma.recordingMetadata.delete({
     *   where: {
     *     // ... filter to delete one RecordingMetadata
     *   }
     * })
     * 
     */
    delete<T extends RecordingMetadataDeleteArgs>(args: SelectSubset<T, RecordingMetadataDeleteArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecordingMetadata.
     * @param {RecordingMetadataUpdateArgs} args - Arguments to update one RecordingMetadata.
     * @example
     * // Update one RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecordingMetadataUpdateArgs>(args: SelectSubset<T, RecordingMetadataUpdateArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecordingMetadata.
     * @param {RecordingMetadataDeleteManyArgs} args - Arguments to filter RecordingMetadata to delete.
     * @example
     * // Delete a few RecordingMetadata
     * const { count } = await prisma.recordingMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecordingMetadataDeleteManyArgs>(args?: SelectSubset<T, RecordingMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecordingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecordingMetadataUpdateManyArgs>(args: SelectSubset<T, RecordingMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecordingMetadata and returns the data updated in the database.
     * @param {RecordingMetadataUpdateManyAndReturnArgs} args - Arguments to update many RecordingMetadata.
     * @example
     * // Update many RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecordingMetadata and only return the `id`
     * const recordingMetadataWithIdOnly = await prisma.recordingMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecordingMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, RecordingMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecordingMetadata.
     * @param {RecordingMetadataUpsertArgs} args - Arguments to update or create a RecordingMetadata.
     * @example
     * // Update or create a RecordingMetadata
     * const recordingMetadata = await prisma.recordingMetadata.upsert({
     *   create: {
     *     // ... data to create a RecordingMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecordingMetadata we want to update
     *   }
     * })
     */
    upsert<T extends RecordingMetadataUpsertArgs>(args: SelectSubset<T, RecordingMetadataUpsertArgs<ExtArgs>>): Prisma__RecordingMetadataClient<$Result.GetResult<Prisma.$RecordingMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecordingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataCountArgs} args - Arguments to filter RecordingMetadata to count.
     * @example
     * // Count the number of RecordingMetadata
     * const count = await prisma.recordingMetadata.count({
     *   where: {
     *     // ... the filter for the RecordingMetadata we want to count
     *   }
     * })
    **/
    count<T extends RecordingMetadataCountArgs>(
      args?: Subset<T, RecordingMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecordingMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecordingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecordingMetadataAggregateArgs>(args: Subset<T, RecordingMetadataAggregateArgs>): Prisma.PrismaPromise<GetRecordingMetadataAggregateType<T>>

    /**
     * Group by RecordingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecordingMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecordingMetadataGroupByArgs['orderBy'] }
        : { orderBy?: RecordingMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecordingMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecordingMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecordingMetadata model
   */
  readonly fields: RecordingMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecordingMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecordingMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TelehealthSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSessionDefaultArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecordingMetadata model
   */
  interface RecordingMetadataFieldRefs {
    readonly id: FieldRef<"RecordingMetadata", 'String'>
    readonly sessionId: FieldRef<"RecordingMetadata", 'String'>
    readonly fileName: FieldRef<"RecordingMetadata", 'String'>
    readonly fileSize: FieldRef<"RecordingMetadata", 'Int'>
    readonly duration: FieldRef<"RecordingMetadata", 'Int'>
    readonly mimeType: FieldRef<"RecordingMetadata", 'String'>
    readonly downloadUrl: FieldRef<"RecordingMetadata", 'String'>
    readonly createdAt: FieldRef<"RecordingMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecordingMetadata findUnique
   */
  export type RecordingMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which RecordingMetadata to fetch.
     */
    where: RecordingMetadataWhereUniqueInput
  }

  /**
   * RecordingMetadata findUniqueOrThrow
   */
  export type RecordingMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which RecordingMetadata to fetch.
     */
    where: RecordingMetadataWhereUniqueInput
  }

  /**
   * RecordingMetadata findFirst
   */
  export type RecordingMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which RecordingMetadata to fetch.
     */
    where?: RecordingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingMetadata to fetch.
     */
    orderBy?: RecordingMetadataOrderByWithRelationInput | RecordingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecordingMetadata.
     */
    cursor?: RecordingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecordingMetadata.
     */
    distinct?: RecordingMetadataScalarFieldEnum | RecordingMetadataScalarFieldEnum[]
  }

  /**
   * RecordingMetadata findFirstOrThrow
   */
  export type RecordingMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which RecordingMetadata to fetch.
     */
    where?: RecordingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingMetadata to fetch.
     */
    orderBy?: RecordingMetadataOrderByWithRelationInput | RecordingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecordingMetadata.
     */
    cursor?: RecordingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecordingMetadata.
     */
    distinct?: RecordingMetadataScalarFieldEnum | RecordingMetadataScalarFieldEnum[]
  }

  /**
   * RecordingMetadata findMany
   */
  export type RecordingMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which RecordingMetadata to fetch.
     */
    where?: RecordingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingMetadata to fetch.
     */
    orderBy?: RecordingMetadataOrderByWithRelationInput | RecordingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecordingMetadata.
     */
    cursor?: RecordingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingMetadata.
     */
    skip?: number
    distinct?: RecordingMetadataScalarFieldEnum | RecordingMetadataScalarFieldEnum[]
  }

  /**
   * RecordingMetadata create
   */
  export type RecordingMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a RecordingMetadata.
     */
    data: XOR<RecordingMetadataCreateInput, RecordingMetadataUncheckedCreateInput>
  }

  /**
   * RecordingMetadata createMany
   */
  export type RecordingMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecordingMetadata.
     */
    data: RecordingMetadataCreateManyInput | RecordingMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecordingMetadata createManyAndReturn
   */
  export type RecordingMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many RecordingMetadata.
     */
    data: RecordingMetadataCreateManyInput | RecordingMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecordingMetadata update
   */
  export type RecordingMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a RecordingMetadata.
     */
    data: XOR<RecordingMetadataUpdateInput, RecordingMetadataUncheckedUpdateInput>
    /**
     * Choose, which RecordingMetadata to update.
     */
    where: RecordingMetadataWhereUniqueInput
  }

  /**
   * RecordingMetadata updateMany
   */
  export type RecordingMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecordingMetadata.
     */
    data: XOR<RecordingMetadataUpdateManyMutationInput, RecordingMetadataUncheckedUpdateManyInput>
    /**
     * Filter which RecordingMetadata to update
     */
    where?: RecordingMetadataWhereInput
    /**
     * Limit how many RecordingMetadata to update.
     */
    limit?: number
  }

  /**
   * RecordingMetadata updateManyAndReturn
   */
  export type RecordingMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * The data used to update RecordingMetadata.
     */
    data: XOR<RecordingMetadataUpdateManyMutationInput, RecordingMetadataUncheckedUpdateManyInput>
    /**
     * Filter which RecordingMetadata to update
     */
    where?: RecordingMetadataWhereInput
    /**
     * Limit how many RecordingMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecordingMetadata upsert
   */
  export type RecordingMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the RecordingMetadata to update in case it exists.
     */
    where: RecordingMetadataWhereUniqueInput
    /**
     * In case the RecordingMetadata found by the `where` argument doesn't exist, create a new RecordingMetadata with this data.
     */
    create: XOR<RecordingMetadataCreateInput, RecordingMetadataUncheckedCreateInput>
    /**
     * In case the RecordingMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecordingMetadataUpdateInput, RecordingMetadataUncheckedUpdateInput>
  }

  /**
   * RecordingMetadata delete
   */
  export type RecordingMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
    /**
     * Filter which RecordingMetadata to delete.
     */
    where: RecordingMetadataWhereUniqueInput
  }

  /**
   * RecordingMetadata deleteMany
   */
  export type RecordingMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecordingMetadata to delete
     */
    where?: RecordingMetadataWhereInput
    /**
     * Limit how many RecordingMetadata to delete.
     */
    limit?: number
  }

  /**
   * RecordingMetadata without action
   */
  export type RecordingMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordingMetadata
     */
    select?: RecordingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecordingMetadata
     */
    omit?: RecordingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordingMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Transcript
   */

  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    content: string | null
    isEncrypted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    content: string | null
    isEncrypted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    sessionId: number
    content: number
    isEncrypted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TranscriptMinAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    isEncrypted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    isEncrypted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    isEncrypted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithAggregationInput | TranscriptOrderByWithAggregationInput[]
    by: TranscriptScalarFieldEnum[] | TranscriptScalarFieldEnum
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }

  export type TranscriptGroupByOutputType = {
    id: string
    sessionId: string
    content: string
    isEncrypted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    isEncrypted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    isEncrypted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    isEncrypted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectScalar = {
    id?: boolean
    sessionId?: boolean
    content?: boolean
    isEncrypted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TranscriptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "content" | "isEncrypted" | "createdAt" | "updatedAt", ExtArgs["result"]["transcript"]>
  export type TranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TelehealthSessionDefaultArgs<ExtArgs>
  }

  export type $TranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transcript"
    objects: {
      session: Prisma.$TelehealthSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      content: string
      isEncrypted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transcript"]>
    composites: {}
  }

  type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptDefaultArgs> = $Result.GetResult<Prisma.$TranscriptPayload, S>

  type TranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transcript'], meta: { name: 'Transcript' } }
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptFindUniqueArgs>(args: SelectSubset<T, TranscriptFindUniqueArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transcript that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptFindFirstArgs>(args?: SelectSubset<T, TranscriptFindFirstArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptFindManyArgs>(args?: SelectSubset<T, TranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
     */
    create<T extends TranscriptCreateArgs>(args: SelectSubset<T, TranscriptCreateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transcripts.
     * @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptCreateManyArgs>(args?: SelectSubset<T, TranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transcripts and returns the data saved in the database.
     * @param {TranscriptCreateManyAndReturnArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
     */
    delete<T extends TranscriptDeleteArgs>(args: SelectSubset<T, TranscriptDeleteArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUpdateArgs>(args: SelectSubset<T, TranscriptUpdateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptDeleteManyArgs>(args?: SelectSubset<T, TranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUpdateManyArgs>(args: SelectSubset<T, TranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts and returns the data updated in the database.
     * @param {TranscriptUpdateManyAndReturnArgs} args - Arguments to update many Transcripts.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUpsertArgs>(args: SelectSubset<T, TranscriptUpsertArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): Prisma.PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transcript model
   */
  readonly fields: TranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TelehealthSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelehealthSessionDefaultArgs<ExtArgs>>): Prisma__TelehealthSessionClient<$Result.GetResult<Prisma.$TelehealthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transcript model
   */
  interface TranscriptFieldRefs {
    readonly id: FieldRef<"Transcript", 'String'>
    readonly sessionId: FieldRef<"Transcript", 'String'>
    readonly content: FieldRef<"Transcript", 'String'>
    readonly isEncrypted: FieldRef<"Transcript", 'Boolean'>
    readonly createdAt: FieldRef<"Transcript", 'DateTime'>
    readonly updatedAt: FieldRef<"Transcript", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transcript findUnique
   */
  export type TranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findFirst
   */
  export type TranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript create
   */
  export type TranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }

  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transcript createManyAndReturn
   */
  export type TranscriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
  }

  /**
   * Transcript updateManyAndReturn
   */
  export type TranscriptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }

  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to delete.
     */
    limit?: number
  }

  /**
   * Transcript without action
   */
  export type TranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    oldValues: number
    newValues: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    oldValues?: true
    newValues?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    ipAddress: string
    userAgent: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "oldValues" | "newValues" | "ipAddress" | "userAgent" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      ipAddress: string
      userAgent: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    role: 'role',
    isActive: 'isActive',
    mustChangePassword: 'mustChangePassword',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dateOfBirth: 'dateOfBirth',
    street: 'street',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    emergencyContactName: 'emergencyContactName',
    emergencyContactRelationship: 'emergencyContactRelationship',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactEmail: 'emergencyContactEmail',
    insuranceProvider: 'insuranceProvider',
    insurancePolicyNumber: 'insurancePolicyNumber',
    insuranceGroupNumber: 'insuranceGroupNumber',
    insuranceCopay: 'insuranceCopay',
    insuranceDeductible: 'insuranceDeductible',
    medicalHistory: 'medicalHistory',
    allergies: 'allergies',
    assignedTherapistId: 'assignedTherapistId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    therapistId: 'therapistId',
    createdById: 'createdById',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    status: 'status',
    notes: 'notes',
    telehealthLink: 'telehealthLink',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const SOAPNoteScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    therapistId: 'therapistId',
    appointmentId: 'appointmentId',
    date: 'date',
    subjective: 'subjective',
    objective: 'objective',
    assessment: 'assessment',
    plan: 'plan',
    signature: 'signature',
    signatureDate: 'signatureDate',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SOAPNoteScalarFieldEnum = (typeof SOAPNoteScalarFieldEnum)[keyof typeof SOAPNoteScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    appointmentId: 'appointmentId',
    createdById: 'createdById',
    invoiceNumber: 'invoiceNumber',
    date: 'date',
    dueDate: 'dueDate',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    status: 'status',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    cptCode: 'cptCode',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    patientId: 'patientId',
    claimNumber: 'claimNumber',
    insuranceProvider: 'insuranceProvider',
    submissionDate: 'submissionDate',
    status: 'status',
    amount: 'amount',
    approvedAmount: 'approvedAmount',
    denialReason: 'denialReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const MessageThreadScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    lastActivity: 'lastActivity',
    isArchived: 'isArchived',
    createdAt: 'createdAt'
  };

  export type MessageThreadScalarFieldEnum = (typeof MessageThreadScalarFieldEnum)[keyof typeof MessageThreadScalarFieldEnum]


  export const MessageThreadParticipantScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    userId: 'userId',
    joinedAt: 'joinedAt'
  };

  export type MessageThreadParticipantScalarFieldEnum = (typeof MessageThreadParticipantScalarFieldEnum)[keyof typeof MessageThreadParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    senderId: 'senderId',
    readerId: 'readerId',
    content: 'content',
    priority: 'priority',
    isRead: 'isRead',
    isEncrypted: 'isEncrypted',
    sentAt: 'sentAt',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isEncrypted: 'isEncrypted',
    uploadedAt: 'uploadedAt'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    title: 'title',
    description: 'description',
    category: 'category',
    tags: 'tags',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isEncrypted: 'isEncrypted',
    signature: 'signature',
    signatureDate: 'signatureDate',
    isSigned: 'isSigned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentShareScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    recipientEmail: 'recipientEmail',
    shareType: 'shareType',
    expiresAt: 'expiresAt',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type DocumentShareScalarFieldEnum = (typeof DocumentShareScalarFieldEnum)[keyof typeof DocumentShareScalarFieldEnum]


  export const DocumentAccessLogScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    accessedAt: 'accessedAt',
    action: 'action'
  };

  export type DocumentAccessLogScalarFieldEnum = (typeof DocumentAccessLogScalarFieldEnum)[keyof typeof DocumentAccessLogScalarFieldEnum]


  export const TelehealthSessionScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    patientId: 'patientId',
    roomId: 'roomId',
    sessionUrl: 'sessionUrl',
    status: 'status',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    scheduledDuration: 'scheduledDuration',
    actualDuration: 'actualDuration',
    platform: 'platform',
    recordingEnabled: 'recordingEnabled',
    recordingUrl: 'recordingUrl',
    recordingSize: 'recordingSize',
    recordingDuration: 'recordingDuration',
    chatEnabled: 'chatEnabled',
    screenShareEnabled: 'screenShareEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelehealthSessionScalarFieldEnum = (typeof TelehealthSessionScalarFieldEnum)[keyof typeof TelehealthSessionScalarFieldEnum]


  export const TelehealthParticipantScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    role: 'role',
    status: 'status',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    connectionQuality: 'connectionQuality',
    cameraEnabled: 'cameraEnabled',
    micEnabled: 'micEnabled',
    screenSharing: 'screenSharing',
    createdAt: 'createdAt'
  };

  export type TelehealthParticipantScalarFieldEnum = (typeof TelehealthParticipantScalarFieldEnum)[keyof typeof TelehealthParticipantScalarFieldEnum]


  export const RecordingMetadataScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    duration: 'duration',
    mimeType: 'mimeType',
    downloadUrl: 'downloadUrl',
    createdAt: 'createdAt'
  };

  export type RecordingMetadataScalarFieldEnum = (typeof RecordingMetadataScalarFieldEnum)[keyof typeof RecordingMetadataScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    content: 'content',
    isEncrypted: 'isEncrypted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AppointmentType'
   */
  export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType'>
    


  /**
   * Reference to a field of type 'AppointmentType[]'
   */
  export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentCategory'
   */
  export type EnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory'>
    


  /**
   * Reference to a field of type 'DocumentCategory[]'
   */
  export type ListEnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory[]'>
    


  /**
   * Reference to a field of type 'TelehealthStatus'
   */
  export type EnumTelehealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TelehealthStatus'>
    


  /**
   * Reference to a field of type 'TelehealthStatus[]'
   */
  export type ListEnumTelehealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TelehealthStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    mustChangePassword?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    patientProfile?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    assignedPatients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    createdAppointments?: AppointmentListRelationFilter
    sentMessages?: MessageListRelationFilter
    readMessages?: MessageListRelationFilter
    messageThreadParticipants?: MessageThreadParticipantListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    createdNotes?: SOAPNoteListRelationFilter
    sessionParticipants?: TelehealthParticipantListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mustChangePassword?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    patientProfile?: PatientOrderByWithRelationInput
    assignedPatients?: PatientOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    createdAppointments?: AppointmentOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    readMessages?: MessageOrderByRelationAggregateInput
    messageThreadParticipants?: MessageThreadParticipantOrderByRelationAggregateInput
    createdInvoices?: InvoiceOrderByRelationAggregateInput
    createdNotes?: SOAPNoteOrderByRelationAggregateInput
    sessionParticipants?: TelehealthParticipantOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    mustChangePassword?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    patientProfile?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    assignedPatients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    createdAppointments?: AppointmentListRelationFilter
    sentMessages?: MessageListRelationFilter
    readMessages?: MessageListRelationFilter
    messageThreadParticipants?: MessageThreadParticipantListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    createdNotes?: SOAPNoteListRelationFilter
    sessionParticipants?: TelehealthParticipantListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mustChangePassword?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    mustChangePassword?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    street?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    zipCode?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    emergencyContactEmail?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceGroupNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceCopay?: FloatNullableFilter<"Patient"> | number | null
    insuranceDeductible?: FloatNullableFilter<"Patient"> | number | null
    medicalHistory?: StringNullableFilter<"Patient"> | string | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    assignedTherapistId?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTherapist?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    soapNotes?: SOAPNoteListRelationFilter
    documents?: DocumentListRelationFilter
    sessions?: TelehealthSessionListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactEmail?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insurancePolicyNumber?: SortOrderInput | SortOrder
    insuranceGroupNumber?: SortOrderInput | SortOrder
    insuranceCopay?: SortOrderInput | SortOrder
    insuranceDeductible?: SortOrderInput | SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    assignedTherapistId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedTherapist?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    soapNotes?: SOAPNoteOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    sessions?: TelehealthSessionOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    street?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    zipCode?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    emergencyContactEmail?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceGroupNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceCopay?: FloatNullableFilter<"Patient"> | number | null
    insuranceDeductible?: FloatNullableFilter<"Patient"> | number | null
    medicalHistory?: StringNullableFilter<"Patient"> | string | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    assignedTherapistId?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTherapist?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    soapNotes?: SOAPNoteListRelationFilter
    documents?: DocumentListRelationFilter
    sessions?: TelehealthSessionListRelationFilter
  }, "id" | "userId">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactEmail?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insurancePolicyNumber?: SortOrderInput | SortOrder
    insuranceGroupNumber?: SortOrderInput | SortOrder
    insuranceCopay?: SortOrderInput | SortOrder
    insuranceDeductible?: SortOrderInput | SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    assignedTherapistId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    userId?: StringWithAggregatesFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    street?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    city?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    state?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    country?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactRelationship?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactEmail?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insurancePolicyNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceGroupNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceCopay?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    insuranceDeductible?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    medicalHistory?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    assignedTherapistId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    isActive?: BoolWithAggregatesFilter<"Patient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    therapistId?: StringFilter<"Appointment"> | string
    createdById?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    telehealthLink?: StringNullableFilter<"Appointment"> | string | null
    location?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    therapist?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    soapNote?: XOR<SOAPNoteNullableScalarRelationFilter, SOAPNoteWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    session?: XOR<TelehealthSessionNullableScalarRelationFilter, TelehealthSessionWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    createdById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    telehealthLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    therapist?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    soapNote?: SOAPNoteOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    session?: TelehealthSessionOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    therapistId?: StringFilter<"Appointment"> | string
    createdById?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    telehealthLink?: StringNullableFilter<"Appointment"> | string | null
    location?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    therapist?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    soapNote?: XOR<SOAPNoteNullableScalarRelationFilter, SOAPNoteWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    session?: XOR<TelehealthSessionNullableScalarRelationFilter, TelehealthSessionWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    createdById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    telehealthLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    therapistId?: StringWithAggregatesFilter<"Appointment"> | string
    createdById?: StringWithAggregatesFilter<"Appointment"> | string
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    type?: EnumAppointmentTypeWithAggregatesFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    telehealthLink?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type SOAPNoteWhereInput = {
    AND?: SOAPNoteWhereInput | SOAPNoteWhereInput[]
    OR?: SOAPNoteWhereInput[]
    NOT?: SOAPNoteWhereInput | SOAPNoteWhereInput[]
    id?: StringFilter<"SOAPNote"> | string
    patientId?: StringFilter<"SOAPNote"> | string
    therapistId?: StringFilter<"SOAPNote"> | string
    appointmentId?: StringNullableFilter<"SOAPNote"> | string | null
    date?: DateTimeFilter<"SOAPNote"> | Date | string
    subjective?: StringFilter<"SOAPNote"> | string
    objective?: StringFilter<"SOAPNote"> | string
    assessment?: StringFilter<"SOAPNote"> | string
    plan?: StringFilter<"SOAPNote"> | string
    signature?: StringNullableFilter<"SOAPNote"> | string | null
    signatureDate?: DateTimeNullableFilter<"SOAPNote"> | Date | string | null
    isLocked?: BoolFilter<"SOAPNote"> | boolean
    createdAt?: DateTimeFilter<"SOAPNote"> | Date | string
    updatedAt?: DateTimeFilter<"SOAPNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    therapist?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }

  export type SOAPNoteOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    date?: SortOrder
    subjective?: SortOrder
    objective?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    signature?: SortOrderInput | SortOrder
    signatureDate?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    therapist?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type SOAPNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: SOAPNoteWhereInput | SOAPNoteWhereInput[]
    OR?: SOAPNoteWhereInput[]
    NOT?: SOAPNoteWhereInput | SOAPNoteWhereInput[]
    patientId?: StringFilter<"SOAPNote"> | string
    therapistId?: StringFilter<"SOAPNote"> | string
    date?: DateTimeFilter<"SOAPNote"> | Date | string
    subjective?: StringFilter<"SOAPNote"> | string
    objective?: StringFilter<"SOAPNote"> | string
    assessment?: StringFilter<"SOAPNote"> | string
    plan?: StringFilter<"SOAPNote"> | string
    signature?: StringNullableFilter<"SOAPNote"> | string | null
    signatureDate?: DateTimeNullableFilter<"SOAPNote"> | Date | string | null
    isLocked?: BoolFilter<"SOAPNote"> | boolean
    createdAt?: DateTimeFilter<"SOAPNote"> | Date | string
    updatedAt?: DateTimeFilter<"SOAPNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    therapist?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }, "id" | "appointmentId">

  export type SOAPNoteOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    date?: SortOrder
    subjective?: SortOrder
    objective?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    signature?: SortOrderInput | SortOrder
    signatureDate?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SOAPNoteCountOrderByAggregateInput
    _max?: SOAPNoteMaxOrderByAggregateInput
    _min?: SOAPNoteMinOrderByAggregateInput
  }

  export type SOAPNoteScalarWhereWithAggregatesInput = {
    AND?: SOAPNoteScalarWhereWithAggregatesInput | SOAPNoteScalarWhereWithAggregatesInput[]
    OR?: SOAPNoteScalarWhereWithAggregatesInput[]
    NOT?: SOAPNoteScalarWhereWithAggregatesInput | SOAPNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SOAPNote"> | string
    patientId?: StringWithAggregatesFilter<"SOAPNote"> | string
    therapistId?: StringWithAggregatesFilter<"SOAPNote"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"SOAPNote"> | string | null
    date?: DateTimeWithAggregatesFilter<"SOAPNote"> | Date | string
    subjective?: StringWithAggregatesFilter<"SOAPNote"> | string
    objective?: StringWithAggregatesFilter<"SOAPNote"> | string
    assessment?: StringWithAggregatesFilter<"SOAPNote"> | string
    plan?: StringWithAggregatesFilter<"SOAPNote"> | string
    signature?: StringNullableWithAggregatesFilter<"SOAPNote"> | string | null
    signatureDate?: DateTimeNullableWithAggregatesFilter<"SOAPNote"> | Date | string | null
    isLocked?: BoolWithAggregatesFilter<"SOAPNote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SOAPNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SOAPNote"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    appointmentId?: StringNullableFilter<"Invoice"> | string | null
    createdById?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paymentDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    claim?: XOR<ClaimNullableScalarRelationFilter, ClaimWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    claim?: ClaimOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    patientId?: StringFilter<"Invoice"> | string
    createdById?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paymentDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    claim?: XOR<ClaimNullableScalarRelationFilter, ClaimWhereInput> | null
  }, "id" | "appointmentId" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    patientId?: StringWithAggregatesFilter<"Invoice"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdById?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    tax?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    cptCode?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    cptCode?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    cptCode?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    cptCode?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    cptCode?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"InvoiceItem"> | number
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    invoiceId?: StringFilter<"Claim"> | string
    patientId?: StringFilter<"Claim"> | string
    claimNumber?: StringFilter<"Claim"> | string
    insuranceProvider?: StringFilter<"Claim"> | string
    submissionDate?: DateTimeFilter<"Claim"> | Date | string
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    amount?: FloatFilter<"Claim"> | number
    approvedAmount?: FloatNullableFilter<"Claim"> | number | null
    denialReason?: StringNullableFilter<"Claim"> | string | null
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    claimNumber?: SortOrder
    insuranceProvider?: SortOrder
    submissionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    denialReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceId?: string
    claimNumber?: string
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    patientId?: StringFilter<"Claim"> | string
    insuranceProvider?: StringFilter<"Claim"> | string
    submissionDate?: DateTimeFilter<"Claim"> | Date | string
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    amount?: FloatFilter<"Claim"> | number
    approvedAmount?: FloatNullableFilter<"Claim"> | number | null
    denialReason?: StringNullableFilter<"Claim"> | string | null
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id" | "invoiceId" | "claimNumber">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    claimNumber?: SortOrder
    insuranceProvider?: SortOrder
    submissionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    denialReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    invoiceId?: StringWithAggregatesFilter<"Claim"> | string
    patientId?: StringWithAggregatesFilter<"Claim"> | string
    claimNumber?: StringWithAggregatesFilter<"Claim"> | string
    insuranceProvider?: StringWithAggregatesFilter<"Claim"> | string
    submissionDate?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    status?: EnumClaimStatusWithAggregatesFilter<"Claim"> | $Enums.ClaimStatus
    amount?: FloatWithAggregatesFilter<"Claim"> | number
    approvedAmount?: FloatNullableWithAggregatesFilter<"Claim"> | number | null
    denialReason?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
  }

  export type MessageThreadWhereInput = {
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    id?: StringFilter<"MessageThread"> | string
    subject?: StringFilter<"MessageThread"> | string
    lastActivity?: DateTimeFilter<"MessageThread"> | Date | string
    isArchived?: BoolFilter<"MessageThread"> | boolean
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    messages?: MessageListRelationFilter
    participants?: MessageThreadParticipantListRelationFilter
  }

  export type MessageThreadOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    lastActivity?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    participants?: MessageThreadParticipantOrderByRelationAggregateInput
  }

  export type MessageThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    subject?: StringFilter<"MessageThread"> | string
    lastActivity?: DateTimeFilter<"MessageThread"> | Date | string
    isArchived?: BoolFilter<"MessageThread"> | boolean
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    messages?: MessageListRelationFilter
    participants?: MessageThreadParticipantListRelationFilter
  }, "id">

  export type MessageThreadOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    lastActivity?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    _count?: MessageThreadCountOrderByAggregateInput
    _max?: MessageThreadMaxOrderByAggregateInput
    _min?: MessageThreadMinOrderByAggregateInput
  }

  export type MessageThreadScalarWhereWithAggregatesInput = {
    AND?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    OR?: MessageThreadScalarWhereWithAggregatesInput[]
    NOT?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageThread"> | string
    subject?: StringWithAggregatesFilter<"MessageThread"> | string
    lastActivity?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
    isArchived?: BoolWithAggregatesFilter<"MessageThread"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
  }

  export type MessageThreadParticipantWhereInput = {
    AND?: MessageThreadParticipantWhereInput | MessageThreadParticipantWhereInput[]
    OR?: MessageThreadParticipantWhereInput[]
    NOT?: MessageThreadParticipantWhereInput | MessageThreadParticipantWhereInput[]
    id?: StringFilter<"MessageThreadParticipant"> | string
    threadId?: StringFilter<"MessageThreadParticipant"> | string
    userId?: StringFilter<"MessageThreadParticipant"> | string
    joinedAt?: DateTimeFilter<"MessageThreadParticipant"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageThreadParticipantOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageThreadParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    threadId_userId?: MessageThreadParticipantThreadIdUserIdCompoundUniqueInput
    AND?: MessageThreadParticipantWhereInput | MessageThreadParticipantWhereInput[]
    OR?: MessageThreadParticipantWhereInput[]
    NOT?: MessageThreadParticipantWhereInput | MessageThreadParticipantWhereInput[]
    threadId?: StringFilter<"MessageThreadParticipant"> | string
    userId?: StringFilter<"MessageThreadParticipant"> | string
    joinedAt?: DateTimeFilter<"MessageThreadParticipant"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "threadId_userId">

  export type MessageThreadParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    _count?: MessageThreadParticipantCountOrderByAggregateInput
    _max?: MessageThreadParticipantMaxOrderByAggregateInput
    _min?: MessageThreadParticipantMinOrderByAggregateInput
  }

  export type MessageThreadParticipantScalarWhereWithAggregatesInput = {
    AND?: MessageThreadParticipantScalarWhereWithAggregatesInput | MessageThreadParticipantScalarWhereWithAggregatesInput[]
    OR?: MessageThreadParticipantScalarWhereWithAggregatesInput[]
    NOT?: MessageThreadParticipantScalarWhereWithAggregatesInput | MessageThreadParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageThreadParticipant"> | string
    threadId?: StringWithAggregatesFilter<"MessageThreadParticipant"> | string
    userId?: StringWithAggregatesFilter<"MessageThreadParticipant"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"MessageThreadParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    readerId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    priority?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isEncrypted?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    reader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    attachments?: MessageAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    readerId?: SortOrderInput | SortOrder
    content?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isEncrypted?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    reader?: UserOrderByWithRelationInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    readerId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    priority?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isEncrypted?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    reader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    attachments?: MessageAttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    readerId?: SortOrderInput | SortOrder
    content?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isEncrypted?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    threadId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    readerId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringWithAggregatesFilter<"Message"> | string
    priority?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    isEncrypted?: BoolWithAggregatesFilter<"Message"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    isEncrypted?: BoolFilter<"MessageAttachment"> | boolean
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    uploadedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    isEncrypted?: BoolFilter<"MessageAttachment"> | boolean
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    uploadedAt?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileName?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"MessageAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"MessageAttachment"> | string
    isEncrypted?: BoolWithAggregatesFilter<"MessageAttachment"> | boolean
    uploadedAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    patientId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    tags?: StringNullableListFilter<"Document">
    fileUrl?: StringNullableFilter<"Document"> | string | null
    fileName?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    isEncrypted?: BoolFilter<"Document"> | boolean
    signature?: StringNullableFilter<"Document"> | string | null
    signatureDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isSigned?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    shares?: DocumentShareListRelationFilter
    accessHistory?: DocumentAccessLogListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isEncrypted?: SortOrder
    signature?: SortOrderInput | SortOrder
    signatureDate?: SortOrderInput | SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    shares?: DocumentShareOrderByRelationAggregateInput
    accessHistory?: DocumentAccessLogOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    patientId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    tags?: StringNullableListFilter<"Document">
    fileUrl?: StringNullableFilter<"Document"> | string | null
    fileName?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    isEncrypted?: BoolFilter<"Document"> | boolean
    signature?: StringNullableFilter<"Document"> | string | null
    signatureDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isSigned?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    shares?: DocumentShareListRelationFilter
    accessHistory?: DocumentAccessLogListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isEncrypted?: SortOrder
    signature?: SortOrderInput | SortOrder
    signatureDate?: SortOrderInput | SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    patientId?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    category?: EnumDocumentCategoryWithAggregatesFilter<"Document"> | $Enums.DocumentCategory
    tags?: StringNullableListFilter<"Document">
    fileUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    isEncrypted?: BoolWithAggregatesFilter<"Document"> | boolean
    signature?: StringNullableWithAggregatesFilter<"Document"> | string | null
    signatureDate?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    isSigned?: BoolWithAggregatesFilter<"Document"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentShareWhereInput = {
    AND?: DocumentShareWhereInput | DocumentShareWhereInput[]
    OR?: DocumentShareWhereInput[]
    NOT?: DocumentShareWhereInput | DocumentShareWhereInput[]
    id?: StringFilter<"DocumentShare"> | string
    documentId?: StringFilter<"DocumentShare"> | string
    recipientEmail?: StringFilter<"DocumentShare"> | string
    shareType?: StringFilter<"DocumentShare"> | string
    expiresAt?: DateTimeNullableFilter<"DocumentShare"> | Date | string | null
    message?: StringNullableFilter<"DocumentShare"> | string | null
    createdAt?: DateTimeFilter<"DocumentShare"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type DocumentShareOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    recipientEmail?: SortOrder
    shareType?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentShareWhereInput | DocumentShareWhereInput[]
    OR?: DocumentShareWhereInput[]
    NOT?: DocumentShareWhereInput | DocumentShareWhereInput[]
    documentId?: StringFilter<"DocumentShare"> | string
    recipientEmail?: StringFilter<"DocumentShare"> | string
    shareType?: StringFilter<"DocumentShare"> | string
    expiresAt?: DateTimeNullableFilter<"DocumentShare"> | Date | string | null
    message?: StringNullableFilter<"DocumentShare"> | string | null
    createdAt?: DateTimeFilter<"DocumentShare"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id">

  export type DocumentShareOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    recipientEmail?: SortOrder
    shareType?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentShareCountOrderByAggregateInput
    _max?: DocumentShareMaxOrderByAggregateInput
    _min?: DocumentShareMinOrderByAggregateInput
  }

  export type DocumentShareScalarWhereWithAggregatesInput = {
    AND?: DocumentShareScalarWhereWithAggregatesInput | DocumentShareScalarWhereWithAggregatesInput[]
    OR?: DocumentShareScalarWhereWithAggregatesInput[]
    NOT?: DocumentShareScalarWhereWithAggregatesInput | DocumentShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentShare"> | string
    documentId?: StringWithAggregatesFilter<"DocumentShare"> | string
    recipientEmail?: StringWithAggregatesFilter<"DocumentShare"> | string
    shareType?: StringWithAggregatesFilter<"DocumentShare"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DocumentShare"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"DocumentShare"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentShare"> | Date | string
  }

  export type DocumentAccessLogWhereInput = {
    AND?: DocumentAccessLogWhereInput | DocumentAccessLogWhereInput[]
    OR?: DocumentAccessLogWhereInput[]
    NOT?: DocumentAccessLogWhereInput | DocumentAccessLogWhereInput[]
    id?: StringFilter<"DocumentAccessLog"> | string
    documentId?: StringFilter<"DocumentAccessLog"> | string
    accessedAt?: DateTimeFilter<"DocumentAccessLog"> | Date | string
    action?: StringFilter<"DocumentAccessLog"> | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type DocumentAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    accessedAt?: SortOrder
    action?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentAccessLogWhereInput | DocumentAccessLogWhereInput[]
    OR?: DocumentAccessLogWhereInput[]
    NOT?: DocumentAccessLogWhereInput | DocumentAccessLogWhereInput[]
    documentId?: StringFilter<"DocumentAccessLog"> | string
    accessedAt?: DateTimeFilter<"DocumentAccessLog"> | Date | string
    action?: StringFilter<"DocumentAccessLog"> | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id">

  export type DocumentAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    accessedAt?: SortOrder
    action?: SortOrder
    _count?: DocumentAccessLogCountOrderByAggregateInput
    _max?: DocumentAccessLogMaxOrderByAggregateInput
    _min?: DocumentAccessLogMinOrderByAggregateInput
  }

  export type DocumentAccessLogScalarWhereWithAggregatesInput = {
    AND?: DocumentAccessLogScalarWhereWithAggregatesInput | DocumentAccessLogScalarWhereWithAggregatesInput[]
    OR?: DocumentAccessLogScalarWhereWithAggregatesInput[]
    NOT?: DocumentAccessLogScalarWhereWithAggregatesInput | DocumentAccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentAccessLog"> | string
    documentId?: StringWithAggregatesFilter<"DocumentAccessLog"> | string
    accessedAt?: DateTimeWithAggregatesFilter<"DocumentAccessLog"> | Date | string
    action?: StringWithAggregatesFilter<"DocumentAccessLog"> | string
  }

  export type TelehealthSessionWhereInput = {
    AND?: TelehealthSessionWhereInput | TelehealthSessionWhereInput[]
    OR?: TelehealthSessionWhereInput[]
    NOT?: TelehealthSessionWhereInput | TelehealthSessionWhereInput[]
    id?: StringFilter<"TelehealthSession"> | string
    appointmentId?: StringNullableFilter<"TelehealthSession"> | string | null
    patientId?: StringFilter<"TelehealthSession"> | string
    roomId?: StringFilter<"TelehealthSession"> | string
    sessionUrl?: StringFilter<"TelehealthSession"> | string
    status?: EnumTelehealthStatusFilter<"TelehealthSession"> | $Enums.TelehealthStatus
    startedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    scheduledDuration?: IntFilter<"TelehealthSession"> | number
    actualDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    platform?: StringFilter<"TelehealthSession"> | string
    recordingEnabled?: BoolFilter<"TelehealthSession"> | boolean
    recordingUrl?: StringNullableFilter<"TelehealthSession"> | string | null
    recordingSize?: IntNullableFilter<"TelehealthSession"> | number | null
    recordingDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    chatEnabled?: BoolFilter<"TelehealthSession"> | boolean
    screenShareEnabled?: BoolFilter<"TelehealthSession"> | boolean
    createdAt?: DateTimeFilter<"TelehealthSession"> | Date | string
    updatedAt?: DateTimeFilter<"TelehealthSession"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    participants?: TelehealthParticipantListRelationFilter
    recordings?: RecordingMetadataListRelationFilter
    transcripts?: TranscriptListRelationFilter
  }

  export type TelehealthSessionOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    roomId?: SortOrder
    sessionUrl?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    scheduledDuration?: SortOrder
    actualDuration?: SortOrderInput | SortOrder
    platform?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingSize?: SortOrderInput | SortOrder
    recordingDuration?: SortOrderInput | SortOrder
    chatEnabled?: SortOrder
    screenShareEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    participants?: TelehealthParticipantOrderByRelationAggregateInput
    recordings?: RecordingMetadataOrderByRelationAggregateInput
    transcripts?: TranscriptOrderByRelationAggregateInput
  }

  export type TelehealthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    roomId?: string
    AND?: TelehealthSessionWhereInput | TelehealthSessionWhereInput[]
    OR?: TelehealthSessionWhereInput[]
    NOT?: TelehealthSessionWhereInput | TelehealthSessionWhereInput[]
    patientId?: StringFilter<"TelehealthSession"> | string
    sessionUrl?: StringFilter<"TelehealthSession"> | string
    status?: EnumTelehealthStatusFilter<"TelehealthSession"> | $Enums.TelehealthStatus
    startedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    scheduledDuration?: IntFilter<"TelehealthSession"> | number
    actualDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    platform?: StringFilter<"TelehealthSession"> | string
    recordingEnabled?: BoolFilter<"TelehealthSession"> | boolean
    recordingUrl?: StringNullableFilter<"TelehealthSession"> | string | null
    recordingSize?: IntNullableFilter<"TelehealthSession"> | number | null
    recordingDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    chatEnabled?: BoolFilter<"TelehealthSession"> | boolean
    screenShareEnabled?: BoolFilter<"TelehealthSession"> | boolean
    createdAt?: DateTimeFilter<"TelehealthSession"> | Date | string
    updatedAt?: DateTimeFilter<"TelehealthSession"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    participants?: TelehealthParticipantListRelationFilter
    recordings?: RecordingMetadataListRelationFilter
    transcripts?: TranscriptListRelationFilter
  }, "id" | "appointmentId" | "roomId">

  export type TelehealthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    roomId?: SortOrder
    sessionUrl?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    scheduledDuration?: SortOrder
    actualDuration?: SortOrderInput | SortOrder
    platform?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingSize?: SortOrderInput | SortOrder
    recordingDuration?: SortOrderInput | SortOrder
    chatEnabled?: SortOrder
    screenShareEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelehealthSessionCountOrderByAggregateInput
    _avg?: TelehealthSessionAvgOrderByAggregateInput
    _max?: TelehealthSessionMaxOrderByAggregateInput
    _min?: TelehealthSessionMinOrderByAggregateInput
    _sum?: TelehealthSessionSumOrderByAggregateInput
  }

  export type TelehealthSessionScalarWhereWithAggregatesInput = {
    AND?: TelehealthSessionScalarWhereWithAggregatesInput | TelehealthSessionScalarWhereWithAggregatesInput[]
    OR?: TelehealthSessionScalarWhereWithAggregatesInput[]
    NOT?: TelehealthSessionScalarWhereWithAggregatesInput | TelehealthSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelehealthSession"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"TelehealthSession"> | string | null
    patientId?: StringWithAggregatesFilter<"TelehealthSession"> | string
    roomId?: StringWithAggregatesFilter<"TelehealthSession"> | string
    sessionUrl?: StringWithAggregatesFilter<"TelehealthSession"> | string
    status?: EnumTelehealthStatusWithAggregatesFilter<"TelehealthSession"> | $Enums.TelehealthStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"TelehealthSession"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TelehealthSession"> | Date | string | null
    scheduledDuration?: IntWithAggregatesFilter<"TelehealthSession"> | number
    actualDuration?: IntNullableWithAggregatesFilter<"TelehealthSession"> | number | null
    platform?: StringWithAggregatesFilter<"TelehealthSession"> | string
    recordingEnabled?: BoolWithAggregatesFilter<"TelehealthSession"> | boolean
    recordingUrl?: StringNullableWithAggregatesFilter<"TelehealthSession"> | string | null
    recordingSize?: IntNullableWithAggregatesFilter<"TelehealthSession"> | number | null
    recordingDuration?: IntNullableWithAggregatesFilter<"TelehealthSession"> | number | null
    chatEnabled?: BoolWithAggregatesFilter<"TelehealthSession"> | boolean
    screenShareEnabled?: BoolWithAggregatesFilter<"TelehealthSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TelehealthSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelehealthSession"> | Date | string
  }

  export type TelehealthParticipantWhereInput = {
    AND?: TelehealthParticipantWhereInput | TelehealthParticipantWhereInput[]
    OR?: TelehealthParticipantWhereInput[]
    NOT?: TelehealthParticipantWhereInput | TelehealthParticipantWhereInput[]
    id?: StringFilter<"TelehealthParticipant"> | string
    sessionId?: StringFilter<"TelehealthParticipant"> | string
    userId?: StringFilter<"TelehealthParticipant"> | string
    role?: StringFilter<"TelehealthParticipant"> | string
    status?: StringFilter<"TelehealthParticipant"> | string
    joinedAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    connectionQuality?: StringNullableFilter<"TelehealthParticipant"> | string | null
    cameraEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    micEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    screenSharing?: BoolFilter<"TelehealthParticipant"> | boolean
    createdAt?: DateTimeFilter<"TelehealthParticipant"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TelehealthParticipantOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    connectionQuality?: SortOrderInput | SortOrder
    cameraEnabled?: SortOrder
    micEnabled?: SortOrder
    screenSharing?: SortOrder
    createdAt?: SortOrder
    session?: TelehealthSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TelehealthParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TelehealthParticipantWhereInput | TelehealthParticipantWhereInput[]
    OR?: TelehealthParticipantWhereInput[]
    NOT?: TelehealthParticipantWhereInput | TelehealthParticipantWhereInput[]
    sessionId?: StringFilter<"TelehealthParticipant"> | string
    userId?: StringFilter<"TelehealthParticipant"> | string
    role?: StringFilter<"TelehealthParticipant"> | string
    status?: StringFilter<"TelehealthParticipant"> | string
    joinedAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    connectionQuality?: StringNullableFilter<"TelehealthParticipant"> | string | null
    cameraEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    micEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    screenSharing?: BoolFilter<"TelehealthParticipant"> | boolean
    createdAt?: DateTimeFilter<"TelehealthParticipant"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TelehealthParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    connectionQuality?: SortOrderInput | SortOrder
    cameraEnabled?: SortOrder
    micEnabled?: SortOrder
    screenSharing?: SortOrder
    createdAt?: SortOrder
    _count?: TelehealthParticipantCountOrderByAggregateInput
    _max?: TelehealthParticipantMaxOrderByAggregateInput
    _min?: TelehealthParticipantMinOrderByAggregateInput
  }

  export type TelehealthParticipantScalarWhereWithAggregatesInput = {
    AND?: TelehealthParticipantScalarWhereWithAggregatesInput | TelehealthParticipantScalarWhereWithAggregatesInput[]
    OR?: TelehealthParticipantScalarWhereWithAggregatesInput[]
    NOT?: TelehealthParticipantScalarWhereWithAggregatesInput | TelehealthParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelehealthParticipant"> | string
    sessionId?: StringWithAggregatesFilter<"TelehealthParticipant"> | string
    userId?: StringWithAggregatesFilter<"TelehealthParticipant"> | string
    role?: StringWithAggregatesFilter<"TelehealthParticipant"> | string
    status?: StringWithAggregatesFilter<"TelehealthParticipant"> | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"TelehealthParticipant"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"TelehealthParticipant"> | Date | string | null
    connectionQuality?: StringNullableWithAggregatesFilter<"TelehealthParticipant"> | string | null
    cameraEnabled?: BoolWithAggregatesFilter<"TelehealthParticipant"> | boolean
    micEnabled?: BoolWithAggregatesFilter<"TelehealthParticipant"> | boolean
    screenSharing?: BoolWithAggregatesFilter<"TelehealthParticipant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TelehealthParticipant"> | Date | string
  }

  export type RecordingMetadataWhereInput = {
    AND?: RecordingMetadataWhereInput | RecordingMetadataWhereInput[]
    OR?: RecordingMetadataWhereInput[]
    NOT?: RecordingMetadataWhereInput | RecordingMetadataWhereInput[]
    id?: StringFilter<"RecordingMetadata"> | string
    sessionId?: StringFilter<"RecordingMetadata"> | string
    fileName?: StringFilter<"RecordingMetadata"> | string
    fileSize?: IntFilter<"RecordingMetadata"> | number
    duration?: IntFilter<"RecordingMetadata"> | number
    mimeType?: StringFilter<"RecordingMetadata"> | string
    downloadUrl?: StringNullableFilter<"RecordingMetadata"> | string | null
    createdAt?: DateTimeFilter<"RecordingMetadata"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
  }

  export type RecordingMetadataOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: TelehealthSessionOrderByWithRelationInput
  }

  export type RecordingMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecordingMetadataWhereInput | RecordingMetadataWhereInput[]
    OR?: RecordingMetadataWhereInput[]
    NOT?: RecordingMetadataWhereInput | RecordingMetadataWhereInput[]
    sessionId?: StringFilter<"RecordingMetadata"> | string
    fileName?: StringFilter<"RecordingMetadata"> | string
    fileSize?: IntFilter<"RecordingMetadata"> | number
    duration?: IntFilter<"RecordingMetadata"> | number
    mimeType?: StringFilter<"RecordingMetadata"> | string
    downloadUrl?: StringNullableFilter<"RecordingMetadata"> | string | null
    createdAt?: DateTimeFilter<"RecordingMetadata"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
  }, "id">

  export type RecordingMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RecordingMetadataCountOrderByAggregateInput
    _avg?: RecordingMetadataAvgOrderByAggregateInput
    _max?: RecordingMetadataMaxOrderByAggregateInput
    _min?: RecordingMetadataMinOrderByAggregateInput
    _sum?: RecordingMetadataSumOrderByAggregateInput
  }

  export type RecordingMetadataScalarWhereWithAggregatesInput = {
    AND?: RecordingMetadataScalarWhereWithAggregatesInput | RecordingMetadataScalarWhereWithAggregatesInput[]
    OR?: RecordingMetadataScalarWhereWithAggregatesInput[]
    NOT?: RecordingMetadataScalarWhereWithAggregatesInput | RecordingMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecordingMetadata"> | string
    sessionId?: StringWithAggregatesFilter<"RecordingMetadata"> | string
    fileName?: StringWithAggregatesFilter<"RecordingMetadata"> | string
    fileSize?: IntWithAggregatesFilter<"RecordingMetadata"> | number
    duration?: IntWithAggregatesFilter<"RecordingMetadata"> | number
    mimeType?: StringWithAggregatesFilter<"RecordingMetadata"> | string
    downloadUrl?: StringNullableWithAggregatesFilter<"RecordingMetadata"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecordingMetadata"> | Date | string
  }

  export type TranscriptWhereInput = {
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    id?: StringFilter<"Transcript"> | string
    sessionId?: StringFilter<"Transcript"> | string
    content?: StringFilter<"Transcript"> | string
    isEncrypted?: BoolFilter<"Transcript"> | boolean
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    updatedAt?: DateTimeFilter<"Transcript"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    isEncrypted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: TelehealthSessionOrderByWithRelationInput
  }

  export type TranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    sessionId?: StringFilter<"Transcript"> | string
    content?: StringFilter<"Transcript"> | string
    isEncrypted?: BoolFilter<"Transcript"> | boolean
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    updatedAt?: DateTimeFilter<"Transcript"> | Date | string
    session?: XOR<TelehealthSessionScalarRelationFilter, TelehealthSessionWhereInput>
  }, "id">

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    isEncrypted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    OR?: TranscriptScalarWhereWithAggregatesInput[]
    NOT?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transcript"> | string
    sessionId?: StringWithAggregatesFilter<"Transcript"> | string
    content?: StringWithAggregatesFilter<"Transcript"> | string
    isEncrypted?: BoolWithAggregatesFilter<"Transcript"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Transcript"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transcript"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringWithAggregatesFilter<"AuditLog"> | string
    userAgent?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteCreateInput = {
    id?: string
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSoapNotesInput
    therapist: UserCreateNestedOneWithoutCreatedNotesInput
    appointment?: AppointmentCreateNestedOneWithoutSoapNoteInput
  }

  export type SOAPNoteUncheckedCreateInput = {
    id?: string
    patientId: string
    therapistId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSoapNotesNestedInput
    therapist?: UserUpdateOneRequiredWithoutCreatedNotesNestedInput
    appointment?: AppointmentUpdateOneWithoutSoapNoteNestedInput
  }

  export type SOAPNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteCreateManyInput = {
    id?: string
    patientId: string
    therapistId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvoicesInput
    appointment?: AppointmentCreateNestedOneWithoutInvoiceInput
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    claim?: ClaimCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    claim?: ClaimUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    appointment?: AppointmentUpdateOneWithoutInvoiceNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type ClaimCreateInput = {
    id?: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date | string
    status?: $Enums.ClaimStatus
    amount: number
    approvedAmount?: number | null
    denialReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    invoiceId: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date | string
    status?: $Enums.ClaimStatus
    amount: number
    approvedAmount?: number | null
    denialReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateManyInput = {
    id?: string
    invoiceId: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date | string
    status?: $Enums.ClaimStatus
    amount: number
    approvedAmount?: number | null
    denialReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadCreateInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    messages?: MessageCreateNestedManyWithoutThreadInput
    participants?: MessageThreadParticipantCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
    participants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutThreadNestedInput
    participants?: MessageThreadParticipantUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
    participants?: MessageThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadCreateManyInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
  }

  export type MessageThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantCreateInput = {
    id?: string
    joinedAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutMessageThreadParticipantsInput
  }

  export type MessageThreadParticipantUncheckedCreateInput = {
    id?: string
    threadId: string
    userId: string
    joinedAt?: Date | string
  }

  export type MessageThreadParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageThreadParticipantsNestedInput
  }

  export type MessageThreadParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantCreateManyInput = {
    id?: string
    threadId: string
    userId: string
    joinedAt?: Date | string
  }

  export type MessageThreadParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    reader?: UserCreateNestedOneWithoutReadMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    threadId: string
    senderId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    reader?: UserUpdateOneWithoutReadMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    threadId: string
    senderId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    shares?: DocumentShareCreateNestedManyWithoutDocumentInput
    accessHistory?: DocumentAccessLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shares?: DocumentShareUncheckedCreateNestedManyWithoutDocumentInput
    accessHistory?: DocumentAccessLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    shares?: DocumentShareUpdateManyWithoutDocumentNestedInput
    accessHistory?: DocumentAccessLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: DocumentShareUncheckedUpdateManyWithoutDocumentNestedInput
    accessHistory?: DocumentAccessLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareCreateInput = {
    id?: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSharesInput
  }

  export type DocumentShareUncheckedCreateInput = {
    id?: string
    documentId: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
  }

  export type DocumentShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSharesNestedInput
  }

  export type DocumentShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareCreateManyInput = {
    id?: string
    documentId: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
  }

  export type DocumentShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAccessLogCreateInput = {
    id?: string
    accessedAt?: Date | string
    action: string
    document: DocumentCreateNestedOneWithoutAccessHistoryInput
  }

  export type DocumentAccessLogUncheckedCreateInput = {
    id?: string
    documentId: string
    accessedAt?: Date | string
    action: string
  }

  export type DocumentAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    document?: DocumentUpdateOneRequiredWithoutAccessHistoryNestedInput
  }

  export type DocumentAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAccessLogCreateManyInput = {
    id?: string
    documentId: string
    accessedAt?: Date | string
    action: string
  }

  export type DocumentAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type TelehealthSessionCreateInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSessionInput
    patient: PatientCreateNestedOneWithoutSessionsInput
    participants?: TelehealthParticipantCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSessionNestedInput
    patient?: PatientUpdateOneRequiredWithoutSessionsNestedInput
    participants?: TelehealthParticipantUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionCreateManyInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelehealthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantCreateInput = {
    id?: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
    session: TelehealthSessionCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutSessionParticipantsInput
  }

  export type TelehealthParticipantUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type TelehealthParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TelehealthSessionUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionParticipantsNestedInput
  }

  export type TelehealthParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type TelehealthParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
    session: TelehealthSessionCreateNestedOneWithoutRecordingsInput
  }

  export type RecordingMetadataUncheckedCreateInput = {
    id?: string
    sessionId: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
  }

  export type RecordingMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TelehealthSessionUpdateOneRequiredWithoutRecordingsNestedInput
  }

  export type RecordingMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataCreateManyInput = {
    id?: string
    sessionId: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
  }

  export type RecordingMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateInput = {
    id?: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TelehealthSessionCreateNestedOneWithoutTranscriptsInput
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    sessionId: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TelehealthSessionUpdateOneRequiredWithoutTranscriptsNestedInput
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateManyInput = {
    id?: string
    sessionId: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageThreadParticipantListRelationFilter = {
    every?: MessageThreadParticipantWhereInput
    some?: MessageThreadParticipantWhereInput
    none?: MessageThreadParticipantWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SOAPNoteListRelationFilter = {
    every?: SOAPNoteWhereInput
    some?: SOAPNoteWhereInput
    none?: SOAPNoteWhereInput
  }

  export type TelehealthParticipantListRelationFilter = {
    every?: TelehealthParticipantWhereInput
    some?: TelehealthParticipantWhereInput
    none?: TelehealthParticipantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageThreadParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SOAPNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelehealthParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mustChangePassword?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mustChangePassword?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mustChangePassword?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type TelehealthSessionListRelationFilter = {
    every?: TelehealthSessionWhereInput
    some?: TelehealthSessionWhereInput
    none?: TelehealthSessionWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelehealthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactRelationship?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactEmail?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicyNumber?: SortOrder
    insuranceGroupNumber?: SortOrder
    insuranceCopay?: SortOrder
    insuranceDeductible?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    assignedTherapistId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    insuranceCopay?: SortOrder
    insuranceDeductible?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactRelationship?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactEmail?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicyNumber?: SortOrder
    insuranceGroupNumber?: SortOrder
    insuranceCopay?: SortOrder
    insuranceDeductible?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    assignedTherapistId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactRelationship?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactEmail?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicyNumber?: SortOrder
    insuranceGroupNumber?: SortOrder
    insuranceCopay?: SortOrder
    insuranceDeductible?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    assignedTherapistId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    insuranceCopay?: SortOrder
    insuranceDeductible?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type SOAPNoteNullableScalarRelationFilter = {
    is?: SOAPNoteWhereInput | null
    isNot?: SOAPNoteWhereInput | null
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type TelehealthSessionNullableScalarRelationFilter = {
    is?: TelehealthSessionWhereInput | null
    isNot?: TelehealthSessionWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    createdById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    telehealthLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    createdById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    telehealthLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    createdById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    telehealthLink?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type SOAPNoteCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    appointmentId?: SortOrder
    date?: SortOrder
    subjective?: SortOrder
    objective?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SOAPNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    appointmentId?: SortOrder
    date?: SortOrder
    subjective?: SortOrder
    objective?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SOAPNoteMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    therapistId?: SortOrder
    appointmentId?: SortOrder
    date?: SortOrder
    subjective?: SortOrder
    objective?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type ClaimNullableScalarRelationFilter = {
    is?: ClaimWhereInput | null
    isNot?: ClaimWhereInput | null
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    cptCode?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    cptCode?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    cptCode?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    claimNumber?: SortOrder
    insuranceProvider?: SortOrder
    submissionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    approvedAmount?: SortOrder
    denialReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    amount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    claimNumber?: SortOrder
    insuranceProvider?: SortOrder
    submissionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    approvedAmount?: SortOrder
    denialReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    claimNumber?: SortOrder
    insuranceProvider?: SortOrder
    submissionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    approvedAmount?: SortOrder
    denialReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    amount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type MessageThreadCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    lastActivity?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    lastActivity?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    lastActivity?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadScalarRelationFilter = {
    is?: MessageThreadWhereInput
    isNot?: MessageThreadWhereInput
  }

  export type MessageThreadParticipantThreadIdUserIdCompoundUniqueInput = {
    threadId: string
    userId: string
  }

  export type MessageThreadParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageThreadParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageThreadParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    readerId?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isEncrypted?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    readerId?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isEncrypted?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    readerId?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isEncrypted?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DocumentShareListRelationFilter = {
    every?: DocumentShareWhereInput
    some?: DocumentShareWhereInput
    none?: DocumentShareWhereInput
  }

  export type DocumentAccessLogListRelationFilter = {
    every?: DocumentAccessLogWhereInput
    some?: DocumentAccessLogWhereInput
    none?: DocumentAccessLogWhereInput
  }

  export type DocumentShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isEncrypted?: SortOrder
    signature?: SortOrder
    signatureDate?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentShareCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    recipientEmail?: SortOrder
    shareType?: SortOrder
    expiresAt?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentShareMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    recipientEmail?: SortOrder
    shareType?: SortOrder
    expiresAt?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentShareMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    recipientEmail?: SortOrder
    shareType?: SortOrder
    expiresAt?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    accessedAt?: SortOrder
    action?: SortOrder
  }

  export type DocumentAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    accessedAt?: SortOrder
    action?: SortOrder
  }

  export type DocumentAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    accessedAt?: SortOrder
    action?: SortOrder
  }

  export type EnumTelehealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TelehealthStatus | EnumTelehealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelehealthStatusFilter<$PrismaModel> | $Enums.TelehealthStatus
  }

  export type RecordingMetadataListRelationFilter = {
    every?: RecordingMetadataWhereInput
    some?: RecordingMetadataWhereInput
    none?: RecordingMetadataWhereInput
  }

  export type TranscriptListRelationFilter = {
    every?: TranscriptWhereInput
    some?: TranscriptWhereInput
    none?: TranscriptWhereInput
  }

  export type RecordingMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelehealthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    roomId?: SortOrder
    sessionUrl?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    scheduledDuration?: SortOrder
    actualDuration?: SortOrder
    platform?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingSize?: SortOrder
    recordingDuration?: SortOrder
    chatEnabled?: SortOrder
    screenShareEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelehealthSessionAvgOrderByAggregateInput = {
    scheduledDuration?: SortOrder
    actualDuration?: SortOrder
    recordingSize?: SortOrder
    recordingDuration?: SortOrder
  }

  export type TelehealthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    roomId?: SortOrder
    sessionUrl?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    scheduledDuration?: SortOrder
    actualDuration?: SortOrder
    platform?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingSize?: SortOrder
    recordingDuration?: SortOrder
    chatEnabled?: SortOrder
    screenShareEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelehealthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    roomId?: SortOrder
    sessionUrl?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    scheduledDuration?: SortOrder
    actualDuration?: SortOrder
    platform?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingSize?: SortOrder
    recordingDuration?: SortOrder
    chatEnabled?: SortOrder
    screenShareEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelehealthSessionSumOrderByAggregateInput = {
    scheduledDuration?: SortOrder
    actualDuration?: SortOrder
    recordingSize?: SortOrder
    recordingDuration?: SortOrder
  }

  export type EnumTelehealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TelehealthStatus | EnumTelehealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelehealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.TelehealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTelehealthStatusFilter<$PrismaModel>
    _max?: NestedEnumTelehealthStatusFilter<$PrismaModel>
  }

  export type TelehealthSessionScalarRelationFilter = {
    is?: TelehealthSessionWhereInput
    isNot?: TelehealthSessionWhereInput
  }

  export type TelehealthParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    connectionQuality?: SortOrder
    cameraEnabled?: SortOrder
    micEnabled?: SortOrder
    screenSharing?: SortOrder
    createdAt?: SortOrder
  }

  export type TelehealthParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    connectionQuality?: SortOrder
    cameraEnabled?: SortOrder
    micEnabled?: SortOrder
    screenSharing?: SortOrder
    createdAt?: SortOrder
  }

  export type TelehealthParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    connectionQuality?: SortOrder
    cameraEnabled?: SortOrder
    micEnabled?: SortOrder
    screenSharing?: SortOrder
    createdAt?: SortOrder
  }

  export type RecordingMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecordingMetadataAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type RecordingMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecordingMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecordingMetadataSumOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    isEncrypted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    isEncrypted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    isEncrypted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PatientCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientCreateNestedManyWithoutAssignedTherapistInput = {
    create?: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput> | PatientCreateWithoutAssignedTherapistInput[] | PatientUncheckedCreateWithoutAssignedTherapistInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAssignedTherapistInput | PatientCreateOrConnectWithoutAssignedTherapistInput[]
    createMany?: PatientCreateManyAssignedTherapistInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput> | AppointmentCreateWithoutTherapistInput[] | AppointmentUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTherapistInput | AppointmentCreateOrConnectWithoutTherapistInput[]
    createMany?: AppointmentCreateManyTherapistInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReaderInput = {
    create?: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput> | MessageCreateWithoutReaderInput[] | MessageUncheckedCreateWithoutReaderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReaderInput | MessageCreateOrConnectWithoutReaderInput[]
    createMany?: MessageCreateManyReaderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageThreadParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput> | MessageThreadParticipantCreateWithoutUserInput[] | MessageThreadParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutUserInput | MessageThreadParticipantCreateOrConnectWithoutUserInput[]
    createMany?: MessageThreadParticipantCreateManyUserInputEnvelope
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SOAPNoteCreateNestedManyWithoutTherapistInput = {
    create?: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput> | SOAPNoteCreateWithoutTherapistInput[] | SOAPNoteUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutTherapistInput | SOAPNoteCreateOrConnectWithoutTherapistInput[]
    createMany?: SOAPNoteCreateManyTherapistInputEnvelope
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
  }

  export type TelehealthParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput> | TelehealthParticipantCreateWithoutUserInput[] | TelehealthParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutUserInput | TelehealthParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TelehealthParticipantCreateManyUserInputEnvelope
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput = {
    create?: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput> | PatientCreateWithoutAssignedTherapistInput[] | PatientUncheckedCreateWithoutAssignedTherapistInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAssignedTherapistInput | PatientCreateOrConnectWithoutAssignedTherapistInput[]
    createMany?: PatientCreateManyAssignedTherapistInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput> | AppointmentCreateWithoutTherapistInput[] | AppointmentUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTherapistInput | AppointmentCreateOrConnectWithoutTherapistInput[]
    createMany?: AppointmentCreateManyTherapistInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReaderInput = {
    create?: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput> | MessageCreateWithoutReaderInput[] | MessageUncheckedCreateWithoutReaderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReaderInput | MessageCreateOrConnectWithoutReaderInput[]
    createMany?: MessageCreateManyReaderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput> | MessageThreadParticipantCreateWithoutUserInput[] | MessageThreadParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutUserInput | MessageThreadParticipantCreateOrConnectWithoutUserInput[]
    createMany?: MessageThreadParticipantCreateManyUserInputEnvelope
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput = {
    create?: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput> | SOAPNoteCreateWithoutTherapistInput[] | SOAPNoteUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutTherapistInput | SOAPNoteCreateOrConnectWithoutTherapistInput[]
    createMany?: SOAPNoteCreateManyTherapistInputEnvelope
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
  }

  export type TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput> | TelehealthParticipantCreateWithoutUserInput[] | TelehealthParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutUserInput | TelehealthParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TelehealthParticipantCreateManyUserInputEnvelope
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PatientUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateManyWithoutAssignedTherapistNestedInput = {
    create?: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput> | PatientCreateWithoutAssignedTherapistInput[] | PatientUncheckedCreateWithoutAssignedTherapistInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAssignedTherapistInput | PatientCreateOrConnectWithoutAssignedTherapistInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutAssignedTherapistInput | PatientUpsertWithWhereUniqueWithoutAssignedTherapistInput[]
    createMany?: PatientCreateManyAssignedTherapistInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutAssignedTherapistInput | PatientUpdateWithWhereUniqueWithoutAssignedTherapistInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutAssignedTherapistInput | PatientUpdateManyWithWhereWithoutAssignedTherapistInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput> | AppointmentCreateWithoutTherapistInput[] | AppointmentUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTherapistInput | AppointmentCreateOrConnectWithoutTherapistInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTherapistInput | AppointmentUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AppointmentCreateManyTherapistInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTherapistInput | AppointmentUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTherapistInput | AppointmentUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCreatedByInput | AppointmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCreatedByInput | AppointmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCreatedByInput | AppointmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReaderNestedInput = {
    create?: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput> | MessageCreateWithoutReaderInput[] | MessageUncheckedCreateWithoutReaderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReaderInput | MessageCreateOrConnectWithoutReaderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReaderInput | MessageUpsertWithWhereUniqueWithoutReaderInput[]
    createMany?: MessageCreateManyReaderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReaderInput | MessageUpdateWithWhereUniqueWithoutReaderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReaderInput | MessageUpdateManyWithWhereWithoutReaderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput> | MessageThreadParticipantCreateWithoutUserInput[] | MessageThreadParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutUserInput | MessageThreadParticipantCreateOrConnectWithoutUserInput[]
    upsert?: MessageThreadParticipantUpsertWithWhereUniqueWithoutUserInput | MessageThreadParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageThreadParticipantCreateManyUserInputEnvelope
    set?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    disconnect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    delete?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    update?: MessageThreadParticipantUpdateWithWhereUniqueWithoutUserInput | MessageThreadParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageThreadParticipantUpdateManyWithWhereWithoutUserInput | MessageThreadParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SOAPNoteUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput> | SOAPNoteCreateWithoutTherapistInput[] | SOAPNoteUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutTherapistInput | SOAPNoteCreateOrConnectWithoutTherapistInput[]
    upsert?: SOAPNoteUpsertWithWhereUniqueWithoutTherapistInput | SOAPNoteUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: SOAPNoteCreateManyTherapistInputEnvelope
    set?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    disconnect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    delete?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    update?: SOAPNoteUpdateWithWhereUniqueWithoutTherapistInput | SOAPNoteUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: SOAPNoteUpdateManyWithWhereWithoutTherapistInput | SOAPNoteUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
  }

  export type TelehealthParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput> | TelehealthParticipantCreateWithoutUserInput[] | TelehealthParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutUserInput | TelehealthParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TelehealthParticipantUpsertWithWhereUniqueWithoutUserInput | TelehealthParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelehealthParticipantCreateManyUserInputEnvelope
    set?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    disconnect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    delete?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    update?: TelehealthParticipantUpdateWithWhereUniqueWithoutUserInput | TelehealthParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelehealthParticipantUpdateManyWithWhereWithoutUserInput | TelehealthParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PatientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput = {
    create?: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput> | PatientCreateWithoutAssignedTherapistInput[] | PatientUncheckedCreateWithoutAssignedTherapistInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAssignedTherapistInput | PatientCreateOrConnectWithoutAssignedTherapistInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutAssignedTherapistInput | PatientUpsertWithWhereUniqueWithoutAssignedTherapistInput[]
    createMany?: PatientCreateManyAssignedTherapistInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutAssignedTherapistInput | PatientUpdateWithWhereUniqueWithoutAssignedTherapistInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutAssignedTherapistInput | PatientUpdateManyWithWhereWithoutAssignedTherapistInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput> | AppointmentCreateWithoutTherapistInput[] | AppointmentUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTherapistInput | AppointmentCreateOrConnectWithoutTherapistInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTherapistInput | AppointmentUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AppointmentCreateManyTherapistInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTherapistInput | AppointmentUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTherapistInput | AppointmentUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCreatedByInput | AppointmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCreatedByInput | AppointmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCreatedByInput | AppointmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReaderNestedInput = {
    create?: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput> | MessageCreateWithoutReaderInput[] | MessageUncheckedCreateWithoutReaderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReaderInput | MessageCreateOrConnectWithoutReaderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReaderInput | MessageUpsertWithWhereUniqueWithoutReaderInput[]
    createMany?: MessageCreateManyReaderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReaderInput | MessageUpdateWithWhereUniqueWithoutReaderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReaderInput | MessageUpdateManyWithWhereWithoutReaderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput> | MessageThreadParticipantCreateWithoutUserInput[] | MessageThreadParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutUserInput | MessageThreadParticipantCreateOrConnectWithoutUserInput[]
    upsert?: MessageThreadParticipantUpsertWithWhereUniqueWithoutUserInput | MessageThreadParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageThreadParticipantCreateManyUserInputEnvelope
    set?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    disconnect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    delete?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    update?: MessageThreadParticipantUpdateWithWhereUniqueWithoutUserInput | MessageThreadParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageThreadParticipantUpdateManyWithWhereWithoutUserInput | MessageThreadParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput> | SOAPNoteCreateWithoutTherapistInput[] | SOAPNoteUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutTherapistInput | SOAPNoteCreateOrConnectWithoutTherapistInput[]
    upsert?: SOAPNoteUpsertWithWhereUniqueWithoutTherapistInput | SOAPNoteUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: SOAPNoteCreateManyTherapistInputEnvelope
    set?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    disconnect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    delete?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    update?: SOAPNoteUpdateWithWhereUniqueWithoutTherapistInput | SOAPNoteUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: SOAPNoteUpdateManyWithWhereWithoutTherapistInput | SOAPNoteUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
  }

  export type TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput> | TelehealthParticipantCreateWithoutUserInput[] | TelehealthParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutUserInput | TelehealthParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TelehealthParticipantUpsertWithWhereUniqueWithoutUserInput | TelehealthParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelehealthParticipantCreateManyUserInputEnvelope
    set?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    disconnect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    delete?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    update?: TelehealthParticipantUpdateWithWhereUniqueWithoutUserInput | TelehealthParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelehealthParticipantUpdateManyWithWhereWithoutUserInput | TelehealthParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutPatientProfileInput = {
    create?: XOR<UserCreateWithoutPatientProfileInput, UserUncheckedCreateWithoutPatientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedPatientsInput = {
    create?: XOR<UserCreateWithoutAssignedPatientsInput, UserUncheckedCreateWithoutAssignedPatientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedPatientsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SOAPNoteCreateNestedManyWithoutPatientInput = {
    create?: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput> | SOAPNoteCreateWithoutPatientInput[] | SOAPNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutPatientInput | SOAPNoteCreateOrConnectWithoutPatientInput[]
    createMany?: SOAPNoteCreateManyPatientInputEnvelope
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput> | DocumentCreateWithoutPatientInput[] | DocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPatientInput | DocumentCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentCreateManyPatientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type TelehealthSessionCreateNestedManyWithoutPatientInput = {
    create?: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput> | TelehealthSessionCreateWithoutPatientInput[] | TelehealthSessionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutPatientInput | TelehealthSessionCreateOrConnectWithoutPatientInput[]
    createMany?: TelehealthSessionCreateManyPatientInputEnvelope
    connect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SOAPNoteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput> | SOAPNoteCreateWithoutPatientInput[] | SOAPNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutPatientInput | SOAPNoteCreateOrConnectWithoutPatientInput[]
    createMany?: SOAPNoteCreateManyPatientInputEnvelope
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput> | DocumentCreateWithoutPatientInput[] | DocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPatientInput | DocumentCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentCreateManyPatientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput> | TelehealthSessionCreateWithoutPatientInput[] | TelehealthSessionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutPatientInput | TelehealthSessionCreateOrConnectWithoutPatientInput[]
    createMany?: TelehealthSessionCreateManyPatientInputEnvelope
    connect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPatientProfileNestedInput = {
    create?: XOR<UserCreateWithoutPatientProfileInput, UserUncheckedCreateWithoutPatientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientProfileInput
    upsert?: UserUpsertWithoutPatientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientProfileInput, UserUpdateWithoutPatientProfileInput>, UserUncheckedUpdateWithoutPatientProfileInput>
  }

  export type UserUpdateOneWithoutAssignedPatientsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedPatientsInput, UserUncheckedCreateWithoutAssignedPatientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedPatientsInput
    upsert?: UserUpsertWithoutAssignedPatientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedPatientsInput, UserUpdateWithoutAssignedPatientsInput>, UserUncheckedUpdateWithoutAssignedPatientsInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SOAPNoteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput> | SOAPNoteCreateWithoutPatientInput[] | SOAPNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutPatientInput | SOAPNoteCreateOrConnectWithoutPatientInput[]
    upsert?: SOAPNoteUpsertWithWhereUniqueWithoutPatientInput | SOAPNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SOAPNoteCreateManyPatientInputEnvelope
    set?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    disconnect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    delete?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    update?: SOAPNoteUpdateWithWhereUniqueWithoutPatientInput | SOAPNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SOAPNoteUpdateManyWithWhereWithoutPatientInput | SOAPNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput> | DocumentCreateWithoutPatientInput[] | DocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPatientInput | DocumentCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPatientInput | DocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentCreateManyPatientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPatientInput | DocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPatientInput | DocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TelehealthSessionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput> | TelehealthSessionCreateWithoutPatientInput[] | TelehealthSessionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutPatientInput | TelehealthSessionCreateOrConnectWithoutPatientInput[]
    upsert?: TelehealthSessionUpsertWithWhereUniqueWithoutPatientInput | TelehealthSessionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TelehealthSessionCreateManyPatientInputEnvelope
    set?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    disconnect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    delete?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    connect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    update?: TelehealthSessionUpdateWithWhereUniqueWithoutPatientInput | TelehealthSessionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TelehealthSessionUpdateManyWithWhereWithoutPatientInput | TelehealthSessionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TelehealthSessionScalarWhereInput | TelehealthSessionScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput> | SOAPNoteCreateWithoutPatientInput[] | SOAPNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutPatientInput | SOAPNoteCreateOrConnectWithoutPatientInput[]
    upsert?: SOAPNoteUpsertWithWhereUniqueWithoutPatientInput | SOAPNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SOAPNoteCreateManyPatientInputEnvelope
    set?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    disconnect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    delete?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    connect?: SOAPNoteWhereUniqueInput | SOAPNoteWhereUniqueInput[]
    update?: SOAPNoteUpdateWithWhereUniqueWithoutPatientInput | SOAPNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SOAPNoteUpdateManyWithWhereWithoutPatientInput | SOAPNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput> | DocumentCreateWithoutPatientInput[] | DocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPatientInput | DocumentCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPatientInput | DocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentCreateManyPatientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPatientInput | DocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPatientInput | DocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput> | TelehealthSessionCreateWithoutPatientInput[] | TelehealthSessionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutPatientInput | TelehealthSessionCreateOrConnectWithoutPatientInput[]
    upsert?: TelehealthSessionUpsertWithWhereUniqueWithoutPatientInput | TelehealthSessionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TelehealthSessionCreateManyPatientInputEnvelope
    set?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    disconnect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    delete?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    connect?: TelehealthSessionWhereUniqueInput | TelehealthSessionWhereUniqueInput[]
    update?: TelehealthSessionUpdateWithWhereUniqueWithoutPatientInput | TelehealthSessionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TelehealthSessionUpdateManyWithWhereWithoutPatientInput | TelehealthSessionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TelehealthSessionScalarWhereInput | TelehealthSessionScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedAppointmentsInput = {
    create?: XOR<UserCreateWithoutCreatedAppointmentsInput, UserUncheckedCreateWithoutCreatedAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type SOAPNoteCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutAppointmentInput
    connect?: SOAPNoteWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAppointmentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TelehealthSessionCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutAppointmentInput
    connect?: TelehealthSessionWhereUniqueInput
  }

  export type SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutAppointmentInput
    connect?: SOAPNoteWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAppointmentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutAppointmentInput
    connect?: TelehealthSessionWhereUniqueInput
  }

  export type EnumAppointmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAppointmentsInput, UserUncheckedCreateWithoutCreatedAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAppointmentsInput
    upsert?: UserUpsertWithoutCreatedAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAppointmentsInput, UserUpdateWithoutCreatedAppointmentsInput>, UserUncheckedUpdateWithoutCreatedAppointmentsInput>
  }

  export type SOAPNoteUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutAppointmentInput
    upsert?: SOAPNoteUpsertWithoutAppointmentInput
    disconnect?: SOAPNoteWhereInput | boolean
    delete?: SOAPNoteWhereInput | boolean
    connect?: SOAPNoteWhereUniqueInput
    update?: XOR<XOR<SOAPNoteUpdateToOneWithWhereWithoutAppointmentInput, SOAPNoteUpdateWithoutAppointmentInput>, SOAPNoteUncheckedUpdateWithoutAppointmentInput>
  }

  export type InvoiceUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAppointmentInput
    upsert?: InvoiceUpsertWithoutAppointmentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutAppointmentInput, InvoiceUpdateWithoutAppointmentInput>, InvoiceUncheckedUpdateWithoutAppointmentInput>
  }

  export type TelehealthSessionUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutAppointmentInput
    upsert?: TelehealthSessionUpsertWithoutAppointmentInput
    disconnect?: TelehealthSessionWhereInput | boolean
    delete?: TelehealthSessionWhereInput | boolean
    connect?: TelehealthSessionWhereUniqueInput
    update?: XOR<XOR<TelehealthSessionUpdateToOneWithWhereWithoutAppointmentInput, TelehealthSessionUpdateWithoutAppointmentInput>, TelehealthSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SOAPNoteCreateOrConnectWithoutAppointmentInput
    upsert?: SOAPNoteUpsertWithoutAppointmentInput
    disconnect?: SOAPNoteWhereInput | boolean
    delete?: SOAPNoteWhereInput | boolean
    connect?: SOAPNoteWhereUniqueInput
    update?: XOR<XOR<SOAPNoteUpdateToOneWithWhereWithoutAppointmentInput, SOAPNoteUpdateWithoutAppointmentInput>, SOAPNoteUncheckedUpdateWithoutAppointmentInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAppointmentInput
    upsert?: InvoiceUpsertWithoutAppointmentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutAppointmentInput, InvoiceUpdateWithoutAppointmentInput>, InvoiceUncheckedUpdateWithoutAppointmentInput>
  }

  export type TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutAppointmentInput
    upsert?: TelehealthSessionUpsertWithoutAppointmentInput
    disconnect?: TelehealthSessionWhereInput | boolean
    delete?: TelehealthSessionWhereInput | boolean
    connect?: TelehealthSessionWhereUniqueInput
    update?: XOR<XOR<TelehealthSessionUpdateToOneWithWhereWithoutAppointmentInput, TelehealthSessionUpdateWithoutAppointmentInput>, TelehealthSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type PatientCreateNestedOneWithoutSoapNotesInput = {
    create?: XOR<PatientCreateWithoutSoapNotesInput, PatientUncheckedCreateWithoutSoapNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSoapNotesInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedNotesInput = {
    create?: XOR<UserCreateWithoutCreatedNotesInput, UserUncheckedCreateWithoutCreatedNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedNotesInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutSoapNoteInput = {
    create?: XOR<AppointmentCreateWithoutSoapNoteInput, AppointmentUncheckedCreateWithoutSoapNoteInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSoapNoteInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutSoapNotesNestedInput = {
    create?: XOR<PatientCreateWithoutSoapNotesInput, PatientUncheckedCreateWithoutSoapNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSoapNotesInput
    upsert?: PatientUpsertWithoutSoapNotesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutSoapNotesInput, PatientUpdateWithoutSoapNotesInput>, PatientUncheckedUpdateWithoutSoapNotesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedNotesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedNotesInput, UserUncheckedCreateWithoutCreatedNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedNotesInput
    upsert?: UserUpsertWithoutCreatedNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedNotesInput, UserUpdateWithoutCreatedNotesInput>, UserUncheckedUpdateWithoutCreatedNotesInput>
  }

  export type AppointmentUpdateOneWithoutSoapNoteNestedInput = {
    create?: XOR<AppointmentCreateWithoutSoapNoteInput, AppointmentUncheckedCreateWithoutSoapNoteInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSoapNoteInput
    upsert?: AppointmentUpsertWithoutSoapNoteInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutSoapNoteInput, AppointmentUpdateWithoutSoapNoteInput>, AppointmentUncheckedUpdateWithoutSoapNoteInput>
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<AppointmentCreateWithoutInvoiceInput, AppointmentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutInvoiceInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedInvoicesInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ClaimCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutInvoiceInput
    connect?: ClaimWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutInvoiceInput
    connect?: ClaimWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type PatientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type AppointmentUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutInvoiceInput, AppointmentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutInvoiceInput
    upsert?: AppointmentUpsertWithoutInvoiceInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutInvoiceInput, AppointmentUpdateWithoutInvoiceInput>, AppointmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    upsert?: UserUpsertWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInvoicesInput, UserUpdateWithoutCreatedInvoicesInput>, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ClaimUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutInvoiceInput
    upsert?: ClaimUpsertWithoutInvoiceInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutInvoiceInput, ClaimUpdateWithoutInvoiceInput>, ClaimUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutInvoiceInput
    upsert?: ClaimUpsertWithoutInvoiceInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutInvoiceInput, ClaimUpdateWithoutInvoiceInput>, ClaimUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutClaimInput = {
    create?: XOR<InvoiceCreateWithoutClaimInput, InvoiceUncheckedCreateWithoutClaimInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClaimInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type InvoiceUpdateOneRequiredWithoutClaimNestedInput = {
    create?: XOR<InvoiceCreateWithoutClaimInput, InvoiceUncheckedCreateWithoutClaimInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClaimInput
    upsert?: InvoiceUpsertWithoutClaimInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutClaimInput, InvoiceUpdateWithoutClaimInput>, InvoiceUncheckedUpdateWithoutClaimInput>
  }

  export type MessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageThreadParticipantCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput> | MessageThreadParticipantCreateWithoutThreadInput[] | MessageThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutThreadInput | MessageThreadParticipantCreateOrConnectWithoutThreadInput[]
    createMany?: MessageThreadParticipantCreateManyThreadInputEnvelope
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageThreadParticipantUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput> | MessageThreadParticipantCreateWithoutThreadInput[] | MessageThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutThreadInput | MessageThreadParticipantCreateOrConnectWithoutThreadInput[]
    createMany?: MessageThreadParticipantCreateManyThreadInputEnvelope
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadParticipantUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput> | MessageThreadParticipantCreateWithoutThreadInput[] | MessageThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutThreadInput | MessageThreadParticipantCreateOrConnectWithoutThreadInput[]
    upsert?: MessageThreadParticipantUpsertWithWhereUniqueWithoutThreadInput | MessageThreadParticipantUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageThreadParticipantCreateManyThreadInputEnvelope
    set?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    disconnect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    delete?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    update?: MessageThreadParticipantUpdateWithWhereUniqueWithoutThreadInput | MessageThreadParticipantUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageThreadParticipantUpdateManyWithWhereWithoutThreadInput | MessageThreadParticipantUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput> | MessageThreadParticipantCreateWithoutThreadInput[] | MessageThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageThreadParticipantCreateOrConnectWithoutThreadInput | MessageThreadParticipantCreateOrConnectWithoutThreadInput[]
    upsert?: MessageThreadParticipantUpsertWithWhereUniqueWithoutThreadInput | MessageThreadParticipantUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageThreadParticipantCreateManyThreadInputEnvelope
    set?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    disconnect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    delete?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    connect?: MessageThreadParticipantWhereUniqueInput | MessageThreadParticipantWhereUniqueInput[]
    update?: MessageThreadParticipantUpdateWithWhereUniqueWithoutThreadInput | MessageThreadParticipantUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageThreadParticipantUpdateManyWithWhereWithoutThreadInput | MessageThreadParticipantUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
  }

  export type MessageThreadCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutParticipantsInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageThreadParticipantsInput = {
    create?: XOR<UserCreateWithoutMessageThreadParticipantsInput, UserUncheckedCreateWithoutMessageThreadParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageThreadParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutParticipantsInput
    upsert?: MessageThreadUpsertWithoutParticipantsInput
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutParticipantsInput, MessageThreadUpdateWithoutParticipantsInput>, MessageThreadUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageThreadParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutMessageThreadParticipantsInput, UserUncheckedCreateWithoutMessageThreadParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageThreadParticipantsInput
    upsert?: UserUpsertWithoutMessageThreadParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageThreadParticipantsInput, UserUpdateWithoutMessageThreadParticipantsInput>, UserUncheckedUpdateWithoutMessageThreadParticipantsInput>
  }

  export type MessageThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReadMessagesInput = {
    create?: XOR<UserCreateWithoutReadMessagesInput, UserUncheckedCreateWithoutReadMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageThreadUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    upsert?: MessageThreadUpsertWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutMessagesInput, MessageThreadUpdateWithoutMessagesInput>, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneWithoutReadMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReadMessagesInput, UserUncheckedCreateWithoutReadMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadMessagesInput
    upsert?: UserUpsertWithoutReadMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReadMessagesInput, UserUpdateWithoutReadMessagesInput>, UserUncheckedUpdateWithoutReadMessagesInput>
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type DocumentCreatetagsInput = {
    set: string[]
  }

  export type PatientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsInput
    connect?: PatientWhereUniqueInput
  }

  export type DocumentShareCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput> | DocumentShareCreateWithoutDocumentInput[] | DocumentShareUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentShareCreateOrConnectWithoutDocumentInput | DocumentShareCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentShareCreateManyDocumentInputEnvelope
    connect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
  }

  export type DocumentAccessLogCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput> | DocumentAccessLogCreateWithoutDocumentInput[] | DocumentAccessLogUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAccessLogCreateOrConnectWithoutDocumentInput | DocumentAccessLogCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAccessLogCreateManyDocumentInputEnvelope
    connect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
  }

  export type DocumentShareUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput> | DocumentShareCreateWithoutDocumentInput[] | DocumentShareUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentShareCreateOrConnectWithoutDocumentInput | DocumentShareCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentShareCreateManyDocumentInputEnvelope
    connect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
  }

  export type DocumentAccessLogUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput> | DocumentAccessLogCreateWithoutDocumentInput[] | DocumentAccessLogUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAccessLogCreateOrConnectWithoutDocumentInput | DocumentAccessLogCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAccessLogCreateManyDocumentInputEnvelope
    connect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
  }

  export type EnumDocumentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DocumentCategory
  }

  export type DocumentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsInput
    upsert?: PatientUpsertWithoutDocumentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDocumentsInput, PatientUpdateWithoutDocumentsInput>, PatientUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentShareUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput> | DocumentShareCreateWithoutDocumentInput[] | DocumentShareUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentShareCreateOrConnectWithoutDocumentInput | DocumentShareCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentShareUpsertWithWhereUniqueWithoutDocumentInput | DocumentShareUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentShareCreateManyDocumentInputEnvelope
    set?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    disconnect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    delete?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    connect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    update?: DocumentShareUpdateWithWhereUniqueWithoutDocumentInput | DocumentShareUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentShareUpdateManyWithWhereWithoutDocumentInput | DocumentShareUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentShareScalarWhereInput | DocumentShareScalarWhereInput[]
  }

  export type DocumentAccessLogUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput> | DocumentAccessLogCreateWithoutDocumentInput[] | DocumentAccessLogUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAccessLogCreateOrConnectWithoutDocumentInput | DocumentAccessLogCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAccessLogUpsertWithWhereUniqueWithoutDocumentInput | DocumentAccessLogUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAccessLogCreateManyDocumentInputEnvelope
    set?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    disconnect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    delete?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    connect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    update?: DocumentAccessLogUpdateWithWhereUniqueWithoutDocumentInput | DocumentAccessLogUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAccessLogUpdateManyWithWhereWithoutDocumentInput | DocumentAccessLogUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAccessLogScalarWhereInput | DocumentAccessLogScalarWhereInput[]
  }

  export type DocumentShareUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput> | DocumentShareCreateWithoutDocumentInput[] | DocumentShareUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentShareCreateOrConnectWithoutDocumentInput | DocumentShareCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentShareUpsertWithWhereUniqueWithoutDocumentInput | DocumentShareUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentShareCreateManyDocumentInputEnvelope
    set?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    disconnect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    delete?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    connect?: DocumentShareWhereUniqueInput | DocumentShareWhereUniqueInput[]
    update?: DocumentShareUpdateWithWhereUniqueWithoutDocumentInput | DocumentShareUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentShareUpdateManyWithWhereWithoutDocumentInput | DocumentShareUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentShareScalarWhereInput | DocumentShareScalarWhereInput[]
  }

  export type DocumentAccessLogUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput> | DocumentAccessLogCreateWithoutDocumentInput[] | DocumentAccessLogUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAccessLogCreateOrConnectWithoutDocumentInput | DocumentAccessLogCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAccessLogUpsertWithWhereUniqueWithoutDocumentInput | DocumentAccessLogUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAccessLogCreateManyDocumentInputEnvelope
    set?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    disconnect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    delete?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    connect?: DocumentAccessLogWhereUniqueInput | DocumentAccessLogWhereUniqueInput[]
    update?: DocumentAccessLogUpdateWithWhereUniqueWithoutDocumentInput | DocumentAccessLogUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAccessLogUpdateManyWithWhereWithoutDocumentInput | DocumentAccessLogUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAccessLogScalarWhereInput | DocumentAccessLogScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutSharesInput = {
    create?: XOR<DocumentCreateWithoutSharesInput, DocumentUncheckedCreateWithoutSharesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSharesInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<DocumentCreateWithoutSharesInput, DocumentUncheckedCreateWithoutSharesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSharesInput
    upsert?: DocumentUpsertWithoutSharesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSharesInput, DocumentUpdateWithoutSharesInput>, DocumentUncheckedUpdateWithoutSharesInput>
  }

  export type DocumentCreateNestedOneWithoutAccessHistoryInput = {
    create?: XOR<DocumentCreateWithoutAccessHistoryInput, DocumentUncheckedCreateWithoutAccessHistoryInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAccessHistoryInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutAccessHistoryNestedInput = {
    create?: XOR<DocumentCreateWithoutAccessHistoryInput, DocumentUncheckedCreateWithoutAccessHistoryInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAccessHistoryInput
    upsert?: DocumentUpsertWithoutAccessHistoryInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutAccessHistoryInput, DocumentUpdateWithoutAccessHistoryInput>, DocumentUncheckedUpdateWithoutAccessHistoryInput>
  }

  export type AppointmentCreateNestedOneWithoutSessionInput = {
    create?: XOR<AppointmentCreateWithoutSessionInput, AppointmentUncheckedCreateWithoutSessionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSessionInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutSessionsInput = {
    create?: XOR<PatientCreateWithoutSessionsInput, PatientUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSessionsInput
    connect?: PatientWhereUniqueInput
  }

  export type TelehealthParticipantCreateNestedManyWithoutSessionInput = {
    create?: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput> | TelehealthParticipantCreateWithoutSessionInput[] | TelehealthParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutSessionInput | TelehealthParticipantCreateOrConnectWithoutSessionInput[]
    createMany?: TelehealthParticipantCreateManySessionInputEnvelope
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
  }

  export type RecordingMetadataCreateNestedManyWithoutSessionInput = {
    create?: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput> | RecordingMetadataCreateWithoutSessionInput[] | RecordingMetadataUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RecordingMetadataCreateOrConnectWithoutSessionInput | RecordingMetadataCreateOrConnectWithoutSessionInput[]
    createMany?: RecordingMetadataCreateManySessionInputEnvelope
    connect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
  }

  export type TranscriptCreateNestedManyWithoutSessionInput = {
    create?: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput> | TranscriptCreateWithoutSessionInput[] | TranscriptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutSessionInput | TranscriptCreateOrConnectWithoutSessionInput[]
    createMany?: TranscriptCreateManySessionInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput> | TelehealthParticipantCreateWithoutSessionInput[] | TelehealthParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutSessionInput | TelehealthParticipantCreateOrConnectWithoutSessionInput[]
    createMany?: TelehealthParticipantCreateManySessionInputEnvelope
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
  }

  export type RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput> | RecordingMetadataCreateWithoutSessionInput[] | RecordingMetadataUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RecordingMetadataCreateOrConnectWithoutSessionInput | RecordingMetadataCreateOrConnectWithoutSessionInput[]
    createMany?: RecordingMetadataCreateManySessionInputEnvelope
    connect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput> | TranscriptCreateWithoutSessionInput[] | TranscriptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutSessionInput | TranscriptCreateOrConnectWithoutSessionInput[]
    createMany?: TranscriptCreateManySessionInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type EnumTelehealthStatusFieldUpdateOperationsInput = {
    set?: $Enums.TelehealthStatus
  }

  export type AppointmentUpdateOneWithoutSessionNestedInput = {
    create?: XOR<AppointmentCreateWithoutSessionInput, AppointmentUncheckedCreateWithoutSessionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSessionInput
    upsert?: AppointmentUpsertWithoutSessionInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutSessionInput, AppointmentUpdateWithoutSessionInput>, AppointmentUncheckedUpdateWithoutSessionInput>
  }

  export type PatientUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<PatientCreateWithoutSessionsInput, PatientUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSessionsInput
    upsert?: PatientUpsertWithoutSessionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutSessionsInput, PatientUpdateWithoutSessionsInput>, PatientUncheckedUpdateWithoutSessionsInput>
  }

  export type TelehealthParticipantUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput> | TelehealthParticipantCreateWithoutSessionInput[] | TelehealthParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutSessionInput | TelehealthParticipantCreateOrConnectWithoutSessionInput[]
    upsert?: TelehealthParticipantUpsertWithWhereUniqueWithoutSessionInput | TelehealthParticipantUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TelehealthParticipantCreateManySessionInputEnvelope
    set?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    disconnect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    delete?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    update?: TelehealthParticipantUpdateWithWhereUniqueWithoutSessionInput | TelehealthParticipantUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TelehealthParticipantUpdateManyWithWhereWithoutSessionInput | TelehealthParticipantUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
  }

  export type RecordingMetadataUpdateManyWithoutSessionNestedInput = {
    create?: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput> | RecordingMetadataCreateWithoutSessionInput[] | RecordingMetadataUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RecordingMetadataCreateOrConnectWithoutSessionInput | RecordingMetadataCreateOrConnectWithoutSessionInput[]
    upsert?: RecordingMetadataUpsertWithWhereUniqueWithoutSessionInput | RecordingMetadataUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: RecordingMetadataCreateManySessionInputEnvelope
    set?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    disconnect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    delete?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    connect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    update?: RecordingMetadataUpdateWithWhereUniqueWithoutSessionInput | RecordingMetadataUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: RecordingMetadataUpdateManyWithWhereWithoutSessionInput | RecordingMetadataUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: RecordingMetadataScalarWhereInput | RecordingMetadataScalarWhereInput[]
  }

  export type TranscriptUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput> | TranscriptCreateWithoutSessionInput[] | TranscriptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutSessionInput | TranscriptCreateOrConnectWithoutSessionInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutSessionInput | TranscriptUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TranscriptCreateManySessionInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutSessionInput | TranscriptUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutSessionInput | TranscriptUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput> | TelehealthParticipantCreateWithoutSessionInput[] | TelehealthParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TelehealthParticipantCreateOrConnectWithoutSessionInput | TelehealthParticipantCreateOrConnectWithoutSessionInput[]
    upsert?: TelehealthParticipantUpsertWithWhereUniqueWithoutSessionInput | TelehealthParticipantUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TelehealthParticipantCreateManySessionInputEnvelope
    set?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    disconnect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    delete?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    connect?: TelehealthParticipantWhereUniqueInput | TelehealthParticipantWhereUniqueInput[]
    update?: TelehealthParticipantUpdateWithWhereUniqueWithoutSessionInput | TelehealthParticipantUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TelehealthParticipantUpdateManyWithWhereWithoutSessionInput | TelehealthParticipantUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
  }

  export type RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput> | RecordingMetadataCreateWithoutSessionInput[] | RecordingMetadataUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RecordingMetadataCreateOrConnectWithoutSessionInput | RecordingMetadataCreateOrConnectWithoutSessionInput[]
    upsert?: RecordingMetadataUpsertWithWhereUniqueWithoutSessionInput | RecordingMetadataUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: RecordingMetadataCreateManySessionInputEnvelope
    set?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    disconnect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    delete?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    connect?: RecordingMetadataWhereUniqueInput | RecordingMetadataWhereUniqueInput[]
    update?: RecordingMetadataUpdateWithWhereUniqueWithoutSessionInput | RecordingMetadataUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: RecordingMetadataUpdateManyWithWhereWithoutSessionInput | RecordingMetadataUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: RecordingMetadataScalarWhereInput | RecordingMetadataScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput> | TranscriptCreateWithoutSessionInput[] | TranscriptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutSessionInput | TranscriptCreateOrConnectWithoutSessionInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutSessionInput | TranscriptUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TranscriptCreateManySessionInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutSessionInput | TranscriptUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutSessionInput | TranscriptUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type TelehealthSessionCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TelehealthSessionCreateWithoutParticipantsInput, TelehealthSessionUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutParticipantsInput
    connect?: TelehealthSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionParticipantsInput = {
    create?: XOR<UserCreateWithoutSessionParticipantsInput, UserUncheckedCreateWithoutSessionParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type TelehealthSessionUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutParticipantsInput, TelehealthSessionUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutParticipantsInput
    upsert?: TelehealthSessionUpsertWithoutParticipantsInput
    connect?: TelehealthSessionWhereUniqueInput
    update?: XOR<XOR<TelehealthSessionUpdateToOneWithWhereWithoutParticipantsInput, TelehealthSessionUpdateWithoutParticipantsInput>, TelehealthSessionUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutSessionParticipantsInput, UserUncheckedCreateWithoutSessionParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionParticipantsInput
    upsert?: UserUpsertWithoutSessionParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionParticipantsInput, UserUpdateWithoutSessionParticipantsInput>, UserUncheckedUpdateWithoutSessionParticipantsInput>
  }

  export type TelehealthSessionCreateNestedOneWithoutRecordingsInput = {
    create?: XOR<TelehealthSessionCreateWithoutRecordingsInput, TelehealthSessionUncheckedCreateWithoutRecordingsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutRecordingsInput
    connect?: TelehealthSessionWhereUniqueInput
  }

  export type TelehealthSessionUpdateOneRequiredWithoutRecordingsNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutRecordingsInput, TelehealthSessionUncheckedCreateWithoutRecordingsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutRecordingsInput
    upsert?: TelehealthSessionUpsertWithoutRecordingsInput
    connect?: TelehealthSessionWhereUniqueInput
    update?: XOR<XOR<TelehealthSessionUpdateToOneWithWhereWithoutRecordingsInput, TelehealthSessionUpdateWithoutRecordingsInput>, TelehealthSessionUncheckedUpdateWithoutRecordingsInput>
  }

  export type TelehealthSessionCreateNestedOneWithoutTranscriptsInput = {
    create?: XOR<TelehealthSessionCreateWithoutTranscriptsInput, TelehealthSessionUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutTranscriptsInput
    connect?: TelehealthSessionWhereUniqueInput
  }

  export type TelehealthSessionUpdateOneRequiredWithoutTranscriptsNestedInput = {
    create?: XOR<TelehealthSessionCreateWithoutTranscriptsInput, TelehealthSessionUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: TelehealthSessionCreateOrConnectWithoutTranscriptsInput
    upsert?: TelehealthSessionUpsertWithoutTranscriptsInput
    connect?: TelehealthSessionWhereUniqueInput
    update?: XOR<XOR<TelehealthSessionUpdateToOneWithWhereWithoutTranscriptsInput, TelehealthSessionUpdateWithoutTranscriptsInput>, TelehealthSessionUncheckedUpdateWithoutTranscriptsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumTelehealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TelehealthStatus | EnumTelehealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelehealthStatusFilter<$PrismaModel> | $Enums.TelehealthStatus
  }

  export type NestedEnumTelehealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TelehealthStatus | EnumTelehealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelehealthStatus[] | ListEnumTelehealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelehealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.TelehealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTelehealthStatusFilter<$PrismaModel>
    _max?: NestedEnumTelehealthStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutUserInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientCreateWithoutAssignedTherapistInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAssignedTherapistInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAssignedTherapistInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput>
  }

  export type PatientCreateManyAssignedTherapistInputEnvelope = {
    data: PatientCreateManyAssignedTherapistInput | PatientCreateManyAssignedTherapistInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutTherapistInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutTherapistInput = {
    id?: string
    patientId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutTherapistInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput>
  }

  export type AppointmentCreateManyTherapistInputEnvelope = {
    data: AppointmentCreateManyTherapistInput | AppointmentCreateManyTherapistInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutCreatedByInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    patientId: string
    therapistId: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AppointmentCreateManyCreatedByInputEnvelope = {
    data: AppointmentCreateManyCreatedByInput | AppointmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    reader?: UserCreateNestedOneWithoutReadMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    threadId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReaderInput = {
    id?: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReaderInput = {
    id?: string
    threadId: string
    senderId: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReaderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput>
  }

  export type MessageCreateManyReaderInputEnvelope = {
    data: MessageCreateManyReaderInput | MessageCreateManyReaderInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadParticipantCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutParticipantsInput
  }

  export type MessageThreadParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    threadId: string
    joinedAt?: Date | string
  }

  export type MessageThreadParticipantCreateOrConnectWithoutUserInput = {
    where: MessageThreadParticipantWhereUniqueInput
    create: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput>
  }

  export type MessageThreadParticipantCreateManyUserInputEnvelope = {
    data: MessageThreadParticipantCreateManyUserInput | MessageThreadParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCreatedByInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvoicesInput
    appointment?: AppointmentCreateNestedOneWithoutInvoiceInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    claim?: ClaimCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    claim?: ClaimUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceCreateManyCreatedByInputEnvelope = {
    data: InvoiceCreateManyCreatedByInput | InvoiceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SOAPNoteCreateWithoutTherapistInput = {
    id?: string
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSoapNotesInput
    appointment?: AppointmentCreateNestedOneWithoutSoapNoteInput
  }

  export type SOAPNoteUncheckedCreateWithoutTherapistInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteCreateOrConnectWithoutTherapistInput = {
    where: SOAPNoteWhereUniqueInput
    create: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput>
  }

  export type SOAPNoteCreateManyTherapistInputEnvelope = {
    data: SOAPNoteCreateManyTherapistInput | SOAPNoteCreateManyTherapistInput[]
    skipDuplicates?: boolean
  }

  export type TelehealthParticipantCreateWithoutUserInput = {
    id?: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
    session: TelehealthSessionCreateNestedOneWithoutParticipantsInput
  }

  export type TelehealthParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type TelehealthParticipantCreateOrConnectWithoutUserInput = {
    where: TelehealthParticipantWhereUniqueInput
    create: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput>
  }

  export type TelehealthParticipantCreateManyUserInputEnvelope = {
    data: TelehealthParticipantCreateManyUserInput | TelehealthParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PatientUpsertWithoutUserInput = {
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutUserInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUpsertWithWhereUniqueWithoutAssignedTherapistInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutAssignedTherapistInput, PatientUncheckedUpdateWithoutAssignedTherapistInput>
    create: XOR<PatientCreateWithoutAssignedTherapistInput, PatientUncheckedCreateWithoutAssignedTherapistInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutAssignedTherapistInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutAssignedTherapistInput, PatientUncheckedUpdateWithoutAssignedTherapistInput>
  }

  export type PatientUpdateManyWithWhereWithoutAssignedTherapistInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutAssignedTherapistInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    street?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    zipCode?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    emergencyContactEmail?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceGroupNumber?: StringNullableFilter<"Patient"> | string | null
    insuranceCopay?: FloatNullableFilter<"Patient"> | number | null
    insuranceDeductible?: FloatNullableFilter<"Patient"> | number | null
    medicalHistory?: StringNullableFilter<"Patient"> | string | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    assignedTherapistId?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutTherapistInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutTherapistInput, AppointmentUncheckedUpdateWithoutTherapistInput>
    create: XOR<AppointmentCreateWithoutTherapistInput, AppointmentUncheckedCreateWithoutTherapistInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutTherapistInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutTherapistInput, AppointmentUncheckedUpdateWithoutTherapistInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutTherapistInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutTherapistInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    therapistId?: StringFilter<"Appointment"> | string
    createdById?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    telehealthLink?: StringNullableFilter<"Appointment"> | string | null
    location?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutCreatedByInput, AppointmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutCreatedByInput, AppointmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    readerId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    priority?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isEncrypted?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReaderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReaderInput, MessageUncheckedUpdateWithoutReaderInput>
    create: XOR<MessageCreateWithoutReaderInput, MessageUncheckedCreateWithoutReaderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReaderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReaderInput, MessageUncheckedUpdateWithoutReaderInput>
  }

  export type MessageUpdateManyWithWhereWithoutReaderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReaderInput>
  }

  export type MessageThreadParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageThreadParticipantWhereUniqueInput
    update: XOR<MessageThreadParticipantUpdateWithoutUserInput, MessageThreadParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<MessageThreadParticipantCreateWithoutUserInput, MessageThreadParticipantUncheckedCreateWithoutUserInput>
  }

  export type MessageThreadParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageThreadParticipantWhereUniqueInput
    data: XOR<MessageThreadParticipantUpdateWithoutUserInput, MessageThreadParticipantUncheckedUpdateWithoutUserInput>
  }

  export type MessageThreadParticipantUpdateManyWithWhereWithoutUserInput = {
    where: MessageThreadParticipantScalarWhereInput
    data: XOR<MessageThreadParticipantUpdateManyMutationInput, MessageThreadParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageThreadParticipantScalarWhereInput = {
    AND?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
    OR?: MessageThreadParticipantScalarWhereInput[]
    NOT?: MessageThreadParticipantScalarWhereInput | MessageThreadParticipantScalarWhereInput[]
    id?: StringFilter<"MessageThreadParticipant"> | string
    threadId?: StringFilter<"MessageThreadParticipant"> | string
    userId?: StringFilter<"MessageThreadParticipant"> | string
    joinedAt?: DateTimeFilter<"MessageThreadParticipant"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    appointmentId?: StringNullableFilter<"Invoice"> | string | null
    createdById?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paymentDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type SOAPNoteUpsertWithWhereUniqueWithoutTherapistInput = {
    where: SOAPNoteWhereUniqueInput
    update: XOR<SOAPNoteUpdateWithoutTherapistInput, SOAPNoteUncheckedUpdateWithoutTherapistInput>
    create: XOR<SOAPNoteCreateWithoutTherapistInput, SOAPNoteUncheckedCreateWithoutTherapistInput>
  }

  export type SOAPNoteUpdateWithWhereUniqueWithoutTherapistInput = {
    where: SOAPNoteWhereUniqueInput
    data: XOR<SOAPNoteUpdateWithoutTherapistInput, SOAPNoteUncheckedUpdateWithoutTherapistInput>
  }

  export type SOAPNoteUpdateManyWithWhereWithoutTherapistInput = {
    where: SOAPNoteScalarWhereInput
    data: XOR<SOAPNoteUpdateManyMutationInput, SOAPNoteUncheckedUpdateManyWithoutTherapistInput>
  }

  export type SOAPNoteScalarWhereInput = {
    AND?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
    OR?: SOAPNoteScalarWhereInput[]
    NOT?: SOAPNoteScalarWhereInput | SOAPNoteScalarWhereInput[]
    id?: StringFilter<"SOAPNote"> | string
    patientId?: StringFilter<"SOAPNote"> | string
    therapistId?: StringFilter<"SOAPNote"> | string
    appointmentId?: StringNullableFilter<"SOAPNote"> | string | null
    date?: DateTimeFilter<"SOAPNote"> | Date | string
    subjective?: StringFilter<"SOAPNote"> | string
    objective?: StringFilter<"SOAPNote"> | string
    assessment?: StringFilter<"SOAPNote"> | string
    plan?: StringFilter<"SOAPNote"> | string
    signature?: StringNullableFilter<"SOAPNote"> | string | null
    signatureDate?: DateTimeNullableFilter<"SOAPNote"> | Date | string | null
    isLocked?: BoolFilter<"SOAPNote"> | boolean
    createdAt?: DateTimeFilter<"SOAPNote"> | Date | string
    updatedAt?: DateTimeFilter<"SOAPNote"> | Date | string
  }

  export type TelehealthParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TelehealthParticipantWhereUniqueInput
    update: XOR<TelehealthParticipantUpdateWithoutUserInput, TelehealthParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TelehealthParticipantCreateWithoutUserInput, TelehealthParticipantUncheckedCreateWithoutUserInput>
  }

  export type TelehealthParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TelehealthParticipantWhereUniqueInput
    data: XOR<TelehealthParticipantUpdateWithoutUserInput, TelehealthParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TelehealthParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TelehealthParticipantScalarWhereInput
    data: XOR<TelehealthParticipantUpdateManyMutationInput, TelehealthParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TelehealthParticipantScalarWhereInput = {
    AND?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
    OR?: TelehealthParticipantScalarWhereInput[]
    NOT?: TelehealthParticipantScalarWhereInput | TelehealthParticipantScalarWhereInput[]
    id?: StringFilter<"TelehealthParticipant"> | string
    sessionId?: StringFilter<"TelehealthParticipant"> | string
    userId?: StringFilter<"TelehealthParticipant"> | string
    role?: StringFilter<"TelehealthParticipant"> | string
    status?: StringFilter<"TelehealthParticipant"> | string
    joinedAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"TelehealthParticipant"> | Date | string | null
    connectionQuality?: StringNullableFilter<"TelehealthParticipant"> | string | null
    cameraEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    micEnabled?: BoolFilter<"TelehealthParticipant"> | boolean
    screenSharing?: BoolFilter<"TelehealthParticipant"> | boolean
    createdAt?: DateTimeFilter<"TelehealthParticipant"> | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPatientProfileInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatientProfileInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientProfileInput, UserUncheckedCreateWithoutPatientProfileInput>
  }

  export type UserCreateWithoutAssignedPatientsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedPatientsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedPatientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedPatientsInput, UserUncheckedCreateWithoutAssignedPatientsInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutInvoiceInput
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    claim?: ClaimCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    claim?: ClaimUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type SOAPNoteCreateWithoutPatientInput = {
    id?: string
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    therapist: UserCreateNestedOneWithoutCreatedNotesInput
    appointment?: AppointmentCreateNestedOneWithoutSoapNoteInput
  }

  export type SOAPNoteUncheckedCreateWithoutPatientInput = {
    id?: string
    therapistId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteCreateOrConnectWithoutPatientInput = {
    where: SOAPNoteWhereUniqueInput
    create: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput>
  }

  export type SOAPNoteCreateManyPatientInputEnvelope = {
    data: SOAPNoteCreateManyPatientInput | SOAPNoteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shares?: DocumentShareCreateNestedManyWithoutDocumentInput
    accessHistory?: DocumentAccessLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shares?: DocumentShareUncheckedCreateNestedManyWithoutDocumentInput
    accessHistory?: DocumentAccessLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutPatientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput>
  }

  export type DocumentCreateManyPatientInputEnvelope = {
    data: DocumentCreateManyPatientInput | DocumentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TelehealthSessionCreateWithoutPatientInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSessionInput
    participants?: TelehealthParticipantCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateWithoutPatientInput = {
    id?: string
    appointmentId?: string | null
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionCreateOrConnectWithoutPatientInput = {
    where: TelehealthSessionWhereUniqueInput
    create: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput>
  }

  export type TelehealthSessionCreateManyPatientInputEnvelope = {
    data: TelehealthSessionCreateManyPatientInput | TelehealthSessionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientProfileInput = {
    update: XOR<UserUpdateWithoutPatientProfileInput, UserUncheckedUpdateWithoutPatientProfileInput>
    create: XOR<UserCreateWithoutPatientProfileInput, UserUncheckedCreateWithoutPatientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientProfileInput, UserUncheckedUpdateWithoutPatientProfileInput>
  }

  export type UserUpdateWithoutPatientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedPatientsInput = {
    update: XOR<UserUpdateWithoutAssignedPatientsInput, UserUncheckedUpdateWithoutAssignedPatientsInput>
    create: XOR<UserCreateWithoutAssignedPatientsInput, UserUncheckedCreateWithoutAssignedPatientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedPatientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedPatientsInput, UserUncheckedUpdateWithoutAssignedPatientsInput>
  }

  export type UserUpdateWithoutAssignedPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type SOAPNoteUpsertWithWhereUniqueWithoutPatientInput = {
    where: SOAPNoteWhereUniqueInput
    update: XOR<SOAPNoteUpdateWithoutPatientInput, SOAPNoteUncheckedUpdateWithoutPatientInput>
    create: XOR<SOAPNoteCreateWithoutPatientInput, SOAPNoteUncheckedCreateWithoutPatientInput>
  }

  export type SOAPNoteUpdateWithWhereUniqueWithoutPatientInput = {
    where: SOAPNoteWhereUniqueInput
    data: XOR<SOAPNoteUpdateWithoutPatientInput, SOAPNoteUncheckedUpdateWithoutPatientInput>
  }

  export type SOAPNoteUpdateManyWithWhereWithoutPatientInput = {
    where: SOAPNoteScalarWhereInput
    data: XOR<SOAPNoteUpdateManyMutationInput, SOAPNoteUncheckedUpdateManyWithoutPatientInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutPatientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPatientInput, DocumentUncheckedUpdateWithoutPatientInput>
    create: XOR<DocumentCreateWithoutPatientInput, DocumentUncheckedCreateWithoutPatientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPatientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPatientInput, DocumentUncheckedUpdateWithoutPatientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPatientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPatientInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    patientId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    tags?: StringNullableListFilter<"Document">
    fileUrl?: StringNullableFilter<"Document"> | string | null
    fileName?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    isEncrypted?: BoolFilter<"Document"> | boolean
    signature?: StringNullableFilter<"Document"> | string | null
    signatureDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isSigned?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type TelehealthSessionUpsertWithWhereUniqueWithoutPatientInput = {
    where: TelehealthSessionWhereUniqueInput
    update: XOR<TelehealthSessionUpdateWithoutPatientInput, TelehealthSessionUncheckedUpdateWithoutPatientInput>
    create: XOR<TelehealthSessionCreateWithoutPatientInput, TelehealthSessionUncheckedCreateWithoutPatientInput>
  }

  export type TelehealthSessionUpdateWithWhereUniqueWithoutPatientInput = {
    where: TelehealthSessionWhereUniqueInput
    data: XOR<TelehealthSessionUpdateWithoutPatientInput, TelehealthSessionUncheckedUpdateWithoutPatientInput>
  }

  export type TelehealthSessionUpdateManyWithWhereWithoutPatientInput = {
    where: TelehealthSessionScalarWhereInput
    data: XOR<TelehealthSessionUpdateManyMutationInput, TelehealthSessionUncheckedUpdateManyWithoutPatientInput>
  }

  export type TelehealthSessionScalarWhereInput = {
    AND?: TelehealthSessionScalarWhereInput | TelehealthSessionScalarWhereInput[]
    OR?: TelehealthSessionScalarWhereInput[]
    NOT?: TelehealthSessionScalarWhereInput | TelehealthSessionScalarWhereInput[]
    id?: StringFilter<"TelehealthSession"> | string
    appointmentId?: StringNullableFilter<"TelehealthSession"> | string | null
    patientId?: StringFilter<"TelehealthSession"> | string
    roomId?: StringFilter<"TelehealthSession"> | string
    sessionUrl?: StringFilter<"TelehealthSession"> | string
    status?: EnumTelehealthStatusFilter<"TelehealthSession"> | $Enums.TelehealthStatus
    startedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelehealthSession"> | Date | string | null
    scheduledDuration?: IntFilter<"TelehealthSession"> | number
    actualDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    platform?: StringFilter<"TelehealthSession"> | string
    recordingEnabled?: BoolFilter<"TelehealthSession"> | boolean
    recordingUrl?: StringNullableFilter<"TelehealthSession"> | string | null
    recordingSize?: IntNullableFilter<"TelehealthSession"> | number | null
    recordingDuration?: IntNullableFilter<"TelehealthSession"> | number | null
    chatEnabled?: BoolFilter<"TelehealthSession"> | boolean
    screenShareEnabled?: BoolFilter<"TelehealthSession"> | boolean
    createdAt?: DateTimeFilter<"TelehealthSession"> | Date | string
    updatedAt?: DateTimeFilter<"TelehealthSession"> | Date | string
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutCreatedAppointmentsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAppointmentsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAppointmentsInput, UserUncheckedCreateWithoutCreatedAppointmentsInput>
  }

  export type SOAPNoteCreateWithoutAppointmentInput = {
    id?: string
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSoapNotesInput
    therapist: UserCreateNestedOneWithoutCreatedNotesInput
  }

  export type SOAPNoteUncheckedCreateWithoutAppointmentInput = {
    id?: string
    patientId: string
    therapistId: string
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteCreateOrConnectWithoutAppointmentInput = {
    where: SOAPNoteWhereUniqueInput
    create: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
  }

  export type InvoiceCreateWithoutAppointmentInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    claim?: ClaimCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAppointmentInput = {
    id?: string
    patientId: string
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    claim?: ClaimUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAppointmentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
  }

  export type TelehealthSessionCreateWithoutAppointmentInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSessionsInput
    participants?: TelehealthParticipantCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateWithoutAppointmentInput = {
    id?: string
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionCreateOrConnectWithoutAppointmentInput = {
    where: TelehealthSessionWhereUniqueInput
    create: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedAppointmentsInput = {
    update: XOR<UserUpdateWithoutCreatedAppointmentsInput, UserUncheckedUpdateWithoutCreatedAppointmentsInput>
    create: XOR<UserCreateWithoutCreatedAppointmentsInput, UserUncheckedCreateWithoutCreatedAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAppointmentsInput, UserUncheckedUpdateWithoutCreatedAppointmentsInput>
  }

  export type UserUpdateWithoutCreatedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SOAPNoteUpsertWithoutAppointmentInput = {
    update: XOR<SOAPNoteUpdateWithoutAppointmentInput, SOAPNoteUncheckedUpdateWithoutAppointmentInput>
    create: XOR<SOAPNoteCreateWithoutAppointmentInput, SOAPNoteUncheckedCreateWithoutAppointmentInput>
    where?: SOAPNoteWhereInput
  }

  export type SOAPNoteUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: SOAPNoteWhereInput
    data: XOR<SOAPNoteUpdateWithoutAppointmentInput, SOAPNoteUncheckedUpdateWithoutAppointmentInput>
  }

  export type SOAPNoteUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSoapNotesNestedInput
    therapist?: UserUpdateOneRequiredWithoutCreatedNotesNestedInput
  }

  export type SOAPNoteUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutAppointmentInput = {
    update: XOR<InvoiceUpdateWithoutAppointmentInput, InvoiceUncheckedUpdateWithoutAppointmentInput>
    create: XOR<InvoiceCreateWithoutAppointmentInput, InvoiceUncheckedCreateWithoutAppointmentInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutAppointmentInput, InvoiceUncheckedUpdateWithoutAppointmentInput>
  }

  export type InvoiceUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type TelehealthSessionUpsertWithoutAppointmentInput = {
    update: XOR<TelehealthSessionUpdateWithoutAppointmentInput, TelehealthSessionUncheckedUpdateWithoutAppointmentInput>
    create: XOR<TelehealthSessionCreateWithoutAppointmentInput, TelehealthSessionUncheckedCreateWithoutAppointmentInput>
    where?: TelehealthSessionWhereInput
  }

  export type TelehealthSessionUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: TelehealthSessionWhereInput
    data: XOR<TelehealthSessionUpdateWithoutAppointmentInput, TelehealthSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type TelehealthSessionUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSessionsNestedInput
    participants?: TelehealthParticipantUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PatientCreateWithoutSoapNotesInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutSoapNotesInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutSoapNotesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutSoapNotesInput, PatientUncheckedCreateWithoutSoapNotesInput>
  }

  export type UserCreateWithoutCreatedNotesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedNotesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedNotesInput, UserUncheckedCreateWithoutCreatedNotesInput>
  }

  export type AppointmentCreateWithoutSoapNoteInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutSoapNoteInput = {
    id?: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutSoapNoteInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutSoapNoteInput, AppointmentUncheckedCreateWithoutSoapNoteInput>
  }

  export type PatientUpsertWithoutSoapNotesInput = {
    update: XOR<PatientUpdateWithoutSoapNotesInput, PatientUncheckedUpdateWithoutSoapNotesInput>
    create: XOR<PatientCreateWithoutSoapNotesInput, PatientUncheckedCreateWithoutSoapNotesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutSoapNotesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutSoapNotesInput, PatientUncheckedUpdateWithoutSoapNotesInput>
  }

  export type PatientUpdateWithoutSoapNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutSoapNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutCreatedNotesInput = {
    update: XOR<UserUpdateWithoutCreatedNotesInput, UserUncheckedUpdateWithoutCreatedNotesInput>
    create: XOR<UserCreateWithoutCreatedNotesInput, UserUncheckedCreateWithoutCreatedNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedNotesInput, UserUncheckedUpdateWithoutCreatedNotesInput>
  }

  export type UserUpdateWithoutCreatedNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithoutSoapNoteInput = {
    update: XOR<AppointmentUpdateWithoutSoapNoteInput, AppointmentUncheckedUpdateWithoutSoapNoteInput>
    create: XOR<AppointmentCreateWithoutSoapNoteInput, AppointmentUncheckedCreateWithoutSoapNoteInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutSoapNoteInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutSoapNoteInput, AppointmentUncheckedUpdateWithoutSoapNoteInput>
  }

  export type AppointmentUpdateWithoutSoapNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutSoapNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type PatientCreateWithoutInvoicesInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type AppointmentCreateWithoutInvoiceInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    session?: TelehealthSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutInvoiceInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutInvoiceInput, AppointmentUncheckedCreateWithoutInvoiceInput>
  }

  export type UserCreateWithoutCreatedInvoicesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedInvoicesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutInvoiceInput = {
    id?: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date | string
    status?: $Enums.ClaimStatus
    amount: number
    approvedAmount?: number | null
    denialReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUncheckedCreateWithoutInvoiceInput = {
    id?: string
    patientId: string
    claimNumber: string
    insuranceProvider: string
    submissionDate: Date | string
    status?: $Enums.ClaimStatus
    amount: number
    approvedAmount?: number | null
    denialReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateOrConnectWithoutInvoiceInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AppointmentUpsertWithoutInvoiceInput = {
    update: XOR<AppointmentUpdateWithoutInvoiceInput, AppointmentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<AppointmentCreateWithoutInvoiceInput, AppointmentUncheckedCreateWithoutInvoiceInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutInvoiceInput, AppointmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type AppointmentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutCreatedInvoicesInput = {
    update: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type UserUpdateWithoutCreatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    cptCode?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
  }

  export type ClaimUpsertWithoutInvoiceInput = {
    update: XOR<ClaimUpdateWithoutInvoiceInput, ClaimUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ClaimCreateWithoutInvoiceInput, ClaimUncheckedCreateWithoutInvoiceInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutInvoiceInput, ClaimUncheckedUpdateWithoutInvoiceInput>
  }

  export type ClaimUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    claimNumber?: StringFieldUpdateOperationsInput | string
    insuranceProvider?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    amount?: FloatFieldUpdateOperationsInput | number
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvoicesInput
    appointment?: AppointmentCreateNestedOneWithoutInvoiceInput
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    claim?: ClaimCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claim?: ClaimUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    appointment?: AppointmentUpdateOneWithoutInvoiceNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    claim?: ClaimUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutClaimInput = {
    id?: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvoicesInput
    appointment?: AppointmentCreateNestedOneWithoutInvoiceInput
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClaimInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClaimInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClaimInput, InvoiceUncheckedCreateWithoutClaimInput>
  }

  export type InvoiceUpsertWithoutClaimInput = {
    update: XOR<InvoiceUpdateWithoutClaimInput, InvoiceUncheckedUpdateWithoutClaimInput>
    create: XOR<InvoiceCreateWithoutClaimInput, InvoiceUncheckedCreateWithoutClaimInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutClaimInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutClaimInput, InvoiceUncheckedUpdateWithoutClaimInput>
  }

  export type InvoiceUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    appointment?: AppointmentUpdateOneWithoutInvoiceNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type MessageCreateWithoutThreadInput = {
    id?: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    reader?: UserCreateNestedOneWithoutReadMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutThreadInput = {
    id?: string
    senderId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutThreadInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageCreateManyThreadInputEnvelope = {
    data: MessageCreateManyThreadInput | MessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadParticipantCreateWithoutThreadInput = {
    id?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMessageThreadParticipantsInput
  }

  export type MessageThreadParticipantUncheckedCreateWithoutThreadInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type MessageThreadParticipantCreateOrConnectWithoutThreadInput = {
    where: MessageThreadParticipantWhereUniqueInput
    create: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput>
  }

  export type MessageThreadParticipantCreateManyThreadInputEnvelope = {
    data: MessageThreadParticipantCreateManyThreadInput | MessageThreadParticipantCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
  }

  export type MessageUpdateManyWithWhereWithoutThreadInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type MessageThreadParticipantUpsertWithWhereUniqueWithoutThreadInput = {
    where: MessageThreadParticipantWhereUniqueInput
    update: XOR<MessageThreadParticipantUpdateWithoutThreadInput, MessageThreadParticipantUncheckedUpdateWithoutThreadInput>
    create: XOR<MessageThreadParticipantCreateWithoutThreadInput, MessageThreadParticipantUncheckedCreateWithoutThreadInput>
  }

  export type MessageThreadParticipantUpdateWithWhereUniqueWithoutThreadInput = {
    where: MessageThreadParticipantWhereUniqueInput
    data: XOR<MessageThreadParticipantUpdateWithoutThreadInput, MessageThreadParticipantUncheckedUpdateWithoutThreadInput>
  }

  export type MessageThreadParticipantUpdateManyWithWhereWithoutThreadInput = {
    where: MessageThreadParticipantScalarWhereInput
    data: XOR<MessageThreadParticipantUpdateManyMutationInput, MessageThreadParticipantUncheckedUpdateManyWithoutThreadInput>
  }

  export type MessageThreadCreateWithoutParticipantsInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutParticipantsInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutParticipantsInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutMessageThreadParticipantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageThreadParticipantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageThreadParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageThreadParticipantsInput, UserUncheckedCreateWithoutMessageThreadParticipantsInput>
  }

  export type MessageThreadUpsertWithoutParticipantsInput = {
    update: XOR<MessageThreadUpdateWithoutParticipantsInput, MessageThreadUncheckedUpdateWithoutParticipantsInput>
    create: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutParticipantsInput, MessageThreadUncheckedUpdateWithoutParticipantsInput>
  }

  export type MessageThreadUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type UserUpsertWithoutMessageThreadParticipantsInput = {
    update: XOR<UserUpdateWithoutMessageThreadParticipantsInput, UserUncheckedUpdateWithoutMessageThreadParticipantsInput>
    create: XOR<UserCreateWithoutMessageThreadParticipantsInput, UserUncheckedCreateWithoutMessageThreadParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageThreadParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageThreadParticipantsInput, UserUncheckedUpdateWithoutMessageThreadParticipantsInput>
  }

  export type UserUpdateWithoutMessageThreadParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageThreadParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageThreadCreateWithoutMessagesInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    participants?: MessageThreadParticipantCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    subject: string
    lastActivity?: Date | string
    isArchived?: boolean
    createdAt?: Date | string
    participants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutMessagesInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReadMessagesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadMessagesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadMessagesInput, UserUncheckedCreateWithoutReadMessagesInput>
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadUpsertWithoutMessagesInput = {
    update: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MessageThreadParticipantUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MessageThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReadMessagesInput = {
    update: XOR<UserUpdateWithoutReadMessagesInput, UserUncheckedUpdateWithoutReadMessagesInput>
    create: XOR<UserCreateWithoutReadMessagesInput, UserUncheckedCreateWithoutReadMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReadMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReadMessagesInput, UserUncheckedUpdateWithoutReadMessagesInput>
  }

  export type UserUpdateWithoutReadMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    isEncrypted?: BoolFilter<"MessageAttachment"> | boolean
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    reader?: UserCreateNestedOneWithoutReadMessagesInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    threadId: string
    senderId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    reader?: UserUpdateOneWithoutReadMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutDocumentsInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    sessions?: TelehealthSessionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDocumentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentShareCreateWithoutDocumentInput = {
    id?: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
  }

  export type DocumentShareUncheckedCreateWithoutDocumentInput = {
    id?: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
  }

  export type DocumentShareCreateOrConnectWithoutDocumentInput = {
    where: DocumentShareWhereUniqueInput
    create: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentShareCreateManyDocumentInputEnvelope = {
    data: DocumentShareCreateManyDocumentInput | DocumentShareCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentAccessLogCreateWithoutDocumentInput = {
    id?: string
    accessedAt?: Date | string
    action: string
  }

  export type DocumentAccessLogUncheckedCreateWithoutDocumentInput = {
    id?: string
    accessedAt?: Date | string
    action: string
  }

  export type DocumentAccessLogCreateOrConnectWithoutDocumentInput = {
    where: DocumentAccessLogWhereUniqueInput
    create: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAccessLogCreateManyDocumentInputEnvelope = {
    data: DocumentAccessLogCreateManyDocumentInput | DocumentAccessLogCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutDocumentsInput = {
    update: XOR<PatientUpdateWithoutDocumentsInput, PatientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDocumentsInput, PatientUncheckedUpdateWithoutDocumentsInput>
  }

  export type PatientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DocumentShareUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentShareWhereUniqueInput
    update: XOR<DocumentShareUpdateWithoutDocumentInput, DocumentShareUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentShareCreateWithoutDocumentInput, DocumentShareUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentShareUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentShareWhereUniqueInput
    data: XOR<DocumentShareUpdateWithoutDocumentInput, DocumentShareUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentShareUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentShareScalarWhereInput
    data: XOR<DocumentShareUpdateManyMutationInput, DocumentShareUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentShareScalarWhereInput = {
    AND?: DocumentShareScalarWhereInput | DocumentShareScalarWhereInput[]
    OR?: DocumentShareScalarWhereInput[]
    NOT?: DocumentShareScalarWhereInput | DocumentShareScalarWhereInput[]
    id?: StringFilter<"DocumentShare"> | string
    documentId?: StringFilter<"DocumentShare"> | string
    recipientEmail?: StringFilter<"DocumentShare"> | string
    shareType?: StringFilter<"DocumentShare"> | string
    expiresAt?: DateTimeNullableFilter<"DocumentShare"> | Date | string | null
    message?: StringNullableFilter<"DocumentShare"> | string | null
    createdAt?: DateTimeFilter<"DocumentShare"> | Date | string
  }

  export type DocumentAccessLogUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAccessLogWhereUniqueInput
    update: XOR<DocumentAccessLogUpdateWithoutDocumentInput, DocumentAccessLogUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentAccessLogCreateWithoutDocumentInput, DocumentAccessLogUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAccessLogUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAccessLogWhereUniqueInput
    data: XOR<DocumentAccessLogUpdateWithoutDocumentInput, DocumentAccessLogUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAccessLogUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentAccessLogScalarWhereInput
    data: XOR<DocumentAccessLogUpdateManyMutationInput, DocumentAccessLogUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentAccessLogScalarWhereInput = {
    AND?: DocumentAccessLogScalarWhereInput | DocumentAccessLogScalarWhereInput[]
    OR?: DocumentAccessLogScalarWhereInput[]
    NOT?: DocumentAccessLogScalarWhereInput | DocumentAccessLogScalarWhereInput[]
    id?: StringFilter<"DocumentAccessLog"> | string
    documentId?: StringFilter<"DocumentAccessLog"> | string
    accessedAt?: DateTimeFilter<"DocumentAccessLog"> | Date | string
    action?: StringFilter<"DocumentAccessLog"> | string
  }

  export type DocumentCreateWithoutSharesInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    accessHistory?: DocumentAccessLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSharesInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessHistory?: DocumentAccessLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSharesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSharesInput, DocumentUncheckedCreateWithoutSharesInput>
  }

  export type DocumentUpsertWithoutSharesInput = {
    update: XOR<DocumentUpdateWithoutSharesInput, DocumentUncheckedUpdateWithoutSharesInput>
    create: XOR<DocumentCreateWithoutSharesInput, DocumentUncheckedCreateWithoutSharesInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSharesInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSharesInput, DocumentUncheckedUpdateWithoutSharesInput>
  }

  export type DocumentUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    accessHistory?: DocumentAccessLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessHistory?: DocumentAccessLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateWithoutAccessHistoryInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    shares?: DocumentShareCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutAccessHistoryInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shares?: DocumentShareUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutAccessHistoryInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAccessHistoryInput, DocumentUncheckedCreateWithoutAccessHistoryInput>
  }

  export type DocumentUpsertWithoutAccessHistoryInput = {
    update: XOR<DocumentUpdateWithoutAccessHistoryInput, DocumentUncheckedUpdateWithoutAccessHistoryInput>
    create: XOR<DocumentCreateWithoutAccessHistoryInput, DocumentUncheckedCreateWithoutAccessHistoryInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutAccessHistoryInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutAccessHistoryInput, DocumentUncheckedUpdateWithoutAccessHistoryInput>
  }

  export type DocumentUpdateWithoutAccessHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    shares?: DocumentShareUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAccessHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: DocumentShareUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type AppointmentCreateWithoutSessionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    therapist: UserCreateNestedOneWithoutAppointmentsInput
    createdBy: UserCreateNestedOneWithoutCreatedAppointmentsInput
    soapNote?: SOAPNoteCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutSessionInput = {
    id?: string
    patientId: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soapNote?: SOAPNoteUncheckedCreateNestedOneWithoutAppointmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutSessionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutSessionInput, AppointmentUncheckedCreateWithoutSessionInput>
  }

  export type PatientCreateWithoutSessionsInput = {
    id?: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientProfileInput
    assignedTherapist?: UserCreateNestedOneWithoutAssignedPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteCreateNestedManyWithoutPatientInput
    documents?: DocumentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutSessionsInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    assignedTherapistId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    soapNotes?: SOAPNoteUncheckedCreateNestedManyWithoutPatientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutSessionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutSessionsInput, PatientUncheckedCreateWithoutSessionsInput>
  }

  export type TelehealthParticipantCreateWithoutSessionInput = {
    id?: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionParticipantsInput
  }

  export type TelehealthParticipantUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type TelehealthParticipantCreateOrConnectWithoutSessionInput = {
    where: TelehealthParticipantWhereUniqueInput
    create: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput>
  }

  export type TelehealthParticipantCreateManySessionInputEnvelope = {
    data: TelehealthParticipantCreateManySessionInput | TelehealthParticipantCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type RecordingMetadataCreateWithoutSessionInput = {
    id?: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
  }

  export type RecordingMetadataUncheckedCreateWithoutSessionInput = {
    id?: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
  }

  export type RecordingMetadataCreateOrConnectWithoutSessionInput = {
    where: RecordingMetadataWhereUniqueInput
    create: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput>
  }

  export type RecordingMetadataCreateManySessionInputEnvelope = {
    data: RecordingMetadataCreateManySessionInput | RecordingMetadataCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutSessionInput = {
    id?: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutSessionInput = {
    id?: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutSessionInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput>
  }

  export type TranscriptCreateManySessionInputEnvelope = {
    data: TranscriptCreateManySessionInput | TranscriptCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithoutSessionInput = {
    update: XOR<AppointmentUpdateWithoutSessionInput, AppointmentUncheckedUpdateWithoutSessionInput>
    create: XOR<AppointmentCreateWithoutSessionInput, AppointmentUncheckedCreateWithoutSessionInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutSessionInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutSessionInput, AppointmentUncheckedUpdateWithoutSessionInput>
  }

  export type AppointmentUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type PatientUpsertWithoutSessionsInput = {
    update: XOR<PatientUpdateWithoutSessionsInput, PatientUncheckedUpdateWithoutSessionsInput>
    create: XOR<PatientCreateWithoutSessionsInput, PatientUncheckedCreateWithoutSessionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutSessionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutSessionsInput, PatientUncheckedUpdateWithoutSessionsInput>
  }

  export type PatientUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    assignedTherapist?: UserUpdateOneWithoutAssignedPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTherapistId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TelehealthParticipantUpsertWithWhereUniqueWithoutSessionInput = {
    where: TelehealthParticipantWhereUniqueInput
    update: XOR<TelehealthParticipantUpdateWithoutSessionInput, TelehealthParticipantUncheckedUpdateWithoutSessionInput>
    create: XOR<TelehealthParticipantCreateWithoutSessionInput, TelehealthParticipantUncheckedCreateWithoutSessionInput>
  }

  export type TelehealthParticipantUpdateWithWhereUniqueWithoutSessionInput = {
    where: TelehealthParticipantWhereUniqueInput
    data: XOR<TelehealthParticipantUpdateWithoutSessionInput, TelehealthParticipantUncheckedUpdateWithoutSessionInput>
  }

  export type TelehealthParticipantUpdateManyWithWhereWithoutSessionInput = {
    where: TelehealthParticipantScalarWhereInput
    data: XOR<TelehealthParticipantUpdateManyMutationInput, TelehealthParticipantUncheckedUpdateManyWithoutSessionInput>
  }

  export type RecordingMetadataUpsertWithWhereUniqueWithoutSessionInput = {
    where: RecordingMetadataWhereUniqueInput
    update: XOR<RecordingMetadataUpdateWithoutSessionInput, RecordingMetadataUncheckedUpdateWithoutSessionInput>
    create: XOR<RecordingMetadataCreateWithoutSessionInput, RecordingMetadataUncheckedCreateWithoutSessionInput>
  }

  export type RecordingMetadataUpdateWithWhereUniqueWithoutSessionInput = {
    where: RecordingMetadataWhereUniqueInput
    data: XOR<RecordingMetadataUpdateWithoutSessionInput, RecordingMetadataUncheckedUpdateWithoutSessionInput>
  }

  export type RecordingMetadataUpdateManyWithWhereWithoutSessionInput = {
    where: RecordingMetadataScalarWhereInput
    data: XOR<RecordingMetadataUpdateManyMutationInput, RecordingMetadataUncheckedUpdateManyWithoutSessionInput>
  }

  export type RecordingMetadataScalarWhereInput = {
    AND?: RecordingMetadataScalarWhereInput | RecordingMetadataScalarWhereInput[]
    OR?: RecordingMetadataScalarWhereInput[]
    NOT?: RecordingMetadataScalarWhereInput | RecordingMetadataScalarWhereInput[]
    id?: StringFilter<"RecordingMetadata"> | string
    sessionId?: StringFilter<"RecordingMetadata"> | string
    fileName?: StringFilter<"RecordingMetadata"> | string
    fileSize?: IntFilter<"RecordingMetadata"> | number
    duration?: IntFilter<"RecordingMetadata"> | number
    mimeType?: StringFilter<"RecordingMetadata"> | string
    downloadUrl?: StringNullableFilter<"RecordingMetadata"> | string | null
    createdAt?: DateTimeFilter<"RecordingMetadata"> | Date | string
  }

  export type TranscriptUpsertWithWhereUniqueWithoutSessionInput = {
    where: TranscriptWhereUniqueInput
    update: XOR<TranscriptUpdateWithoutSessionInput, TranscriptUncheckedUpdateWithoutSessionInput>
    create: XOR<TranscriptCreateWithoutSessionInput, TranscriptUncheckedCreateWithoutSessionInput>
  }

  export type TranscriptUpdateWithWhereUniqueWithoutSessionInput = {
    where: TranscriptWhereUniqueInput
    data: XOR<TranscriptUpdateWithoutSessionInput, TranscriptUncheckedUpdateWithoutSessionInput>
  }

  export type TranscriptUpdateManyWithWhereWithoutSessionInput = {
    where: TranscriptScalarWhereInput
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyWithoutSessionInput>
  }

  export type TranscriptScalarWhereInput = {
    AND?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    OR?: TranscriptScalarWhereInput[]
    NOT?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    id?: StringFilter<"Transcript"> | string
    sessionId?: StringFilter<"Transcript"> | string
    content?: StringFilter<"Transcript"> | string
    isEncrypted?: BoolFilter<"Transcript"> | boolean
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    updatedAt?: DateTimeFilter<"Transcript"> | Date | string
  }

  export type TelehealthSessionCreateWithoutParticipantsInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSessionInput
    patient: PatientCreateNestedOneWithoutSessionsInput
    recordings?: RecordingMetadataCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateWithoutParticipantsInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordings?: RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionCreateOrConnectWithoutParticipantsInput = {
    where: TelehealthSessionWhereUniqueInput
    create: XOR<TelehealthSessionCreateWithoutParticipantsInput, TelehealthSessionUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutSessionParticipantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
  }

  export type UserUncheckedCreateWithoutSessionParticipantsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
  }

  export type UserCreateOrConnectWithoutSessionParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionParticipantsInput, UserUncheckedCreateWithoutSessionParticipantsInput>
  }

  export type TelehealthSessionUpsertWithoutParticipantsInput = {
    update: XOR<TelehealthSessionUpdateWithoutParticipantsInput, TelehealthSessionUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TelehealthSessionCreateWithoutParticipantsInput, TelehealthSessionUncheckedCreateWithoutParticipantsInput>
    where?: TelehealthSessionWhereInput
  }

  export type TelehealthSessionUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TelehealthSessionWhereInput
    data: XOR<TelehealthSessionUpdateWithoutParticipantsInput, TelehealthSessionUncheckedUpdateWithoutParticipantsInput>
  }

  export type TelehealthSessionUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSessionNestedInput
    patient?: PatientUpdateOneRequiredWithoutSessionsNestedInput
    recordings?: RecordingMetadataUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordings?: RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutSessionParticipantsInput = {
    update: XOR<UserUpdateWithoutSessionParticipantsInput, UserUncheckedUpdateWithoutSessionParticipantsInput>
    create: XOR<UserCreateWithoutSessionParticipantsInput, UserUncheckedCreateWithoutSessionParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionParticipantsInput, UserUncheckedUpdateWithoutSessionParticipantsInput>
  }

  export type UserUpdateWithoutSessionParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
  }

  export type TelehealthSessionCreateWithoutRecordingsInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSessionInput
    patient: PatientCreateNestedOneWithoutSessionsInput
    participants?: TelehealthParticipantCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateWithoutRecordingsInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionCreateOrConnectWithoutRecordingsInput = {
    where: TelehealthSessionWhereUniqueInput
    create: XOR<TelehealthSessionCreateWithoutRecordingsInput, TelehealthSessionUncheckedCreateWithoutRecordingsInput>
  }

  export type TelehealthSessionUpsertWithoutRecordingsInput = {
    update: XOR<TelehealthSessionUpdateWithoutRecordingsInput, TelehealthSessionUncheckedUpdateWithoutRecordingsInput>
    create: XOR<TelehealthSessionCreateWithoutRecordingsInput, TelehealthSessionUncheckedCreateWithoutRecordingsInput>
    where?: TelehealthSessionWhereInput
  }

  export type TelehealthSessionUpdateToOneWithWhereWithoutRecordingsInput = {
    where?: TelehealthSessionWhereInput
    data: XOR<TelehealthSessionUpdateWithoutRecordingsInput, TelehealthSessionUncheckedUpdateWithoutRecordingsInput>
  }

  export type TelehealthSessionUpdateWithoutRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSessionNestedInput
    patient?: PatientUpdateOneRequiredWithoutSessionsNestedInput
    participants?: TelehealthParticipantUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateWithoutRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionCreateWithoutTranscriptsInput = {
    id?: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSessionInput
    patient: PatientCreateNestedOneWithoutSessionsInput
    participants?: TelehealthParticipantCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionUncheckedCreateWithoutTranscriptsInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TelehealthParticipantUncheckedCreateNestedManyWithoutSessionInput
    recordings?: RecordingMetadataUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TelehealthSessionCreateOrConnectWithoutTranscriptsInput = {
    where: TelehealthSessionWhereUniqueInput
    create: XOR<TelehealthSessionCreateWithoutTranscriptsInput, TelehealthSessionUncheckedCreateWithoutTranscriptsInput>
  }

  export type TelehealthSessionUpsertWithoutTranscriptsInput = {
    update: XOR<TelehealthSessionUpdateWithoutTranscriptsInput, TelehealthSessionUncheckedUpdateWithoutTranscriptsInput>
    create: XOR<TelehealthSessionCreateWithoutTranscriptsInput, TelehealthSessionUncheckedCreateWithoutTranscriptsInput>
    where?: TelehealthSessionWhereInput
  }

  export type TelehealthSessionUpdateToOneWithWhereWithoutTranscriptsInput = {
    where?: TelehealthSessionWhereInput
    data: XOR<TelehealthSessionUpdateWithoutTranscriptsInput, TelehealthSessionUncheckedUpdateWithoutTranscriptsInput>
  }

  export type TelehealthSessionUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSessionNestedInput
    patient?: PatientUpdateOneRequiredWithoutSessionsNestedInput
    participants?: TelehealthParticipantUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    patientProfile?: PatientCreateNestedOneWithoutUserInput
    assignedPatients?: PatientCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    readMessages?: MessageCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    mustChangePassword?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    patientProfile?: PatientUncheckedCreateNestedOneWithoutUserInput
    assignedPatients?: PatientUncheckedCreateNestedManyWithoutAssignedTherapistInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTherapistInput
    createdAppointments?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    readMessages?: MessageUncheckedCreateNestedManyWithoutReaderInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedCreateNestedManyWithoutUserInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    createdNotes?: SOAPNoteUncheckedCreateNestedManyWithoutTherapistInput
    sessionParticipants?: TelehealthParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    patientProfile?: PatientUncheckedUpdateOneWithoutUserNestedInput
    assignedPatients?: PatientUncheckedUpdateManyWithoutAssignedTherapistNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTherapistNestedInput
    createdAppointments?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    readMessages?: MessageUncheckedUpdateManyWithoutReaderNestedInput
    messageThreadParticipants?: MessageThreadParticipantUncheckedUpdateManyWithoutUserNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    createdNotes?: SOAPNoteUncheckedUpdateManyWithoutTherapistNestedInput
    sessionParticipants?: TelehealthParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PatientCreateManyAssignedTherapistInput = {
    id?: string
    userId: string
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactRelationship?: string | null
    emergencyContactPhone?: string | null
    emergencyContactEmail?: string | null
    insuranceProvider?: string | null
    insurancePolicyNumber?: string | null
    insuranceGroupNumber?: string | null
    insuranceCopay?: number | null
    insuranceDeductible?: number | null
    medicalHistory?: string | null
    allergies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyTherapistInput = {
    id?: string
    patientId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyCreatedByInput = {
    id?: string
    patientId: string
    therapistId: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    threadId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyReaderInput = {
    id?: string
    threadId: string
    senderId: string
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageThreadParticipantCreateManyUserInput = {
    id?: string
    threadId: string
    joinedAt?: Date | string
  }

  export type InvoiceCreateManyCreatedByInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteCreateManyTherapistInput = {
    id?: string
    patientId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelehealthParticipantCreateManyUserInput = {
    id?: string
    sessionId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutAssignedTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUpdateManyWithoutPatientNestedInput
    documents?: DocumentUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAssignedTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    soapNotes?: SOAPNoteUncheckedUpdateManyWithoutPatientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPatientNestedInput
    sessions?: TelehealthSessionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutAssignedTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroupNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCopay?: NullableFloatFieldUpdateOperationsInput | number | null
    insuranceDeductible?: NullableFloatFieldUpdateOperationsInput | number | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    reader?: UserUpdateOneWithoutReadMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutReaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type MessageThreadParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    appointment?: AppointmentUpdateOneWithoutInvoiceNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSoapNotesNestedInput
    appointment?: AppointmentUpdateOneWithoutSoapNoteNestedInput
  }

  export type SOAPNoteUncheckedUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteUncheckedUpdateManyWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TelehealthSessionUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type TelehealthParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    therapistId: string
    createdById: string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    notes?: string | null
    telehealthLink?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: string
    appointmentId?: string | null
    createdById: string
    invoiceNumber: string
    date: Date | string
    dueDate: Date | string
    subtotal: number
    tax: number
    total: number
    status?: $Enums.InvoiceStatus
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOAPNoteCreateManyPatientInput = {
    id?: string
    therapistId: string
    appointmentId?: string | null
    date: Date | string
    subjective: string
    objective: string
    assessment: string
    plan: string
    signature?: string | null
    signatureDate?: Date | string | null
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyPatientInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.DocumentCategory
    tags?: DocumentCreatetagsInput | string[]
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isEncrypted?: boolean
    signature?: string | null
    signatureDate?: Date | string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelehealthSessionCreateManyPatientInput = {
    id?: string
    appointmentId?: string | null
    roomId: string
    sessionUrl: string
    status?: $Enums.TelehealthStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scheduledDuration: number
    actualDuration?: number | null
    platform?: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingSize?: number | null
    recordingDuration?: number | null
    chatEnabled?: boolean
    screenShareEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    therapist?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAppointmentsNestedInput
    soapNote?: SOAPNoteUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soapNote?: SOAPNoteUncheckedUpdateOneWithoutAppointmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutAppointmentNestedInput
    session?: TelehealthSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    telehealthLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutInvoiceNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    claim?: ClaimUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    therapist?: UserUpdateOneRequiredWithoutCreatedNotesNestedInput
    appointment?: AppointmentUpdateOneWithoutSoapNoteNestedInput
  }

  export type SOAPNoteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOAPNoteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subjective?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    assessment?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: DocumentShareUpdateManyWithoutDocumentNestedInput
    accessHistory?: DocumentAccessLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: DocumentShareUncheckedUpdateManyWithoutDocumentNestedInput
    accessHistory?: DocumentAccessLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    tags?: DocumentUpdatetagsInput | string[]
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    signatureDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthSessionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSessionNestedInput
    participants?: TelehealthParticipantUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TelehealthParticipantUncheckedUpdateManyWithoutSessionNestedInput
    recordings?: RecordingMetadataUncheckedUpdateManyWithoutSessionNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TelehealthSessionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: StringFieldUpdateOperationsInput | string
    sessionUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumTelehealthStatusFieldUpdateOperationsInput | $Enums.TelehealthStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDuration?: IntFieldUpdateOperationsInput | number
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingSize?: NullableIntFieldUpdateOperationsInput | number | null
    recordingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenShareEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    cptCode?: string | null
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cptCode?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type MessageCreateManyThreadInput = {
    id?: string
    senderId: string
    readerId?: string | null
    content: string
    priority?: string
    isRead?: boolean
    isEncrypted?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageThreadParticipantCreateManyThreadInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type MessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    reader?: UserUpdateOneWithoutReadMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    readerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageThreadParticipantsNestedInput
  }

  export type MessageThreadParticipantUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadParticipantUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    isEncrypted?: boolean
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareCreateManyDocumentInput = {
    id?: string
    recipientEmail: string
    shareType: string
    expiresAt?: Date | string | null
    message?: string | null
    createdAt?: Date | string
  }

  export type DocumentAccessLogCreateManyDocumentInput = {
    id?: string
    accessedAt?: Date | string
    action: string
  }

  export type DocumentShareUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentShareUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAccessLogUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAccessLogUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAccessLogUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type TelehealthParticipantCreateManySessionInput = {
    id?: string
    userId: string
    role: string
    status?: string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    connectionQuality?: string | null
    cameraEnabled?: boolean
    micEnabled?: boolean
    screenSharing?: boolean
    createdAt?: Date | string
  }

  export type RecordingMetadataCreateManySessionInput = {
    id?: string
    fileName: string
    fileSize: number
    duration: number
    mimeType: string
    downloadUrl?: string | null
    createdAt?: Date | string
  }

  export type TranscriptCreateManySessionInput = {
    id?: string
    content: string
    isEncrypted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelehealthParticipantUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionParticipantsNestedInput
  }

  export type TelehealthParticipantUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelehealthParticipantUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectionQuality?: NullableStringFieldUpdateOperationsInput | string | null
    cameraEnabled?: BoolFieldUpdateOperationsInput | boolean
    micEnabled?: BoolFieldUpdateOperationsInput | boolean
    screenSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingMetadataUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}